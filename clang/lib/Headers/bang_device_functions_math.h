/*===-----------------------------------------------------------------------===
 *
 * Copyright (C) [2020] by Cambricon, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */
#ifndef __BANG_DEVICE_FUNCTIONS_MATH_H__
#define __BANG_DEVICE_FUNCTIONS_MATH_H__

#ifndef __BANG__
#error "This file is for BANG compilation only."
#endif  // __BANG__

#include <bang_device_types.h>
#include <bang_device_functions.h>

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector add operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_add(half* dst,
                                                    half* src0,
                                                    half* src1,
                                                    int elem_count) {
  __mlvm_stream_add_f16(dst, src0, src1, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_add_tz(half* dst,
                                                       half* src0,
                                                       half* src1,
                                                       int elem_count) {
  __mlvm_stream_add_tz_f16(dst, src0, src1, elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_add(float* dst,
                                                    float* src0,
                                                    float* src1,
                                                    int elem_count) {
  __mlvm_stream_add_f32(dst, src0, src1, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_add_tz(float* dst,
                                                       float* src0,
                                                       float* src1,
                                                       int elem_count) {
  __mlvm_stream_add_tz_f32(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 200
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_add(bfloat16_t* dst,
                                                    bfloat16_t* src0,
                                                    bfloat16_t* src1,
                                                    int elem_count) {
  __mlvm_stream_add_bf16(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector sub operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_sub(half* dst,
                                                    half* src0,
                                                    half* src1,
                                                    int elem_count) {
  __mlvm_stream_sub_f16(dst, src0, src1, elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_sub(float* dst,
                                                    float* src0,
                                                    float* src1,
                                                    int elem_count) {
  __mlvm_stream_sub_f32(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 200
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_sub(bfloat16_t* dst,
                                                    bfloat16_t* src0,
                                                    bfloat16_t* src1,
                                                    int elem_count) {
  __mlvm_stream_sub_bf16(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector mul operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_mul(half* dst,
                                                    half* src0,
                                                    half* src1,
                                                    int elem_count) {
  __mlvm_stream_mul_f16(dst, src0, src1, elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_mul(float* dst,
                                                    float* src0,
                                                    float* src1,
                                                    int elem_count) {
  __mlvm_stream_mul_f32(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 200
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_mul(bfloat16_t* dst,
                                                    bfloat16_t* src0,
                                                    bfloat16_t* src1,
                                                    int elem_count) {
  __mlvm_stream_mul_bf16(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector div operation
// -----------------------------------------------------------------------------
#if (__BANG_ARCH__ != 303) && (__BANG_ARCH__ != 306)
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_div(half* dst,
                                                    half* src0,
                                                    half* src1,
                                                    half* src_addition,
                                                    int elem_count) {
  __mlvm_stream_active_abs_f16(src_addition, src1, elem_count);
  __mlvm_stream_active_recip_f16(dst, src_addition, elem_count);
  __mlvm_stream_active_sign_f16(src_addition, src1, elem_count);
  __mlvm_stream_mul_f16(src_addition, src_addition, dst, elem_count);
  __mlvm_stream_mul_f16(dst, src0, src_addition, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_div(float* dst,
                                                    float* src0,
                                                    float* src1,
                                                    float* src_addition,
                                                    int elem_count) {
  __mlvm_stream_active_abs_f32(src_addition, src1, elem_count);
  __mlvm_stream_active_recip_f32(dst, src_addition, elem_count);
  __mlvm_stream_active_sign_f32(src_addition, src1, elem_count);
  __mlvm_stream_mul_f32(src_addition, src_addition, dst, elem_count);
  __mlvm_stream_mul_f32(dst, src0, src_addition, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

#if (__BANG_ARCH__ >= 300) && (__BANG_ARCH__ != 372)
static __mlu_func__ __mlu_builtin__ void __bang_div(half* dst,
                                                    half* src0,
                                                    half* src1,
                                                    int elem_count) {
  __mlvm_stream_div_f16(dst, src0, src1, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_div(float* dst,
                                                    float* src0,
                                                    float* src1,
                                                    int elem_count) {
  __mlvm_stream_div_f32(dst, src0, src1, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_div(short* dst,
                                                    short* src0,
                                                    short* src1,
                                                    int elem_count) {
  __mlvm_stream_div_s16(dst, src0, src1, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_div(int* dst,
                                                    int* src0,
                                                    int* src1,
                                                    int elem_count) {
  __mlvm_stream_div_s32(dst, src0, src1, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_div(unsigned short* dst,
                                                    unsigned short* src0,
                                                    unsigned short* src1,
                                                    int elem_count) {
  __mlvm_stream_div_u16(dst, src0, src1, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_div(unsigned int* dst,
                                                    unsigned int* src0,
                                                    unsigned int* src1,
                                                    int elem_count) {
  __mlvm_stream_div_u32(dst, src0, src1, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_div(half* dst,
                                                    half* src,
                                                    half const_value,
                                                    int elem_count) {
  __mlvm_stream_div_scalar_f16(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_div(float* dst,
                                                    float* src,
                                                    float const_value,
                                                    int elem_count) {
  __mlvm_stream_div_scalar_f32(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_div(short* dst,
                                                    short* src,
                                                    short const_value,
                                                    int elem_count) {
  __mlvm_stream_div_scalar_s16(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_div(int* dst,
                                                    int* src,
                                                    int const_value,
                                                    int elem_count) {
  __mlvm_stream_div_scalar_s32(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_div(unsigned short* dst,
                                                    unsigned short* src,
                                                    unsigned short const_value,
                                                    int elem_count) {
  __mlvm_stream_div_scalar_u16(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_div(unsigned int* dst,
                                                    unsigned int* src,
                                                    unsigned int const_value,
                                                    int elem_count) {
  __mlvm_stream_div_scalar_u32(dst, src, const_value, elem_count);
}
#endif  // (__BANG_ARCH__ >= 300) && (__BANG_ARCH__ != 372)

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream rem operation
// -----------------------------------------------------------------------------
#if (__BANG_ARCH__ >= 300) && (__BANG_ARCH__ != 372)
static __mlu_func__ __mlu_builtin__ void __bang_rem(short* dst,
                                                    short* src0,
                                                    short* src1,
                                                    int elem_count) {
  __mlvm_stream_rem_s16(dst, src0, src1, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_rem(int* dst,
                                                    int* src0,
                                                    int* src1,
                                                    int elem_count) {
  __mlvm_stream_rem_s32(dst, src0, src1, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_rem(unsigned short* dst,
                                                    unsigned short* src0,
                                                    unsigned short* src1,
                                                    int elem_count) {
  __mlvm_stream_rem_u16(dst, src0, src1, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_rem(unsigned int* dst,
                                                    unsigned int* src0,
                                                    unsigned int* src1,
                                                    int elem_count) {
  __mlvm_stream_rem_u32(dst, src0, src1, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_rem(short* dst,
                                                    short* src,
                                                    short const_value,
                                                    int elem_count) {
  __mlvm_stream_rem_scalar_s16(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_rem(int* dst,
                                                    int* src,
                                                    int const_value,
                                                    int elem_count) {
  __mlvm_stream_rem_scalar_s32(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_rem(unsigned short* dst,
                                                    unsigned short* src,
                                                    unsigned short const_value,
                                                    int elem_count) {
  __mlvm_stream_rem_scalar_u16(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_rem(unsigned int* dst,
                                                    unsigned int* src,
                                                    unsigned int const_value,
                                                    int elem_count) {
  __mlvm_stream_rem_scalar_u32(dst, src, const_value, elem_count);
}
#endif  // (__BANG_ARCH__ >= 300) && (__BANG_ARCH__ != 372)

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector add const value operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_add_const(half* dst,
                                                          half* src,
                                                          half const_value,
                                                          int elem_count) {
  __mlvm_stream_add_const_f16(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_add_scalar(half* dst,
                                                           half* src,
                                                           half const_value,
                                                           int elem_count) {
  __mlvm_stream_add_const_f16(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_add_const(float* dst,
                                                          float* src,
                                                          float const_value,
                                                          int elem_count) {
  __mlvm_stream_add_const_f32(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_add_scalar(float* dst,
                                                           float* src,
                                                           float const_value,
                                                           int elem_count) {
  __mlvm_stream_add_const_f32(dst, src, const_value, elem_count);
}
#endif
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_add_scalar(bfloat16_t* dst,
                                                           bfloat16_t* src,
                                                           bfloat16_t const_value,
                                                           int elem_count) {
  __asm__ ("add.scalar.nram.bf16 \t[%[dst]], [%[src0]], %[src1], %[size];\n\t"
                   ::[dst] "r"(dst), [src0] "r"(src), [src1] "r"(const_value),
                   [size] "r"(elem_count));
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream scalar operation
// -----------------------------------------------------------------------------

#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ void __bang_maxeq_scalar(half* dst,
                                                             half* src,
                                                             half const_value,
                                                             int elem_count) {
  __mlvm_stream_maxeq_scalar_f16(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_maxeq_scalar(float* dst,
                                                             float* src,
                                                             float const_value,
                                                             int elem_count) {
  __mlvm_stream_maxeq_scalar_f32(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_mineq_scalar(half* dst,
                                                             half* src,
                                                             half const_value,
                                                             int elem_count) {
  __mlvm_stream_mineq_scalar_f16(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_mineq_scalar(float* dst,
                                                             float* src,
                                                             float const_value,
                                                             int elem_count) {
  __mlvm_stream_mineq_scalar_f32(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_eq_scalar(float* dst,
                                                          float* src,
                                                          float const_value,
                                                          int elem_count) {
  __mlvm_stream_eq_scalar_f32(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_eq_scalar(half* dst,
                                                          half* src,
                                                          half const_value,
                                                          int elem_count) {
  __mlvm_stream_eq_scalar_f16(dst, src, const_value, elem_count);
}

#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_eq_scalar(bfloat16_t* dst,
                                                          bfloat16_t* src,
                                                          bfloat16_t const_value,
                                                          int elem_count) {
  __asm__ ("eq.scalar.nram.bf16 \t[%[dst]], [%[src0]], %[src1], %[size];\n\t"
           ::[dst] "r"(dst), [src0] "r"(src), [src1] "r"(const_value),
           [size] "r"(elem_count));
}
#endif  // __BANG_ARCH__ >= 392
static __mlu_func__ __mlu_builtin__ void __bang_ne_scalar(float* dst,
                                                          float* src,
                                                          float const_value,
                                                          int elem_count) {
  __mlvm_stream_ne_scalar_f32(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_ne_scalar(half* dst,
                                                          half* src,
                                                          half const_value,
                                                          int elem_count) {
  __mlvm_stream_ne_scalar_f16(dst, src, const_value, elem_count);
}

#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_ne_scalar(bfloat16_t* dst,
                                                          bfloat16_t* src,
                                                          bfloat16_t const_value,
                                                          int elem_count) {
  __asm__ ("ne.scalar.nram.bf16 \t[%[dst]], [%[src0]], %[src1], %[size];\n\t"
           ::[dst] "r"(dst), [src0] "r"(src), [src1] "r"(const_value),
           [size] "r"(elem_count));
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_le_scalar(float* dst,
                                                          float* src,
                                                          float const_value,
                                                          int elem_count) {
  __mlvm_stream_le_scalar_f32(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_le_scalar(half* dst,
                                                          half* src,
                                                          half const_value,
                                                          int elem_count) {
  __mlvm_stream_le_scalar_f16(dst, src, const_value, elem_count);
}

#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_le_scalar(bfloat16_t* dst,
                                                          bfloat16_t* src,
                                                          bfloat16_t const_value,
                                                          int elem_count) {
  __asm__ ("le.scalar.nram.bf16 \t[%[dst]], [%[src0]], %[src1], %[size];\n\t"
           ::[dst] "r"(dst), [src0] "r"(src), [src1] "r"(const_value),
           [size] "r"(elem_count));
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_lt_scalar(float* dst,
                                                          float* src,
                                                          float const_value,
                                                          int elem_count) {
  __mlvm_stream_lt_scalar_f32(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_lt_scalar(half* dst,
                                                          half* src,
                                                          half const_value,
                                                          int elem_count) {
  __mlvm_stream_lt_scalar_f16(dst, src, const_value, elem_count);
}

#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_lt_scalar(bfloat16_t* dst,
                                                          bfloat16_t* src,
                                                          bfloat16_t const_value,
                                                          int elem_count) {
  __asm__ ("lt.scalar.nram.bf16 \t[%[dst]], [%[src0]], %[src1], %[size];\n\t"
           ::[dst] "r"(dst), [src0] "r"(src), [src1] "r"(const_value),
           [size] "r"(elem_count));
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_gt_scalar(float* dst,
                                                          float* src,
                                                          float const_value,
                                                          int elem_count) {
  __mlvm_stream_gt_scalar_f32(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_gt_scalar(half* dst,
                                                          half* src,
                                                          half const_value,
                                                          int elem_count) {
  __mlvm_stream_gt_scalar_f16(dst, src, const_value, elem_count);
}

#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_gt_scalar(bfloat16_t* dst,
                                                          bfloat16_t* src,
                                                          bfloat16_t const_value,
                                                          int elem_count) {
  __asm__ ("gt.scalar.nram.bf16 \t[%[dst]], [%[src0]], %[src1], %[size];\n\t"
           ::[dst] "r"(dst), [src0] "r"(src), [src1] "r"(const_value),
           [size] "r"(elem_count));
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_and_scalar(half* dst,
                                                           half* src,
                                                           half const_value,
                                                           int elem_count) {
  __mlvm_stream_and_scalar_f16(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_and_scalar(float* dst,
                                                           float* src,
                                                           float const_value,
                                                           int elem_count) {
  __mlvm_stream_and_scalar_f32(dst, src, const_value, elem_count);
}
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_and_scalar(bfloat16_t* dst,
                                                           bfloat16_t* src,
                                                           bfloat16_t const_value,
                                                           int elem_count) {
  __asm__ ("and.scalar.nram.bf16 \t[%[dst]], [%[src0]], %[src1], %[size];\n\t"
                   ::[dst] "r"(dst), [src0] "r"(src), [src1] "r"(const_value),
                   [size] "r"(elem_count));
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

static __mlu_func__ __mlu_builtin__ void __bang_or_scalar(half* dst,
                                                          half* src,
                                                          half const_value,
                                                          int elem_count) {
  __mlvm_stream_or_scalar_f16(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_or_scalar(float* dst,
                                                          float* src,
                                                          float const_value,
                                                          int elem_count) {
  __mlvm_stream_or_scalar_f32(dst, src, const_value, elem_count);
}
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_or_scalar(bfloat16_t* dst,
                                                          bfloat16_t* src,
                                                          bfloat16_t const_value,
                                                          int elem_count) {
  __asm__ ("or.scalar.nram.bf16 \t[%[dst]], [%[src0]], %[src1], %[size];\n\t"
                   ::[dst] "r"(dst), [src0] "r"(src), [src1] "r"(const_value),
                   [size] "r"(elem_count));
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

static __mlu_func__ __mlu_builtin__ void __bang_xor_scalar(half* dst,
                                                           half* src,
                                                           half const_value,
                                                           int elem_count) {
  __mlvm_stream_xor_scalar_f16(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_xor_scalar(float* dst,
                                                           float* src,
                                                           float const_value,
                                                           int elem_count) {
  __mlvm_stream_xor_scalar_f32(dst, src, const_value, elem_count);
}
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_xor_scalar(bfloat16_t* dst,
                                                           bfloat16_t* src,
                                                           bfloat16_t const_value,
                                                           int elem_count) {
  __asm__ ("xor.scalar.nram.bf16 \t[%[dst]], [%[src0]], %[src1], %[size];\n\t"
                   ::[dst] "r"(dst), [src0] "r"(src), [src1] "r"(const_value),
                   [size] "r"(elem_count));
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_band_scalar(half* dst,
                                                            half* src,
                                                            half const_value,
                                                            int elem_count) {
  __mlvm_stream_band_scalar_f16(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_band_scalar(float* dst,
                                                            float* src,
                                                            float const_value,
                                                            int elem_count) {
  __mlvm_stream_band_scalar_f32(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_bor_scalar(half* dst,
                                                           half* src,
                                                           half const_value,
                                                           int elem_count) {
  __mlvm_stream_bor_scalar_f16(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_bor_scalar(float* dst,
                                                           float* src,
                                                           float const_value,
                                                           int elem_count) {
  __mlvm_stream_bor_scalar_f32(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_bxor_scalar(half* dst,
                                                            half* src,
                                                            half const_value,
                                                            int elem_count) {
  __mlvm_stream_bxor_scalar_f16(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_bxor_scalar(float* dst,
                                                            float* src,
                                                            float const_value,
                                                            int elem_count) {
  __mlvm_stream_bxor_scalar_f32(dst, src, const_value, elem_count);
}
#endif  // __BANG_ARCH__ >= 300

#if __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321 && \
    __BANG_ARCH__ != 303 && __BANG_ARCH__ != 306
static __mlu_func__ __mlu_builtin__ void __bang_and_scalar(int* dst,
                                                           int* src,
                                                           int const_value,
                                                           int elem_count) {
  __mlvm_stream_and_scalar_s32(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_and_scalar(short* dst,
                                                           short* src,
                                                           short const_value,
                                                           int elem_count) {
  __mlvm_stream_and_scalar_s16(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_and_scalar(char* dst,
                                                           char* src,
                                                           char const_value,
                                                           int elem_count) {
  __mlvm_stream_and_scalar_s8(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_or_scalar(int* dst,
                                                          int* src,
                                                          int const_value,
                                                          int elem_count) {
  __mlvm_stream_or_scalar_s32(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_or_scalar(short* dst,
                                                          short* src,
                                                          short const_value,
                                                          int elem_count) {
  __mlvm_stream_or_scalar_s16(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_or_scalar(char* dst,
                                                          char* src,
                                                          char const_value,
                                                          int elem_count) {
  __mlvm_stream_or_scalar_s8(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_xor_scalar(int* dst,
                                                           int* src,
                                                           int const_value,
                                                           int elem_count) {
  __mlvm_stream_xor_scalar_s32(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_xor_scalar(short* dst,
                                                           short* src,
                                                           short const_value,
                                                           int elem_count) {
  __mlvm_stream_xor_scalar_s16(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_xor_scalar(char* dst,
                                                           char* src,
                                                           char const_value,
                                                           int elem_count) {
  __mlvm_stream_xor_scalar_s8(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_band_scalar(char* dst,
                                                            char* src,
                                                            char const_value,
                                                            int elem_count) {
  __mlvm_stream_band_scalar_s8(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_band_scalar(short* dst,
                                                            short* src,
                                                            short const_value,
                                                            int elem_count) {
  __mlvm_stream_band_scalar_s16(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_band_scalar(int* dst,
                                                            int* src,
                                                            int const_value,
                                                            int elem_count) {
  __mlvm_stream_band_scalar_s32(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_bor_scalar(char* dst,
                                                           char* src,
                                                           char const_value,
                                                           int elem_count) {
  __mlvm_stream_bor_scalar_s8(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_bor_scalar(short* dst,
                                                           short* src,
                                                           short const_value,
                                                           int elem_count) {
  __mlvm_stream_bor_scalar_s16(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_bor_scalar(int* dst,
                                                           int* src,
                                                           int const_value,
                                                           int elem_count) {
  __mlvm_stream_bor_scalar_s32(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_bxor_scalar(char* dst,
                                                            char* src,
                                                            char const_value,
                                                            int elem_count) {
  __mlvm_stream_bxor_scalar_s8(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_bxor_scalar(short* dst,
                                                            short* src,
                                                            short const_value,
                                                            int elem_count) {
  __mlvm_stream_bxor_scalar_s16(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_bxor_scalar(int* dst,
                                                            int* src,
                                                            int const_value,
                                                            int elem_count) {
  __mlvm_stream_bxor_scalar_s32(dst, src, const_value, elem_count);
}
#endif  // __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 306

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector sub const value operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_sub_const(half* dst,
                                                          half* src,
                                                          half const_value,
                                                          int elem_count) {
  __mlvm_stream_sub_const_f16(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_sub_scalar(half* dst,
                                                           half* src,
                                                           half const_value,
                                                           int elem_count) {
  __mlvm_stream_sub_const_f16(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_sub_const(float* dst,
                                                          float* src,
                                                          float const_value,
                                                          int elem_count) {
  __mlvm_stream_sub_const_f32(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_sub_scalar(float* dst,
                                                           float* src,
                                                           float const_value,
                                                           int elem_count) {
  __mlvm_stream_sub_const_f32(dst, src, const_value, elem_count);
}
#endif
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_sub_scalar(bfloat16_t* dst,
                                                           bfloat16_t* src,
                                                           bfloat16_t const_value,
                                                           int elem_count) {
  __asm__ ("sub.scalar.nram.bf16 \t[%[dst]], [%[src0]], %[src1], %[size];\n\t"
                   ::[dst] "r"(dst), [src0] "r"(src), [src1] "r"(const_value),
                   [size] "r"(elem_count));
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector mul const value operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_mul_const(half* dst,
                                                          half* src,
                                                          half const_value,
                                                          int elem_count) {
  __mlvm_stream_mul_const_f16(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_mul_scalar(half* dst,
                                                           half* src,
                                                           half const_value,
                                                           int elem_count) {
  __mlvm_stream_mul_const_f16(dst, src, const_value, elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_mul_const(float* dst,
                                                          float* src,
                                                          float const_value,
                                                          int elem_count) {
  __mlvm_stream_mul_const_f32(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_mul_scalar(float* dst,
                                                           float* src,
                                                           float const_value,
                                                           int elem_count) {
  __mlvm_stream_mul_const_f32(dst, src, const_value, elem_count);
}
#endif
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_mul_scalar(bfloat16_t* dst,
                                                           bfloat16_t* src,
                                                           bfloat16_t const_value,
                                                           int elem_count) {
  __asm__ ("mult.scalar.nram.bf16 \t[%[dst]], [%[src0]], %[src1], %[size];\n\t"
                   ::[dst] "r"(dst), [src0] "r"(src), [src1] "r"(const_value),
                   [size] "r"(elem_count));
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream fusion operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ void __bang_fusion(mluFusionOpCode op_code,
                                                       float* dst,
                                                       float* src0,
                                                       float* src1,
                                                       float* src2,
                                                       int dst_src0_elem_count,
                                                       int src1_src2_elem_count) {
  switch(op_code) {
  case FUSION_FMA:
    __mlvm_stream_fma_vec_vec_vec_f32(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src1_src2_elem_count);
    break;
  case FUSION_FMS:
    __mlvm_stream_fms_vec_vec_vec_f32(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src1_src2_elem_count);
    break;
  case FUSION_FAM:
    __mlvm_stream_fam_vec_vec_vec_f32(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src1_src2_elem_count);
    break;
  case FUSION_FSM:
    __mlvm_stream_fsm_vec_vec_vec_f32(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src1_src2_elem_count);
    break;
  case FUSION_FAA:
    __mlvm_stream_faa_vec_vec_vec_f32(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src1_src2_elem_count);
    break;
  case FUSION_FAS:
    __mlvm_stream_fas_vec_vec_vec_f32(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src1_src2_elem_count);
    break;
  case FUSION_FSS:
    __mlvm_stream_fss_vec_vec_vec_f32(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src1_src2_elem_count);
    break;
  case FUSION_FSA:
    __mlvm_stream_fsa_vec_vec_vec_f32(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src1_src2_elem_count);
    break;
  default:
    // Invalid Fusion Opcode.
    asm volatile("exit %[status];\n\t"
                 ::[status]"i"(TRAP_BANG_INVALID_FUSION_OP));
    break;
  }
}

static __mlu_func__ __mlu_builtin__ void __bang_fusion(mluFusionOpCode op_code,
                                                       float* dst,
                                                       float* src0,
                                                       float* src1,
                                                       float src2,
                                                       int dst_src0_elem_count,
                                                       int src1_elem_count) {
  switch(op_code) {
  case FUSION_FMA:
    __mlvm_stream_fma_vec_vec_flt_f32(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src1_elem_count);
    break;
  case FUSION_FMS:
    __mlvm_stream_fms_vec_vec_flt_f32(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src1_elem_count);
    break;
  case FUSION_FAM:
    __mlvm_stream_fam_vec_vec_flt_f32(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src1_elem_count);
    break;
  case FUSION_FSM:
    __mlvm_stream_fsm_vec_vec_flt_f32(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src1_elem_count);
    break;
  case FUSION_FAA:
    __mlvm_stream_faa_vec_vec_flt_f32(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src1_elem_count);
    break;
  case FUSION_FAS:
    __mlvm_stream_fas_vec_vec_flt_f32(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src1_elem_count);
    break;
  case FUSION_FSS:
    __mlvm_stream_fss_vec_vec_flt_f32(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src1_elem_count);
    break;
  case FUSION_FSA:
    __mlvm_stream_fsa_vec_vec_flt_f32(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src1_elem_count);
    break;
  default:
    // Invalid Fusion Opcode.
    asm volatile("exit %[status];\n\t"
                 ::[status]"i"(TRAP_BANG_INVALID_FUSION_OP));
    break;
  }
}

static __mlu_func__ __mlu_builtin__ void __bang_fusion(mluFusionOpCode op_code,
                                                       float* dst,
                                                       float* src0,
                                                       float src1,
                                                       float* src2,
                                                       int dst_src0_elem_count,
                                                       int src2_elem_count) {
  switch(op_code) {
  case FUSION_FMA:
    __mlvm_stream_fma_vec_flt_vec_f32(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src2_elem_count);
    break;
  case FUSION_FMS:
    __mlvm_stream_fms_vec_flt_vec_f32(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src2_elem_count);
    break;
  case FUSION_FAM:
    __mlvm_stream_fam_vec_flt_vec_f32(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src2_elem_count);
    break;
  case FUSION_FSM:
    __mlvm_stream_fsm_vec_flt_vec_f32(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src2_elem_count);
    break;
  case FUSION_FAA:
    __mlvm_stream_faa_vec_flt_vec_f32(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src2_elem_count);
    break;
  case FUSION_FAS:
    __mlvm_stream_fas_vec_flt_vec_f32(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src2_elem_count);
    break;
  case FUSION_FSS:
    __mlvm_stream_fss_vec_flt_vec_f32(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src2_elem_count);
    break;
  case FUSION_FSA:
    __mlvm_stream_fsa_vec_flt_vec_f32(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src2_elem_count);
    break;
  default:
    // Invalid Fusion Opcode.
    asm volatile("exit %[status];\n\t"
                 ::[status]"i"(TRAP_BANG_INVALID_FUSION_OP));
    break;
  }
}

static __mlu_func__ __mlu_builtin__ void __bang_fusion(mluFusionOpCode op_code,
                                                       float* dst,
                                                       float* src0,
                                                       float src1,
                                                       float src2,
                                                       int dst_src0_elem_count) {
  switch(op_code) {
  case FUSION_FMA:
    __mlvm_stream_fma_vec_flt_flt_f32(dst, src0, src1, src2,
                                      dst_src0_elem_count);
    break;
  case FUSION_FMS:
    __mlvm_stream_fms_vec_flt_flt_f32(dst, src0, src1, src2,
                                      dst_src0_elem_count);
    break;
  case FUSION_FAM:
    __mlvm_stream_fam_vec_flt_flt_f32(dst, src0, src1, src2,
                                      dst_src0_elem_count);
    break;
  case FUSION_FSM:
    __mlvm_stream_fsm_vec_flt_flt_f32(dst, src0, src1, src2,
                                      dst_src0_elem_count);
    break;
  case FUSION_FAA:
    __mlvm_stream_faa_vec_flt_flt_f32(dst, src0, src1, src2,
                                      dst_src0_elem_count);
    break;
  case FUSION_FAS:
    __mlvm_stream_fas_vec_flt_flt_f32(dst, src0, src1, src2,
                                      dst_src0_elem_count);
    break;
  case FUSION_FSS:
    __mlvm_stream_fss_vec_flt_flt_f32(dst, src0, src1, src2,
                                      dst_src0_elem_count);
    break;
  case FUSION_FSA:
    __mlvm_stream_fsa_vec_flt_flt_f32(dst, src0, src1, src2,
                                      dst_src0_elem_count);
    break;
  default:
    // Invalid Fusion Opcode.
    asm volatile("exit %[status];\n\t"
                 ::[status]"i"(TRAP_BANG_INVALID_FUSION_OP));
    break;
  }
}

static __mlu_func__ __mlu_builtin__ void __bang_fusion(mluFusionOpCode op_code,
                                                       half* dst,
                                                       half* src0,
                                                       half* src1,
                                                       half* src2,
                                                       int dst_src0_elem_count,
                                                       int src1_src2_elem_count) {
  switch(op_code) {
  case FUSION_FMA:
    __mlvm_stream_fma_vec_vec_vec_f16(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src1_src2_elem_count);
    break;
  case FUSION_FMS:
    __mlvm_stream_fms_vec_vec_vec_f16(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src1_src2_elem_count);
    break;
  case FUSION_FAM:
    __mlvm_stream_fam_vec_vec_vec_f16(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src1_src2_elem_count);
    break;
  case FUSION_FSM:
    __mlvm_stream_fsm_vec_vec_vec_f16(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src1_src2_elem_count);
    break;
  case FUSION_FAA:
    __mlvm_stream_faa_vec_vec_vec_f16(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src1_src2_elem_count);
    break;
  case FUSION_FAS:
    __mlvm_stream_fas_vec_vec_vec_f16(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src1_src2_elem_count);
    break;
  case FUSION_FSS:
    __mlvm_stream_fss_vec_vec_vec_f16(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src1_src2_elem_count);
    break;
  case FUSION_FSA:
    __mlvm_stream_fsa_vec_vec_vec_f16(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src1_src2_elem_count);
    break;
  default:
    // Invalid Fusion Opcode.
    asm volatile("exit %[status];\n\t"
                 ::[status]"i"(TRAP_BANG_INVALID_FUSION_OP));
    break;
  }
}

static __mlu_func__ __mlu_builtin__ void __bang_fusion(mluFusionOpCode op_code,
                                                       half* dst,
                                                       half* src0,
                                                       half* src1,
                                                       half src2,
                                                       int dst_src0_elem_count,
                                                       int src1_elem_count) {
  switch(op_code) {
  case FUSION_FMA:
    __mlvm_stream_fma_vec_vec_flt_f16(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src1_elem_count);
    break;
  case FUSION_FMS:
    __mlvm_stream_fms_vec_vec_flt_f16(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src1_elem_count);
    break;
  case FUSION_FAM:
    __mlvm_stream_fam_vec_vec_flt_f16(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src1_elem_count);
    break;
  case FUSION_FSM:
    __mlvm_stream_fsm_vec_vec_flt_f16(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src1_elem_count);
    break;
  case FUSION_FAA:
    __mlvm_stream_faa_vec_vec_flt_f16(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src1_elem_count);
    break;
  case FUSION_FAS:
    __mlvm_stream_fas_vec_vec_flt_f16(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src1_elem_count);
    break;
  case FUSION_FSS:
    __mlvm_stream_fss_vec_vec_flt_f16(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src1_elem_count);
    break;
  case FUSION_FSA:
    __mlvm_stream_fsa_vec_vec_flt_f16(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src1_elem_count);
    break;
  default:
    // Invalid Fusion Opcode.
    asm volatile("exit %[status];\n\t"
                 ::[status]"i"(TRAP_BANG_INVALID_FUSION_OP));
    break;
  }
}

static __mlu_func__ __mlu_builtin__ void __bang_fusion(mluFusionOpCode op_code,
                                                       half* dst,
                                                       half* src0,
                                                       half src1,
                                                       half* src2,
                                                       int dst_src0_elem_count,
                                                       int src2_elem_count) {
  switch(op_code) {
  case FUSION_FMA:
    __mlvm_stream_fma_vec_flt_vec_f16(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src2_elem_count);
    break;
  case FUSION_FMS:
    __mlvm_stream_fms_vec_flt_vec_f16(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src2_elem_count);
    break;
  case FUSION_FAM:
    __mlvm_stream_fam_vec_flt_vec_f16(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src2_elem_count);
    break;
  case FUSION_FSM:
    __mlvm_stream_fsm_vec_flt_vec_f16(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src2_elem_count);
    break;
  case FUSION_FAA:
    __mlvm_stream_faa_vec_flt_vec_f16(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src2_elem_count);
    break;
  case FUSION_FAS:
    __mlvm_stream_fas_vec_flt_vec_f16(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src2_elem_count);
    break;
  case FUSION_FSS:
    __mlvm_stream_fss_vec_flt_vec_f16(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src2_elem_count);
    break;
  case FUSION_FSA:
    __mlvm_stream_fsa_vec_flt_vec_f16(dst, src0, src1, src2,
                                      dst_src0_elem_count,
                                      src2_elem_count);
    break;
  default:
    // Invalid Fusion Opcode.
    asm volatile("exit %[status];\n\t"
                 ::[status]"i"(TRAP_BANG_INVALID_FUSION_OP));
    break;
  }
}

static __mlu_func__ __mlu_builtin__ void __bang_fusion(mluFusionOpCode op_code,
                                                       half* dst,
                                                       half* src0,
                                                       half src1,
                                                       half src2,
                                                       int dst_src0_elem_count) {
  switch(op_code) {
  case FUSION_FMA:
    __mlvm_stream_fma_vec_flt_flt_f16(dst, src0, src1, src2,
                                      dst_src0_elem_count);
    break;
  case FUSION_FMS:
    __mlvm_stream_fms_vec_flt_flt_f16(dst, src0, src1, src2,
                                      dst_src0_elem_count);
    break;
  case FUSION_FAM:
    __mlvm_stream_fam_vec_flt_flt_f16(dst, src0, src1, src2,
                                      dst_src0_elem_count);
    break;
  case FUSION_FSM:
    __mlvm_stream_fsm_vec_flt_flt_f16(dst, src0, src1, src2,
                                      dst_src0_elem_count);
    break;
  case FUSION_FAA:
    __mlvm_stream_faa_vec_flt_flt_f16(dst, src0, src1, src2,
                                      dst_src0_elem_count);
    break;
  case FUSION_FAS:
    __mlvm_stream_fas_vec_flt_flt_f16(dst, src0, src1, src2,
                                      dst_src0_elem_count);
    break;
  case FUSION_FSS:
    __mlvm_stream_fss_vec_flt_flt_f16(dst, src0, src1, src2,
                                      dst_src0_elem_count);
    break;
  case FUSION_FSA:
    __mlvm_stream_fsa_vec_flt_flt_f16(dst, src0, src1, src2,
                                      dst_src0_elem_count);
    break;
  default:
    // Invalid Fusion Opcode.
    asm volatile("exit %[status];\n\t"
                 ::[status]"i"(TRAP_BANG_INVALID_FUSION_OP));
    break;
  }
}

#endif  // __BANG_ARCH__ >= 300

#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_fusion(mluFusionOpCode op_code,
                                                       bfloat16_t* dst,
                                                       bfloat16_t* src0,
                                                       bfloat16_t* src1,
                                                       bfloat16_t* src2,
                                                       int dst_src0_elem_count,
                                                       int src1_src2_elem_count) {
  switch(op_code) {
  case FUSION_FMA:
    __mlvm_stream_fma_vec_vec_vec_bf16(dst, src0, src1, src2,
                                       dst_src0_elem_count,
                                       src1_src2_elem_count);
    break;
  case FUSION_FMS:
    __mlvm_stream_fms_vec_vec_vec_bf16(dst, src0, src1, src2,
                                       dst_src0_elem_count,
                                       src1_src2_elem_count);
    break;
  case FUSION_FAM:
    __mlvm_stream_fam_vec_vec_vec_bf16(dst, src0, src1, src2,
                                       dst_src0_elem_count,
                                       src1_src2_elem_count);
    break;
  case FUSION_FSM:
    __mlvm_stream_fsm_vec_vec_vec_bf16(dst, src0, src1, src2,
                                       dst_src0_elem_count,
                                       src1_src2_elem_count);
    break;
  case FUSION_FAA:
    __mlvm_stream_faa_vec_vec_vec_bf16(dst, src0, src1, src2,
                                       dst_src0_elem_count,
                                       src1_src2_elem_count);
    break;
  case FUSION_FAS:
    __mlvm_stream_fas_vec_vec_vec_bf16(dst, src0, src1, src2,
                                       dst_src0_elem_count,
                                       src1_src2_elem_count);
    break;
  case FUSION_FSS:
    __mlvm_stream_fss_vec_vec_vec_bf16(dst, src0, src1, src2,
                                       dst_src0_elem_count,
                                       src1_src2_elem_count);
    break;
  case FUSION_FSA:
    __mlvm_stream_fsa_vec_vec_vec_bf16(dst, src0, src1, src2,
                                       dst_src0_elem_count,
                                       src1_src2_elem_count);
    break;
  default:
    // Invalid Fusion Opcode.
    asm volatile("exit %[status];\n\t"
                 ::[status]"i"(TRAP_BANG_INVALID_FUSION_OP));
    break;
  }
}

static __mlu_func__ __mlu_builtin__ void __bang_fusion(mluFusionOpCode op_code,
                                                       bfloat16_t* dst,
                                                       bfloat16_t* src0,
                                                       bfloat16_t* src1,
                                                       bfloat16_t src2,
                                                       int dst_src0_elem_count,
                                                       int src1_elem_count) {
  switch(op_code) {
  case FUSION_FMA:
    __asm__ ("fma.nram.bf16 [%[dst]], [%[src0]], [%[src1]], %[src2], %[size1], %[size2];\n"
             ::[dst] "r"(dst), [src0] "r"(src0), [src1] "r"(src1), [src2] "r"(src2),
             [size1] "r"(dst_src0_elem_count), [size2] "r"(src1_elem_count));
    break;
  case FUSION_FMS:
    __asm__ ("fms.nram.bf16 [%[dst]], [%[src0]], [%[src1]], %[src2], %[size1], %[size2];\n"
             ::[dst] "r"(dst), [src0] "r"(src0), [src1] "r"(src1), [src2] "r"(src2),
             [size1] "r"(dst_src0_elem_count), [size2] "r"(src1_elem_count));
    break;
  case FUSION_FAM:
    __asm__ ("fam.nram.bf16 [%[dst]], [%[src0]], [%[src1]], %[src2], %[size1], %[size2];\n"
             ::[dst] "r"(dst), [src0] "r"(src0), [src1] "r"(src1), [src2] "r"(src2),
             [size1] "r"(dst_src0_elem_count), [size2] "r"(src1_elem_count));
    break;
  case FUSION_FSM:
    __asm__ ("fsm.nram.bf16 [%[dst]], [%[src0]], [%[src1]], %[src2], %[size1], %[size2];\n"
             ::[dst] "r"(dst), [src0] "r"(src0), [src1] "r"(src1), [src2] "r"(src2),
             [size1] "r"(dst_src0_elem_count), [size2] "r"(src1_elem_count));
    break;
  case FUSION_FAA:
    __asm__ ("faa.nram.bf16 [%[dst]], [%[src0]], [%[src1]], %[src2], %[size1], %[size2];\n"
             ::[dst] "r"(dst), [src0] "r"(src0), [src1] "r"(src1), [src2] "r"(src2),
             [size1] "r"(dst_src0_elem_count), [size2] "r"(src1_elem_count));
    break;
  case FUSION_FAS:
    __asm__ ("fas.nram.bf16 [%[dst]], [%[src0]], [%[src1]], %[src2], %[size1], %[size2];\n"
             ::[dst] "r"(dst), [src0] "r"(src0), [src1] "r"(src1), [src2] "r"(src2),
             [size1] "r"(dst_src0_elem_count), [size2] "r"(src1_elem_count));
    break;
  case FUSION_FSS:
    __asm__ ("fss.nram.bf16 [%[dst]], [%[src0]], [%[src1]], %[src2], %[size1], %[size2];\n"
             ::[dst] "r"(dst), [src0] "r"(src0), [src1] "r"(src1), [src2] "r"(src2),
             [size1] "r"(dst_src0_elem_count), [size2] "r"(src1_elem_count));
    break;
  case FUSION_FSA:
    __asm__ ("fsa.nram.bf16 [%[dst]], [%[src0]], [%[src1]], %[src2], %[size1], %[size2];\n"
             ::[dst] "r"(dst), [src0] "r"(src0), [src1] "r"(src1), [src2] "r"(src2),
             [size1] "r"(dst_src0_elem_count), [size2] "r"(src1_elem_count));
    break;
  default:
    // Invalid Fusion Opcode.
    asm volatile("exit %[status];\n\t"
                 ::[status]"i"(TRAP_BANG_INVALID_FUSION_OP));
    break;
  }
}

static __mlu_func__ __mlu_builtin__ void __bang_fusion(mluFusionOpCode op_code,
                                                       bfloat16_t* dst,
                                                       bfloat16_t* src0,
                                                       bfloat16_t src1,
                                                       bfloat16_t* src2,
                                                       int dst_src0_elem_count,
                                                       int src2_elem_count) {
  switch(op_code) {
  case FUSION_FMA:
    __asm__ ("fma.nram.bf16 [%[dst]], [%[src0]], %[src1], [%[src2]], %[size1], %[size2];\n"
             ::[dst] "r"(dst), [src0] "r"(src0), [src1] "r"(src1), [src2] "r"(src2),
             [size1] "r"(dst_src0_elem_count), [size2] "r"(src2_elem_count));
    break;
  case FUSION_FMS:
    __asm__ ("fms.nram.bf16 [%[dst]], [%[src0]], %[src1], [%[src2]], %[size1], %[size2];\n"
             ::[dst] "r"(dst), [src0] "r"(src0), [src1] "r"(src1), [src2] "r"(src2),
             [size1] "r"(dst_src0_elem_count), [size2] "r"(src2_elem_count));
    break;
  case FUSION_FAM:
    __asm__ ("fam.nram.bf16 [%[dst]], [%[src0]], %[src1], [%[src2]], %[size1], %[size2];\n"
             ::[dst] "r"(dst), [src0] "r"(src0), [src1] "r"(src1), [src2] "r"(src2),
             [size1] "r"(dst_src0_elem_count), [size2] "r"(src2_elem_count));
    break;
  case FUSION_FSM:
    __asm__ ("fsm.nram.bf16 [%[dst]], [%[src0]], %[src1], [%[src2]], %[size1], %[size2];\n"
             ::[dst] "r"(dst), [src0] "r"(src0), [src1] "r"(src1), [src2] "r"(src2),
             [size1] "r"(dst_src0_elem_count), [size2] "r"(src2_elem_count));
    break;
  case FUSION_FAA:
    __asm__ ("faa.nram.bf16 [%[dst]], [%[src0]], %[src1], [%[src2]], %[size1], %[size2];\n"
             ::[dst] "r"(dst), [src0] "r"(src0), [src1] "r"(src1), [src2] "r"(src2),
             [size1] "r"(dst_src0_elem_count), [size2] "r"(src2_elem_count));
    break;
  case FUSION_FAS:
    __asm__ ("fas.nram.bf16 [%[dst]], [%[src0]], %[src1], [%[src2]], %[size1], %[size2];\n"
             ::[dst] "r"(dst), [src0] "r"(src0), [src1] "r"(src1), [src2] "r"(src2),
             [size1] "r"(dst_src0_elem_count), [size2] "r"(src2_elem_count));
    break;
  case FUSION_FSS:
    __asm__ ("fss.nram.bf16 [%[dst]], [%[src0]], %[src1], [%[src2]], %[size1], %[size2];\n"
             ::[dst] "r"(dst), [src0] "r"(src0), [src1] "r"(src1), [src2] "r"(src2),
             [size1] "r"(dst_src0_elem_count), [size2] "r"(src2_elem_count));
    break;
  case FUSION_FSA:
    __asm__ ("fsa.nram.bf16 [%[dst]], [%[src0]], %[src1], [%[src2]], %[size1], %[size2];\n"
             ::[dst] "r"(dst), [src0] "r"(src0), [src1] "r"(src1), [src2] "r"(src2),
             [size1] "r"(dst_src0_elem_count), [size2] "r"(src2_elem_count));
    break;
  default:
    // Invalid Fusion Opcode.
    asm volatile("exit %[status];\n\t"
                 ::[status]"i"(TRAP_BANG_INVALID_FUSION_OP));
    break;
  }
}

static __mlu_func__ __mlu_builtin__ void __bang_fusion(mluFusionOpCode op_code,
                                                       bfloat16_t* dst,
                                                       bfloat16_t* src0,
                                                       bfloat16_t src1,
                                                       bfloat16_t src2,
                                                       int dst_src0_elem_count) {
  switch(op_code) {
  case FUSION_FMA:
    __asm__ ("fma.nram.bf16 [%[dst]], [%[src0]], %[src1], %[src2], %[size1];\n"
             ::[dst] "r"(dst), [src0] "r"(src0), [src1] "r"(src1),
             [src2] "r"(src2), [size1] "r"(dst_src0_elem_count));
    break;
  case FUSION_FMS:
    __asm__ ("fms.nram.bf16 [%[dst]], [%[src0]], %[src1], %[src2], %[size1];\n"
             ::[dst] "r"(dst), [src0] "r"(src0), [src1] "r"(src1),
             [src2] "r"(src2), [size1] "r"(dst_src0_elem_count));
    break;
  case FUSION_FAM:
    __asm__ ("fam.nram.bf16 [%[dst]], [%[src0]], %[src1], %[src2], %[size1];\n"
             ::[dst] "r"(dst), [src0] "r"(src0), [src1] "r"(src1),
             [src2] "r"(src2), [size1] "r"(dst_src0_elem_count));
    break;
  case FUSION_FSM:
    __asm__ ("fsm.nram.bf16 [%[dst]], [%[src0]], %[src1], %[src2], %[size1];\n"
             ::[dst] "r"(dst), [src0] "r"(src0), [src1] "r"(src1),
             [src2] "r"(src2), [size1] "r"(dst_src0_elem_count));
    break;
  case FUSION_FAA:
    __asm__ ("faa.nram.bf16 [%[dst]], [%[src0]], %[src1], %[src2], %[size1];\n"
             ::[dst] "r"(dst), [src0] "r"(src0), [src1] "r"(src1),
             [src2] "r"(src2), [size1] "r"(dst_src0_elem_count));
    break;
  case FUSION_FAS:
    __asm__ ("fas.nram.bf16 [%[dst]], [%[src0]], %[src1], %[src2], %[size1];\n"
             ::[dst] "r"(dst), [src0] "r"(src0), [src1] "r"(src1),
             [src2] "r"(src2), [size1] "r"(dst_src0_elem_count));
    break;
  case FUSION_FSS:
    __asm__ ("fss.nram.bf16 [%[dst]], [%[src0]], %[src1], %[src2], %[size1];\n"
             ::[dst] "r"(dst), [src0] "r"(src0), [src1] "r"(src1),
             [src2] "r"(src2), [size1] "r"(dst_src0_elem_count));
    break;
  case FUSION_FSA:
    __asm__ ("fsa.nram.bf16 [%[dst]], [%[src0]], %[src1], %[src2], %[size1];\n"
             ::[dst] "r"(dst), [src0] "r"(src0), [src1] "r"(src1),
             [src2] "r"(src2), [size1] "r"(dst_src0_elem_count));
    break;
  default:
    // Invalid Fusion Opcode.
    asm volatile("exit %[status];\n\t"
                 ::[status]"i"(TRAP_BANG_INVALID_FUSION_OP));
    break;
  }
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector ge const value operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_ge_const(half* dst,
                                                         half* src,
                                                         half const_value,
                                                         int elem_count) {
  __mlvm_stream_ge_const_f16(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_ge_scalar(half* dst,
                                                          half* src,
                                                          half const_value,
                                                          int elem_count) {
  __mlvm_stream_ge_const_f16(dst, src, const_value, elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_ge_const(float* dst,
                                                         float* src,
                                                         float const_value,
                                                         int elem_count) {
  __mlvm_stream_ge_const_f32(dst, src, const_value, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_ge_scalar(float* dst,
                                                          float* src,
                                                          float const_value,
                                                          int elem_count) {
  __mlvm_stream_ge_const_f32(dst, src, const_value, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_ge_scalar(bfloat16_t* dst,
                                                          bfloat16_t* src,
                                                          bfloat16_t const_value,
                                                          int elem_count) {
  __asm__ ("ge.scalar.nram.bf16 \t[%[dst]], [%[src0]], %[src1], %[size];\n\t"
           ::[dst] "r"(dst), [src0] "r"(src), [src1] "r"(const_value),
           [size] "r"(elem_count));
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector equal comparison operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_eq(half* dst,
                                                   half* src0,
                                                   half* src1,
                                                   int elem_count) {
  __mlvm_stream_eq_f16(dst, src0, src1, elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_eq(float* dst,
                                                   float* src0,
                                                   float* src1,
                                                   int elem_count) {
  __mlvm_stream_eq_f32(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_eq(bfloat16_t* dst,
                                                   bfloat16_t* src0,
                                                   bfloat16_t* src1,
                                                   int elem_count) {
  __mlvm_stream_eq_bf16(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector not-equal comparison operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_ne(half* dst,
                                                   half* src0,
                                                   half* src1,
                                                   int elem_count) {
  __mlvm_stream_ne_f16(dst, src0, src1, elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_ne(float* dst,
                                                   float* src0,
                                                   float* src1,
                                                   int elem_count) {
  __mlvm_stream_ne_f32(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_ne(bfloat16_t* dst,
                                                   bfloat16_t* src0,
                                                   bfloat16_t* src1,
                                                   int elem_count) {
  __mlvm_stream_ne_bf16(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector greater comparison operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_gt(half* dst,
                                                   half* src0,
                                                   half* src1,
                                                   int elem_count) {
  __mlvm_stream_gt_f16(dst, src0, src1, elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_gt(float* dst,
                                                   float* src0,
                                                   float* src1,
                                                   int elem_count) {
  __mlvm_stream_gt_f32(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_gt(bfloat16_t* dst,
                                                   bfloat16_t* src0,
                                                   bfloat16_t* src1,
                                                   int elem_count) {
  __mlvm_stream_gt_bf16(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector greater-equal comparison operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_ge(half* dst,
                                                   half* src0,
                                                   half* src1,
                                                   int elem_count) {
  __mlvm_stream_ge_f16(dst, src0, src1, elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_ge(float* dst,
                                                   float* src0,
                                                   float* src1,
                                                   int elem_count) {
  __mlvm_stream_ge_f32(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_ge(bfloat16_t* dst,
                                                   bfloat16_t* src0,
                                                   bfloat16_t* src1,
                                                   int elem_count) {
  __mlvm_stream_ge_bf16(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector little comparison operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_lt(half* dst,
                                                   half* src0,
                                                   half* src1,
                                                   int elem_count) {
  __mlvm_stream_lt_f16(dst, src0, src1, elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_lt(float* dst,
                                                   float* src0,
                                                   float* src1,
                                                   int elem_count) {
  __mlvm_stream_lt_f32(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_lt(bfloat16_t* dst,
                                                   bfloat16_t* src0,
                                                   bfloat16_t* src1,
                                                   int elem_count) {
  __mlvm_stream_lt_bf16(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector little-equal comparison operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_le(half* dst,
                                                   half* src0,
                                                   half* src1,
                                                   int elem_count) {
  __mlvm_stream_le_f16(dst, src0, src1, elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_le(float* dst,
                                                   float* src0,
                                                   float* src1,
                                                   int elem_count) {
  __mlvm_stream_le_f32(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_le(bfloat16_t* dst,
                                                   bfloat16_t* src0,
                                                   bfloat16_t* src1,
                                                   int elem_count) {
  __mlvm_stream_le_bf16(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector equal comparison operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_eq_bitindex(half* dst,
                                                            half* src0,
                                                            half* src1,
                                                            int elem_count) {
  __mlvm_stream_eq_bitindex_f16(dst, src0, src1, elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_eq_bitindex(float* dst,
                                                            float* src0,
                                                            float* src1,
                                                            int elem_count) {
  __mlvm_stream_eq_bitindex_f32(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_eq_bitindex(bfloat16_t* dst,
                                                            bfloat16_t* src0,
                                                            bfloat16_t* src1,
                                                            int elem_count) {
  __mlvm_stream_eq_bitindex_bf16(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector not-equal comparison operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_ne_bitindex(half* dst,
                                                            half* src0,
                                                            half* src1,
                                                            int elem_count) {
  __mlvm_stream_ne_bitindex_f16(dst, src0, src1, elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_ne_bitindex(float* dst,
                                                            float* src0,
                                                            float* src1,
                                                            int elem_count) {
  __mlvm_stream_ne_bitindex_f32(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_ne_bitindex(bfloat16_t* dst,
                                                            bfloat16_t* src0,
                                                            bfloat16_t* src1,
                                                            int elem_count) {
  __mlvm_stream_ne_bitindex_bf16(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector greater comparison operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_gt_bitindex(half* dst,
                                                            half* src0,
                                                            half* src1,
                                                            int elem_count) {
  __mlvm_stream_gt_bitindex_f16(dst, src0, src1, elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_gt_bitindex(float* dst,
                                                            float* src0,
                                                            float* src1,
                                                            int elem_count) {
  __mlvm_stream_gt_bitindex_f32(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_gt_bitindex(bfloat16_t* dst,
                                                            bfloat16_t* src0,
                                                            bfloat16_t* src1,
                                                            int elem_count) {
  __mlvm_stream_gt_bitindex_bf16(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector greater-equal comparison operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_ge_bitindex(half* dst,
                                                            half* src0,
                                                            half* src1,
                                                            int elem_count) {
  __mlvm_stream_ge_bitindex_f16(dst, src0, src1, elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_ge_bitindex(float* dst,
                                                            float* src0,
                                                            float* src1,
                                                            int elem_count) {
  __mlvm_stream_ge_bitindex_f32(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_ge_bitindex(bfloat16_t* dst,
                                                            bfloat16_t* src0,
                                                            bfloat16_t* src1,
                                                            int elem_count) {
  __mlvm_stream_ge_bitindex_bf16(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector little comparison operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_lt_bitindex(half* dst,
                                                            half* src0,
                                                            half* src1,
                                                            int elem_count) {
  __mlvm_stream_lt_bitindex_f16(dst, src0, src1, elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_lt_bitindex(float* dst,
                                                            float* src0,
                                                            float* src1,
                                                            int elem_count) {
  __mlvm_stream_lt_bitindex_f32(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_lt_bitindex(bfloat16_t* dst,
                                                            bfloat16_t* src0,
                                                            bfloat16_t* src1,
                                                            int elem_count) {
  __mlvm_stream_lt_bitindex_bf16(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector little-equal comparison operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_le_bitindex(half* dst,
                                                            half* src0,
                                                            half* src1,
                                                            int elem_count) {
  __mlvm_stream_le_bitindex_f16(dst, src0, src1, elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_le_bitindex(float* dst,
                                                            float* src0,
                                                            float* src1,
                                                            int elem_count) {
  __mlvm_stream_le_bitindex_f32(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_le_bitindex(bfloat16_t* dst,
                                                            bfloat16_t* src0,
                                                            bfloat16_t* src1,
                                                            int elem_count) {
  __mlvm_stream_le_bitindex_bf16(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream fusion unary fabxmax and fabsmin operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ void __bang_fabsmax(half* dst,
                                                        half* src,
                                                        int elem_count) {
  __mlvm_stream_fabsmax_f16(dst, src, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_fabsmax(float* dst,
                                                        float* src,
                                                        int elem_count) {
  __mlvm_stream_fabsmax_f32(dst, src, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_fabsmin(half* dst,
                                                        half* src,
                                                        int elem_count) {
  __mlvm_stream_fabsmin_f16(dst, src, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_fabsmin(float* dst,
                                                        float* src,
                                                        int elem_count) {
  __mlvm_stream_fabsmin_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 300

#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_fabsmax(bfloat16_t* dst,
                                                        bfloat16_t* src,
                                                        int elem_count) {
  __mlvm_stream_fabsmax_bf16(dst, src, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_fabsmin(bfloat16_t* dst,
                                                        bfloat16_t* src,
                                                        int elem_count) {
  __mlvm_stream_fabsmin_bf16(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream fusion binary fcmpfilter operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 300
#define FUSION_CMPFILTER_MLVM(mode, dst, src0, src1, elem_count, type)       \
  switch (mode) {                                                            \
    case CMP_EQ:                                                             \
      __mlvm_stream_fcmpfilter_eq_vec_##type(dst, src0, src1, elem_count);   \
      break;                                                                 \
    case CMP_NE:                                                             \
      __mlvm_stream_fcmpfilter_ne_vec_##type(dst, src0, src1, elem_count);   \
      break;                                                                 \
    case CMP_LT:                                                             \
      __mlvm_stream_fcmpfilter_lt_vec_##type(dst, src0, src1, elem_count);   \
      break;                                                                 \
    case CMP_LE:                                                             \
      __mlvm_stream_fcmpfilter_le_vec_##type(dst, src0, src1, elem_count);   \
      break;                                                                 \
    case CMP_GT:                                                             \
      __mlvm_stream_fcmpfilter_gt_vec_##type(dst, src0, src1, elem_count);   \
      break;                                                                 \
    case CMP_GE:                                                             \
      __mlvm_stream_fcmpfilter_ge_vec_##type(dst, src0, src1, elem_count);   \
      break;                                                                 \
    default:                                                                 \
      /* Invalid Compare Mode */                                             \
      asm volatile("exit %[status];\n\t"                                     \
                   ::[status]"i"(TRAP_BANG_INVALID_COMPARE_MODE));           \
      break;                                                                 \
  }

static __mlu_func__ __mlu_builtin__ void __bang_fcmpfilter(CompareMode mode,
                                                           half* dst,
                                                           half* src0,
                                                           half* src1,
                                                           int elem_count) {
  FUSION_CMPFILTER_MLVM(mode, dst, src0, src1, elem_count, vec_f16);
}
static __mlu_func__ __mlu_builtin__ void __bang_fcmpfilter(CompareMode mode,
                                                           half* dst,
                                                           half* src0,
                                                           half src1,
                                                           int elem_count) {
  FUSION_CMPFILTER_MLVM(mode, dst, src0, src1, elem_count, flt_f16);
}
static __mlu_func__ __mlu_builtin__ void __bang_fcmpfilter(CompareMode mode,
                                                           float* dst,
                                                           float* src0,
                                                           float* src1,
                                                           int elem_count) {
  FUSION_CMPFILTER_MLVM(mode, dst, src0, src1, elem_count, vec_f32);
}
static __mlu_func__ __mlu_builtin__ void __bang_fcmpfilter(CompareMode mode,
                                                           float* dst,
                                                           float* src0,
                                                           float src1,
                                                           int elem_count) {
  FUSION_CMPFILTER_MLVM(mode, dst, src0, src1, elem_count, flt_f32);
}

#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_fcmpfilter(CompareMode mode,
                                                           bfloat16_t* dst,
                                                           bfloat16_t* src0,
                                                           bfloat16_t* src1,
                                                           int elem_count) {
  FUSION_CMPFILTER_MLVM(mode, dst, src0, src1, elem_count, vec_bf16);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
#undef FUSION_CMPFILTER_MLVM
#endif  // __BANG_ARCH__ >= 300

#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_fcmpfilter(CompareMode mode,
                                                           bfloat16_t* dst,
                                                           bfloat16_t* src0,
                                                           bfloat16_t src1,
                                                           int elem_count) {
  switch (mode) {
    case CMP_EQ:
      __asm__ ("fcmpfilter.eq.nram.bf16 [%[dst]], [%[src0]], %[src1], %[size];\n"
               ::[dst] "r"(dst), [src0] "r"(src0), [src1] "r"(src1),
               [size] "r"(elem_count));
      break;
    case CMP_NE:
      __asm__ ("fcmpfilter.ne.nram.bf16 [%[dst]], [%[src0]], %[src1], %[size];\n"
               ::[dst] "r"(dst), [src0] "r"(src0), [src1] "r"(src1),
               [size] "r"(elem_count));
      break;
    case CMP_LT:
      __asm__ ("fcmpfilter.lt.nram.bf16 [%[dst]], [%[src0]], %[src1], %[size];\n"
               ::[dst] "r"(dst), [src0] "r"(src0), [src1] "r"(src1),
               [size] "r"(elem_count));
      break;
    case CMP_LE:
      __asm__ ("fcmpfilter.le.nram.bf16 [%[dst]], [%[src0]], %[src1], %[size];\n"
               ::[dst] "r"(dst), [src0] "r"(src0), [src1] "r"(src1),
               [size] "r"(elem_count));
      break;
    case CMP_GT:
      __asm__ ("fcmpfilter.gt.nram.bf16 [%[dst]], [%[src0]], %[src1], %[size];\n"
               ::[dst] "r"(dst), [src0] "r"(src0), [src1] "r"(src1),
               [size] "r"(elem_count));
      break;
    case CMP_GE:
      __asm__ ("fcmpfilter.ge.nram.bf16 [%[dst]], [%[src0]], %[src1], %[size];\n"
               ::[dst] "r"(dst), [src0] "r"(src0), [src1] "r"(src1),
               [size] "r"(elem_count));
      break;
    default:
      /* Invalid Compare Mode */
      asm volatile("exit %[status];\n\t"
                   ::[status]"i"(TRAP_BANG_INVALID_COMPARE_MODE));
      break;
  }
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector or operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_or(half* dst,
                                                   half* src0,
                                                   half* src1,
                                                   int elem_count) {
  __mlvm_stream_or_f16(dst, src0, src1, elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_or(float* dst,
                                                   float* src0,
                                                   float* src1,
                                                   int elem_count) {
  __mlvm_stream_or_f32(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 200
#if __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321 && \
    __BANG_ARCH__ != 303 && __BANG_ARCH__ != 306
static __mlu_func__ __mlu_builtin__ void __bang_or(int* dst,
                                                   int* src0,
                                                   int* src1,
                                                   int elem_count) {
  __mlvm_stream_or_s32(dst, src0, src1, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_or(short* dst,
                                                   short* src0,
                                                   short* src1,
                                                   int elem_count) {
  __mlvm_stream_or_s16(dst, src0, src1, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_or(char* dst,
                                                   char* src0,
                                                   char* src1,
                                                   int elem_count) {
  __mlvm_stream_or_s8(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 306
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_or(bfloat16_t* dst,
                                                   bfloat16_t* src0,
                                                   bfloat16_t* src1,
                                                   int elem_count) {
  __mlvm_stream_or_bf16(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector and operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_and(half* dst,
                                                    half* src0,
                                                    half* src1,
                                                    int elem_count) {
  __mlvm_stream_and_f16(dst, src0, src1, elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_and(float* dst,
                                                    float* src0,
                                                    float* src1,
                                                    int elem_count) {
  __mlvm_stream_and_f32(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 200
#if __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321 && \
    __BANG_ARCH__ != 303 && __BANG_ARCH__ != 306
static __mlu_func__ __mlu_builtin__ void __bang_and(int* dst,
                                                    int* src0,
                                                    int* src1,
                                                    int elem_count) {
  __mlvm_stream_and_s32(dst, src0, src1, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_and(short* dst,
                                                    short* src0,
                                                    short* src1,
                                                    int elem_count) {
  __mlvm_stream_and_s16(dst, src0, src1, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_and(char* dst,
                                                    char* src0,
                                                    char* src1,
                                                    int elem_count) {
  __mlvm_stream_and_s8(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 306
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_and(bfloat16_t* dst,
                                                    bfloat16_t* src0,
                                                    bfloat16_t* src1,
                                                    int elem_count) {
  __mlvm_stream_and_bf16(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321


// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector xor operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_xor(half* dst,
                                                    half* src0,
                                                    half* src1,
                                                    int elem_count) {
  __mlvm_stream_xor_f16(dst, src0, src1, elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_xor(float* dst,
                                                    float* src0,
                                                    float* src1,
                                                    int elem_count) {
  __mlvm_stream_xor_f32(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 200
#if __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321 && \
    __BANG_ARCH__ != 303 && __BANG_ARCH__ != 306
static __mlu_func__ __mlu_builtin__ void __bang_xor(int* dst,
                                                    int* src0,
                                                    int* src1,
                                                    int elem_count) {
  __mlvm_stream_xor_s32(dst, src0, src1, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_xor(short* dst,
                                                    short* src0,
                                                    short* src1,
                                                    int elem_count) {
  __mlvm_stream_xor_s16(dst, src0, src1, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_xor(char* dst,
                                                    char* src0,
                                                    char* src1,
                                                    int elem_count) {
  __mlvm_stream_xor_s8(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 306
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_xor(bfloat16_t* dst,
                                                    bfloat16_t* src0,
                                                    bfloat16_t* src1,
                                                    int elem_count) {
  __mlvm_stream_xor_bf16(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321


// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector bit operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_bor(char* dst,
                                                    char* src0,
                                                    char* src1,
                                                    int elem_count) {
  __mlvm_stream_bor_b8(dst, src0, src1, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_band(char* dst,
                                                     char* src0,
                                                     char* src1,
                                                     int elem_count) {
  __mlvm_stream_band_b8(dst, src0, src1, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_bxor(char* dst,
                                                     char* src0,
                                                     char* src1,
                                                     int elem_count) {
  __mlvm_stream_bxor_b8(dst, src0, src1, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_bnot(char* dst,
                                                     char* src,
                                                     int elem_count) {
  __mlvm_stream_bnot_b8(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 200
#if __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321 && \
    __BANG_ARCH__ != 303 && __BANG_ARCH__ != 306
static __mlu_func__ __mlu_builtin__ void __bang_bor(int* dst,
                                                    int* src0,
                                                    int* src1,
                                                    int elem_count) {
  __mlvm_stream_bor_s32(dst, src0, src1, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_band(int* dst,
                                                     int* src0,
                                                     int* src1,
                                                     int elem_count) {
  __mlvm_stream_band_s32(dst, src0, src1, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_bxor(int* dst,
                                                     int* src0,
                                                     int* src1,
                                                     int elem_count) {
  __mlvm_stream_bxor_s32(dst, src0, src1, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_bnot(int* dst,
                                                     int* src,
                                                     int elem_count) {
  __mlvm_stream_bnot_s32(dst, src, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_bor(short* dst,
                                                    short* src0,
                                                    short* src1,
                                                    int elem_count) {
  __mlvm_stream_bor_s16(dst, src0, src1, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_band(short* dst,
                                                     short* src0,
                                                     short* src1,
                                                     int elem_count) {
  __mlvm_stream_band_s16(dst, src0, src1, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_bxor(short* dst,
                                                     short* src0,
                                                     short* src1,
                                                     int elem_count) {
  __mlvm_stream_bxor_s16(dst, src0, src1, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_bnot(short* dst,
                                                     short* src,
                                                     int elem_count) {
  __mlvm_stream_bnot_s16(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 306

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector cycle add operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_cycle_add(half* dst,
                                                          half* src,
                                                          half* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count) {
  __mlvm_stream_cycle_add_f16(dst, src, seg, src_elem_count, seg_elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_cycle_add_tz(half* dst,
                                                             half* src,
                                                             half* seg,
                                                             int src_elem_count,
                                                             int seg_elem_count) {
  __mlvm_stream_cycle_add_tz_f16(dst, src, seg, src_elem_count, seg_elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_cycle_add(float* dst,
                                                          float* src,
                                                          float* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count) {
  __mlvm_stream_cycle_add_f32(dst, src, seg, src_elem_count, seg_elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_cycle_add_tz(float* dst,
                                                             float* src,
                                                             float* seg,
                                                             int src_elem_count,
                                                             int seg_elem_count) {
  __mlvm_stream_cycle_add_tz_f32(dst, src, seg, src_elem_count, seg_elem_count);
}
#endif  // __BANG_ARCH__ >= 200
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_cycle_add(bfloat16_t* dst,
                                                          bfloat16_t* src,
                                                          bfloat16_t* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count) {
  __mlvm_stream_cycle_add_bf16(dst, src, seg, src_elem_count, seg_elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector cycle sub operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_cycle_sub(half* dst,
                                                          half* src,
                                                          half* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count) {
  __mlvm_stream_cycle_sub_f16(dst, src, seg, src_elem_count, seg_elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_cycle_sub(float* dst,
                                                          float* src,
                                                          float* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count) {
  __mlvm_stream_cycle_sub_f32(dst, src, seg, src_elem_count, seg_elem_count);
}
#endif  // __BANG_ARCH__ >= 200
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_cycle_sub(bfloat16_t* dst,
                                                          bfloat16_t* src,
                                                          bfloat16_t* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count) {
  __mlvm_stream_cycle_sub_bf16(dst, src, seg, src_elem_count, seg_elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
#endif  // __BANG_ARCH__ != 303 && __BANG_ARCH__ != 306

#if __BANG_ARCH__ > 300
static __mlu_func__ __mlu_builtin__ void __bang_round(float* dst,
                                                      float* src,
                                                      int size) {
  //TODO(libaoliang): support this interface on mtp_392
  __mlvm_stream_cvtfix32_f32_rn((int*)dst, src, size, 0);
  __mlvm_stream_cvtf32_fix32(dst, (int*)dst, size, 0);
#if __BANG_ARCH__ == 372 || __BANG_ARCH__ == 322
  asm volatile(
    "tfuse.nram.s32 [%[dst]], %[size], [%[dst]], "
    ".and(0x7fffffff), .lt(0x4b000000), "
    ".mul([%[dst]]);\n"
    ::[size]"r"(size),
      [dst]"r"(dst));
  asm volatile(
    "tfuse.nram.s32 [%[dst]], %[size], [%[src]], "
    ".and(0x7fffffff), .ge(0x4b000000), "
    ".mul([%[src]]), .add([%[dst]]);\n"
    ::[size]"r"(size),
      [dst]"r"(dst),
      [src]"r"(src));
#endif
}
static __mlu_func__ void __bang_floor(float* dst,
                                      float* src,
                                      int size) {
  //TODO(libaoliang): support this interface on mtp_392
  __mlvm_stream_cvtfix32_f32_dn((int*)dst, src, size, 0);
  __mlvm_stream_cvtf32_fix32(dst, (int*)dst, size, 0);
#if __BANG_ARCH__ == 372 || __BANG_ARCH__ == 322
  asm volatile(
    "tfuse.nram.s32 [%[dst]], %[size], [%[dst]], "
    ".and(0x7fffffff), .lt(0x4b000000), "
    ".mul([%[dst]]);\n"
    ::[size]"r"(size),
      [dst]"r"(dst));
  asm volatile(
    "tfuse.nram.s32 [%[dst]], %[size], [%[src]], "
    ".and(0x7fffffff), .ge(0x4b000000), "
    ".mul([%[src]]), .add([%[dst]]);\n"
    ::[size]"r"(size),
      [dst]"r"(dst),
      [src]"r"(src));
#endif
}
#endif

#if __BANG_ARCH__ >= 300
// max(NAN, val) -> val
static __mlu_func__ __mlu_builtin__ void __bang_maximum(float* dst,
                                                        float* src0,
                                                        float* src1,
                                                        int elem_count) {
  //TODO(libaoliang): support this interface on mtp_392
  __mlvm_stream_maxequal_f32(dst, src0, src1, elem_count);
#if __BANG_ARCH__ == 372 || __BANG_ARCH__ == 322
  asm volatile(
  "tfuse.nram.u32 [%[dst]], %[num], [%[src0]], "
  ".and(0x7fffffff), .ge(0x7f800001), .mul([%[src1]]);\n\t"
  :: [dst] "r"(src1), [num] "r"(elem_count), [src0] "r"(dst), [src1] "r"(src1));
  asm volatile(
  "tfuse.nram.u32 [%[dst]], %[num], [%[src0]], "
  ".and(0x7fffffff), .lt(0x7f800001), .mul([%[src2]]), .add([%[src1]]);\n\t"
  :: [dst] "r"(dst), [num] "r"(elem_count), [src0] "r"(dst), [src2] "r"(dst), [src1] "r"(src1));
#endif
}
// max(NAN, val) -> val
static __mlu_func__ __mlu_builtin__ void __bang_maximum(half* dst,
                                                        half* src0,
                                                        half* src1,
                                                        int elem_count) {
  //TODO(libaoliang): support this interface on mtp_392
  __mlvm_stream_maxequal_f16(dst, src0, src1, elem_count);
#if __BANG_ARCH__ == 372 || __BANG_ARCH__ == 322
  asm volatile(
  "tfuse.nram.u16 [%[dst]], %[num], [%[src0]], "
  ".and(0x7fff), .ge(0x7c01), .mul([%[src1]]);\n\t"
  :: [dst] "r"(src1), [num] "r"(elem_count), [src0] "r"(dst), [src1] "r"(src1));
  asm volatile(
  "tfuse.nram.u16 [%[dst]], %[num], [%[src0]], "
  ".and(0x7fff), .lt(0x7c01), .mul([%[src2]]), .add([%[src1]]);\n\t"
  :: [dst] "r"(dst), [num] "r"(elem_count), [src0] "r"(dst), [src2] "r"(dst), [src1] "r"(src1));
#endif
}
// min(NAN, val) -> val
static __mlu_func__ __mlu_builtin__ void __bang_minimum(half* dst,
                                                        half* src0,
                                                        half* src1,
                                                        int elem_count) {
  //TODO(libaoliang): support this interface on mtp_392
  __mlvm_stream_minequal_f16(dst, src0, src1, elem_count);
#if __BANG_ARCH__ == 372 || __BANG_ARCH__ == 322
  asm volatile(
  "tfuse.nram.u16 [%[dst]], %[num], [%[src0]], "
  ".and(0x7fff), .ge(0x7c01), .mul([%[src1]]);\n\t"
  :: [dst] "r"(src1), [num] "r"(elem_count), [src0] "r"(dst), [src1] "r"(src1));
  asm volatile(
  "tfuse.nram.u16 [%[dst]], %[num], [%[src0]], "
  ".and(0x7fff), .lt(0x7c01), .mul([%[src2]]), .add([%[src1]]);\n\t"
  :: [dst] "r"(dst), [num] "r"(elem_count), [src0] "r"(dst), [src2] "r"(dst), [src1] "r"(src1));
#endif
}
// min(NAN, val) -> val
static __mlu_func__ __mlu_builtin__ void __bang_minimum(float* dst,
                                                        float* src0,
                                                        float* src1,
                                                        int elem_count) {
  //TODO(libaoliang): support this interface on mtp_392
  __mlvm_stream_minequal_f32(dst, src0, src1, elem_count);
#if __BANG_ARCH__ == 372 || __BANG_ARCH__ == 322
  asm volatile(
  "tfuse.nram.u32 [%[dst]], %[num], [%[src0]], "
  ".and(0x7fffffff), .ge(0x7f800001), .mul([%[src1]]);\n\t"
  :: [dst] "r"(src1), [num] "r"(elem_count), [src0] "r"(dst), [src1] "r"(src1));
  asm volatile(
  "tfuse.nram.u32 [%[dst]], %[num], [%[src0]], "
  ".and(0x7fffffff), .lt(0x7f800001), .mul([%[src2]]), .add([%[src1]]);\n\t"
  :: [dst] "r"(dst), [num] "r"(elem_count), [src0] "r"(dst), [src2] "r"(dst), [src1] "r"(src1));
#endif
}
#endif

#if __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 306
// max(NAN, val) -> val
static __mlu_func__ __mlu_builtin__ void __bang_cycle_maximum(half* dst,
                                                              half* src,
                                                              half* seg,
                                                              int src_elem_count,
                                                              int seg_elem_count) {
  //TODO(libaoliang): support this interface on mtp_392
  __mlvm_stream_cycle_maxequal_f16(dst, dst, seg, src_elem_count, seg_elem_count);
#if __BANG_ARCH__ == 372 || __BANG_ARCH__ == 322
  asm volatile(
  "tfuse.nram.u16 [%[dst]], %[num_long], %[num_short], [%[src0]], "
  ".and(0x7fff), .ge(0x7c01), .mul.cycle([%[src1]]);\n\t"
  :: [dst] "r"(seg), [num_long] "r"(src_elem_count), [num_short] "r"(seg_elem_count), [src0] "r"(dst), [src1] "r"(seg));
  asm volatile(
  "tfuse.nram.u16 [%[dst]], %[num_long], %[num_short], [%[src0]], "
  ".and(0x7fff), .lt(0x7c01), .mul.cycle([%[src2]]), .add.cycle([%[src1]]);\n\t"
  :: [dst] "r"(dst), [num_long] "r"(src_elem_count), [num_short] "r"(seg_elem_count), [src0] "r"(dst), [src2] "r"(dst), [src1] "r"(seg));
#endif
}
// max(NAN, val) -> val
static __mlu_func__ __mlu_builtin__ void __bang_cycle_maximum(float* dst,
                                                              float* src,
                                                              float* seg,
                                                              int src_elem_count,
                                                              int seg_elem_count) {
  //TODO(libaoliang): support this interface on mtp_392
  __mlvm_stream_cycle_maxequal_f32(dst, dst, seg, src_elem_count, seg_elem_count);
#if __BANG_ARCH__ == 372 || __BANG_ARCH__ == 322
  asm volatile(
  "tfuse.nram.u32 [%[dst]], %[num_long], %[num_short], [%[src0]], "
  ".and(0x7fffffff), .ge(0x7f800001), .mul.cycle([%[src1]]);\n\t"
  :: [dst] "r"(seg), [num_long] "r"(src_elem_count), [num_short] "r"(seg_elem_count), [src0] "r"(dst), [src1] "r"(seg));
  asm volatile(
  "tfuse.nram.u32 [%[dst]], %[num_long], %[num_short], [%[src0]], "
  ".and(0x7fffffff), .lt(0x7f800001), .mul.cycle([%[src2]]), .add.cycle([%[src1]]);\n\t"
  :: [dst] "r"(dst), [num_long] "r"(src_elem_count), [num_short] "r"(seg_elem_count), [src0] "r"(dst), [src2] "r"(dst), [src1] "r"(seg));
#endif
}
// min(NAN, val) -> val
static __mlu_func__ __mlu_builtin__ void __bang_cycle_minimum(half* dst,
                                                              half* src,
                                                              half* seg,
                                                              int src_elem_count,
                                                              int seg_elem_count) {
  //TODO(libaoliang): support this interface on mtp_392
  __mlvm_stream_cycle_minequal_f16(dst, dst, seg, src_elem_count, seg_elem_count);
#if __BANG_ARCH__ == 372 || __BANG_ARCH__ == 322
  asm volatile(
  "tfuse.nram.u16 [%[dst]], %[num_long], %[num_short], [%[src0]], "
  ".and(0x7fff), .ge(0x7c01), .mul.cycle([%[src1]]);\n\t"
  :: [dst] "r"(seg), [num_long] "r"(src_elem_count), [num_short] "r"(seg_elem_count), [src0] "r"(dst), [src1] "r"(seg));
  asm volatile(
  "tfuse.nram.u16 [%[dst]], %[num_long], %[num_short], [%[src0]], "
  ".and(0x7fff), .lt(0x7c01), .mul.cycle([%[src2]]), .add.cycle([%[src1]]);\n\t"
  :: [dst] "r"(dst), [num_long] "r"(src_elem_count), [num_short] "r"(seg_elem_count), [src0] "r"(dst), [src2] "r"(dst), [src1] "r"(seg));
#endif
}
// min(NAN, val) -> val
static __mlu_func__ __mlu_builtin__ void __bang_cycle_minimum(float* dst,
                                                              float* src,
                                                              float* seg,
                                                              int src_elem_count,
                                                              int seg_elem_count) {
  //TODO(libaoliang): support this interface on mtp_392
  __mlvm_stream_cycle_minequal_f32(dst, dst, seg, src_elem_count, seg_elem_count);
#if __BANG_ARCH__ == 372 || __BANG_ARCH__ == 322
  asm volatile(
  "tfuse.nram.u32 [%[dst]], %[num_long], %[num_short], [%[src0]], "
  ".and(0x7fffffff), .ge(0x7f800001), .mul.cycle([%[src1]]);\n\t"
  :: [dst] "r"(seg), [num_long] "r"(src_elem_count), [num_short] "r"(seg_elem_count), [src0] "r"(dst), [src1] "r"(seg));
  asm volatile(
  "tfuse.nram.u32 [%[dst]], %[num_long], %[num_short], [%[src0]], "
  ".and(0x7fffffff), .lt(0x7f800001), .mul.cycle([%[src2]]), .add.cycle([%[src1]]);\n\t"
  :: [dst] "r"(dst), [num_long] "r"(src_elem_count), [num_short] "r"(seg_elem_count), [src0] "r"(dst), [src2] "r"(dst), [src1] "r"(seg));
#endif
}
#endif

#if __BANG_ARCH__ >= 300
// max(NAN, val) -> NAN
static __mlu_func__ __mlu_builtin__ void __bang_nan_maximum(half* dst,
                                                            half* src0,
                                                            half* src1,
                                                            int elem_count) {
  //TODO(libaoliang): support this interface on mtp_392
#if __BANG_ARCH__ == 372 || __BANG_ARCH__ == 322
  if (dst == src1) {
    src1 = src0;
    src0 = dst;
  }
  asm volatile(
  "tfuse.nram.u16 [%[dst]], %[elem_count], [%[src1]], "
  ".and(0x7fff), .lt(0x7c01), .mul([%[src0]]);\n\t"
   :: [dst] "r"(dst), [elem_count] "r"(elem_count), [src1] "r"(src1), [src0] "r"(src0));
  asm volatile(
  "tfuse.nram.u16 [%[dst]], %[elem_count], [%[src1]], "
  ".and(0x7fff), .ge(0x7c01), .mul(0x7fff), .add([%[src0]]);\n\t"
  :: [dst] "r"(dst), [elem_count] "r"(elem_count), [src1] "r"(src1), [src0] "r"(dst));
  __mlvm_stream_maxequal_f16(dst, dst, src1, elem_count);
#else
  __mlvm_stream_maxequal_f16(dst, src0, src1, elem_count);
#endif
}
// min(NAN, val) -> NAN
static __mlu_func__ __mlu_builtin__ void __bang_nan_minimum(half* dst,
                                                            half* src0,
                                                            half* src1,
                                                            int elem_count) {
  //TODO(libaoliang): support this interface on mtp_392
#if __BANG_ARCH__ == 372 || __BANG_ARCH__ == 322
  if (dst == src1) {
    src1 = src0;
    src0 = dst;
  }
  asm volatile(
  "tfuse.nram.u16 [%[dst]], %[elem_count], [%[src1]], "
  ".and(0x7fff), .lt(0x7c01), .mul([%[src0]]);\n\t"
   :: [dst] "r"(dst), [elem_count] "r"(elem_count), [src1] "r"(src1), [src0] "r"(src0));
  asm volatile(
  "tfuse.nram.u16 [%[dst]], %[elem_count], [%[src1]], "
  ".and(0x7fff), .ge(0x7c01), .mul(0x7fff), .add([%[src0]]);\n\t"
  :: [dst] "r"(dst), [elem_count] "r"(elem_count), [src1] "r"(src1), [src0] "r"(dst));
  __mlvm_stream_minequal_f16(dst, dst, src1, elem_count);
#else
  __mlvm_stream_minequal_f16(dst, src0, src1, elem_count);
#endif
}
// min(NAN, val) -> NAN
static __mlu_func__ __mlu_builtin__ void __bang_nan_minimum(float* dst,
                                                            float* src0,
                                                            float* src1,
                                                            int elem_count) {
  //TODO(libaoliang): support this interface on mtp_392
#if __BANG_ARCH__ == 372 || __BANG_ARCH__ == 322
  if (dst == src1) {
    src1 = src0;
    src0 = dst;
  }
  asm volatile(
  "tfuse.nram.u32 [%[dst]], %[elem_count], [%[src1]], "
  ".and(0x7fffffff), .lt(0x7f800001), .mul([%[src0]]);\n\t"
   :: [dst] "r"(dst), [elem_count] "r"(elem_count), [src1] "r"(src1), [src0] "r"(src0));
  asm volatile(
  "tfuse.nram.u32 [%[dst]], %[elem_count], [%[src1]], "
  ".and(0x7fffffff), .ge(0x7f800001), .mul(0x7fffffff), .add([%[src0]]);\n\t"
  :: [dst] "r"(dst), [elem_count] "r"(elem_count), [src1] "r"(src1), [src0] "r"(dst));
  __mlvm_stream_minequal_f32(dst, dst, src1, elem_count);
#else
  __mlvm_stream_minequal_f32(dst, src0, src1, elem_count);
#endif
}
// max(NAN, val) -> NAN
static __mlu_func__ __mlu_builtin__ void __bang_nan_maximum(float* dst,
                                                            float* src0,
                                                            float* src1,
                                                            int elem_count) {
  //TODO(libaoliang): support this interface on mtp_392
#if __BANG_ARCH__ == 372 || __BANG_ARCH__ == 322
  if (dst == src1) {
    src1 = src0;
    src0 = dst;
  }
  asm volatile(
  "tfuse.nram.u32 [%[dst]], %[elem_count], [%[src1]], "
  ".and(0x7fffffff), .lt(0x7f800001), .mul([%[src0]]);\n\t"
   :: [dst] "r"(dst), [elem_count] "r"(elem_count), [src1] "r"(src1), [src0] "r"(src0));
  asm volatile(
  "tfuse.nram.u32 [%[dst]], %[elem_count], [%[src1]], "
  ".and(0x7fffffff), .ge(0x7f800001), .mul(0x7fffffff), .add([%[src0]]);\n\t"
  :: [dst] "r"(dst), [elem_count] "r"(elem_count), [src1] "r"(src1), [src0] "r"(dst));
  __mlvm_stream_maxequal_f32(dst, dst, src1, elem_count);
#else
  __mlvm_stream_maxequal_f32(dst, src0, src1, elem_count);
#endif
}
#endif

#if __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 306
// max(NAN, val) -> NAN
static __mlu_func__ __mlu_builtin__ void __bang_cycle_nan_maximum(half* dst,
                                                                  half* src,
                                                                  half* seg,
                                                                  int src_elem_count,
                                                                  int seg_elem_count) {
  //TODO(libaoliang): support this interface on mtp_392
#if __BANG_ARCH__ == 372 || __BANG_ARCH__ == 322
  if (dst == seg) {
    seg = src;
    src = dst;
  }
  asm volatile(
  "tfuse.nram.u16 [%[dst]], %[num_long], %[num_short], [%[src1]], "
  ".and(0x7fff), .lt(0x7c01), .mul.cycle([%[src0]]);\n\t"
   :: [dst] "r"(dst), [num_long] "r"(src_elem_count), [num_short] "r"(seg_elem_count), [src1] "r"(seg), [src0] "r"(src));
  asm volatile(
  "tfuse.nram.u16 [%[dst]], %[num_long], %[num_short], [%[src1]], "
  ".and(0x7fff), .ge(0x7c01), .mul(0x7fff), .add.cycle([%[src0]]);\n\t"
  :: [dst] "r"(dst), [num_long] "r"(src_elem_count), [num_short] "r"(seg_elem_count), [src1] "r"(seg), [src0] "r"(dst));
  __mlvm_stream_cycle_maxequal_f16(dst, dst, seg, src_elem_count, seg_elem_count);
#else
  __mlvm_stream_cycle_maxequal_f16(dst, src, seg, src_elem_count, seg_elem_count);
#endif
}
// max(NAN, val) -> NAN
static __mlu_func__ __mlu_builtin__ void __bang_cycle_nan_maximum(float* dst,
                                                                  float* src,
                                                                  float* seg,
                                                                  int src_elem_count,
                                                                  int seg_elem_count) {
  //TODO(libaoliang): support this interface on mtp_392
#if __BANG_ARCH__ == 372 || __BANG_ARCH__ == 322
  if (dst == seg) {
    seg = src;
    src = dst;
  }
  asm volatile(
  "tfuse.nram.u32 [%[dst]], %[num_long], %[num_short], [%[src1]], "
  ".and(0x7fffffff), .lt(0x7f800001), .mul.cycle([%[src0]]);\n\t"
   :: [dst] "r"(dst), [num_long] "r"(src_elem_count), [num_short] "r"(seg_elem_count), [src1] "r"(seg), [src0] "r"(src));
  asm volatile(
  "tfuse.nram.u32 [%[dst]], %[num_long], %[num_short], [%[src1]], "
  ".and(0x7fffffff), .ge(0x7f800001), .mul(0x7fffffff), .add.cycle([%[src0]]);\n\t"
  :: [dst] "r"(dst), [num_long] "r"(src_elem_count), [num_short] "r"(seg_elem_count), [src1] "r"(seg), [src0] "r"(dst));
  __mlvm_stream_cycle_maxequal_f32(dst, dst, seg, src_elem_count, seg_elem_count);
#else
  __mlvm_stream_cycle_maxequal_f32(dst, src, seg, src_elem_count, seg_elem_count);
#endif
}
// min(NAN, val) -> NAN
static __mlu_func__ __mlu_builtin__ void __bang_cycle_nan_minimum(half* dst,
                                                                  half* src,
                                                                  half* seg,
                                                                  int src_elem_count,
                                                                  int seg_elem_count) {
  //TODO(libaoliang): support this interface on mtp_392
#if __BANG_ARCH__ == 372 || __BANG_ARCH__ == 322
  if (dst == seg) {
    seg = src;
    src = dst;
  }
  asm volatile(
  "tfuse.nram.u16 [%[dst]], %[num_long], %[num_short], [%[src1]], "
  ".and(0x7fff), .lt(0x7c01), .mul.cycle([%[src0]]);\n\t"
   :: [dst] "r"(dst), [num_long] "r"(src_elem_count), [num_short] "r"(seg_elem_count), [src1] "r"(seg), [src0] "r"(src));
  asm volatile(
  "tfuse.nram.u16 [%[dst]], %[num_long], %[num_short], [%[src1]], "
  ".and(0x7fff), .ge(0x7c01), .mul(0x7fff), .add.cycle([%[src0]]);\n\t"
  :: [dst] "r"(dst), [num_long] "r"(src_elem_count), [num_short] "r"(seg_elem_count), [src1] "r"(seg), [src0] "r"(dst));
  __mlvm_stream_cycle_minequal_f16(dst, dst, seg, src_elem_count, seg_elem_count);
#else
  __mlvm_stream_cycle_minequal_f16(dst, src, seg, src_elem_count, seg_elem_count);
#endif
}
// min(NAN, val) -> NAN
static __mlu_func__ __mlu_builtin__ void __bang_cycle_nan_minimum(float* dst,
                                                                  float* src,
                                                                  float* seg,
                                                                  int src_elem_count,
                                                                  int seg_elem_count) {
  //TODO(libaoliang): support this interface on mtp_392
#if __BANG_ARCH__ == 372 || __BANG_ARCH__ == 322
  if (dst == seg) {
    seg = src;
    src = dst;
  }
  asm volatile(
  "tfuse.nram.u32 [%[dst]], %[num_long], %[num_short], [%[src1]], "
  ".and(0x7fffffff), .lt(0x7f800001), .mul.cycle([%[src0]]);\n\t"
   :: [dst] "r"(dst), [num_long] "r"(src_elem_count), [num_short] "r"(seg_elem_count), [src1] "r"(seg), [src0] "r"(src));
  asm volatile(
  "tfuse.nram.u32 [%[dst]], %[num_long], %[num_short], [%[src1]], "
  ".and(0x7fffffff), .ge(0x7f800001), .mul(0x7fffffff), .add.cycle([%[src0]]);\n\t"
  :: [dst] "r"(dst), [num_long] "r"(src_elem_count), [num_short] "r"(seg_elem_count), [src1] "r"(seg), [src0] "r"(dst));
  __mlvm_stream_cycle_minequal_f32(dst, dst, seg, src_elem_count, seg_elem_count);
#else
  __mlvm_stream_cycle_minequal_f32(dst, src, seg, src_elem_count, seg_elem_count);
#endif
}
#endif

#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_maxequal(half* dst,
                                                         half* src0,
                                                         half* src1,
                                                         int elem_count) {
  __mlvm_stream_maxequal_f16(dst, src0, src1, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_maxequal(float* dst,
                                                         float* src0,
                                                         float* src1,
                                                         int elem_count) {
  __mlvm_stream_maxequal_f32(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 200
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_maxequal(bfloat16_t* dst,
                                                         bfloat16_t* src0,
                                                         bfloat16_t* src1,
                                                         int elem_count) {
  __mlvm_stream_maxequal_bf16(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector min-equal operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 300
// min(NAN, val) -> NAN
static __mlu_func__ __mlu_builtin__ void __bang_mininum(half* dst,
                                                        half* src0,
                                                        half* src1,
                                                        int elem_count) {
#if __BANG_ARCH__ == 372 || __BANG_ARCH__ == 322
  if (dst == src1) {
    src1 = src0;
    src0 = dst;
  }
  asm volatile(
  "tfuse.nram.u16 [%[dst]], %[elem_count], [%[src1]], "
  ".and(0x7fff), .lt(0x7c01), .mul([%[src0]]);\n\t"
   :: [dst] "r"(dst), [elem_count] "r"(elem_count), [src1] "r"(src1), [src0] "r"(src0));
  asm volatile(
  "tfuse.nram.u16 [%[dst]], %[elem_count], [%[src1]], "
  ".and(0x7fff), .ge(0x7c01), .mul(0x7fff), .add([%[src0]]);\n\t"
  :: [dst] "r"(dst), [elem_count] "r"(elem_count), [src1] "r"(src1), [src0] "r"(dst));
  __mlvm_stream_minequal_f16(dst, dst, src1, elem_count);
#else
  __mlvm_stream_minequal_f16(dst, src0, src1, elem_count);
#endif
}
// min(NAN, val) -> NAN
static __mlu_func__ __mlu_builtin__ void __bang_mininum(float* dst,
                                                        float* src0,
                                                        float* src1,
                                                        int elem_count) {
#if __BANG_ARCH__ == 372 || __BANG_ARCH__ == 322
  if (dst == src1) {
    src1 = src0;
    src0 = dst;
  }
  asm volatile(
  "tfuse.nram.u32 [%[dst]], %[elem_count], [%[src1]], "
  ".and(0x7fffffff), .lt(0x7f800001), .mul([%[src0]]);\n\t"
   :: [dst] "r"(dst), [elem_count] "r"(elem_count), [src1] "r"(src1), [src0] "r"(src0));
  asm volatile(
  "tfuse.nram.u32 [%[dst]], %[elem_count], [%[src1]], "
  ".and(0x7fffffff), .ge(0x7f800001), .mul(0x7fffffff), .add([%[src0]]);\n\t"
  :: [dst] "r"(dst), [elem_count] "r"(elem_count), [src1] "r"(src1), [src0] "r"(dst));
  __mlvm_stream_minequal_f32(dst, dst, src1, elem_count);
#else
  __mlvm_stream_minequal_f32(dst, src0, src1, elem_count);
#endif
}
#endif

#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_minequal(half* dst,
                                                         half* src0,
                                                         half* src1,
                                                         int elem_count) {
  __mlvm_stream_minequal_f16(dst, src0, src1, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_minequal(float* dst,
                                                         float* src0,
                                                         float* src1,
                                                         int elem_count) {
  __mlvm_stream_minequal_f32(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 200
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_minequal(bfloat16_t* dst,
                                                         bfloat16_t* src0,
                                                         bfloat16_t* src1,
                                                         int elem_count) {
  __mlvm_stream_minequal_bf16(dst, src0, src1, elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector cycle max-equal operation
// -----------------------------------------------------------------------------
#define STREAM_CVT_OTHERS(_1, _2, _3, _4, _5, _6, NAME, ...) NAME
#if (__BANG_ARCH__ != 303) && (__BANG_ARCH__ != 306)
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_cycle_maxequal(half* dst,
                                                               half* src,
                                                               half* seg,
                                                               int src_elem_count,
                                                               int seg_elem_count) {
  __mlvm_stream_cycle_maxequal_f16(dst, src, seg, src_elem_count, seg_elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_cycle_maxequal(float* dst,
                                                               float* src,
                                                               float* seg,
                                                               int src_elem_count,
                                                               int seg_elem_count) {
  __mlvm_stream_cycle_maxequal_f32(dst, src, seg, src_elem_count, seg_elem_count);
}
#endif  // __BANG_ARCH__ >= 200
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_cycle_maxequal(bfloat16_t* dst,
                                                               bfloat16_t* src,
                                                               bfloat16_t* seg,
                                                               int src_elem_count,
                                                               int seg_elem_count) {
  __mlvm_stream_cycle_maxequal_bf16(dst, src, seg, src_elem_count, seg_elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector cycle min-equal operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_cycle_minequal(half* dst,
                                                               half* src,
                                                               half* seg,
                                                               int src_elem_count,
                                                               int seg_elem_count) {
  __mlvm_stream_cycle_minequal_f16(dst, src, seg, src_elem_count, seg_elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_cycle_minequal(float* dst,
                                                               float* src,
                                                               float* seg,
                                                               int src_elem_count,
                                                               int seg_elem_count) {
  __mlvm_stream_cycle_minequal_f32(dst, src, seg, src_elem_count, seg_elem_count);
}
#endif  // __BANG_ARCH__ >= 200
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_cycle_minequal(bfloat16_t* dst,
                                                               bfloat16_t* src,
                                                               bfloat16_t* seg,
                                                               int src_elem_count,
                                                               int seg_elem_count) {
  __mlvm_stream_cycle_minequal_bf16(dst, src, seg, src_elem_count, seg_elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector cycle mul operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_cycle_mul(half* dst,
                                                          half* src,
                                                          half* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count) {
  __mlvm_stream_cycle_mul_f16(dst, src, seg, src_elem_count, seg_elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_cycle_mul(float* dst,
                                                          float* src,
                                                          float* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count) {
  __mlvm_stream_cycle_mul_f32(dst, src, seg, src_elem_count, seg_elem_count);
}
#endif  // __BANG_ARCH__ >= 200
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_cycle_mul(bfloat16_t* dst,
                                                          bfloat16_t* src,
                                                          bfloat16_t* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count) {
  __mlvm_stream_cycle_mul_bf16(dst, src, seg, src_elem_count, seg_elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector cycle equal comparison operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_cycle_eq(half* dst,
                                                         half* src,
                                                         half* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count) {
  __mlvm_stream_cycle_eq_f16(dst, src, seg, src_elem_count, seg_elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_cycle_eq(float* dst,
                                                         float* src,
                                                         float* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count) {
  __mlvm_stream_cycle_eq_f32(dst, src, seg, src_elem_count, seg_elem_count);
}
#endif  // __BANG_ARCH__ >= 200

#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_cycle_eq(bfloat16_t* dst,
                                                         bfloat16_t* src,
                                                         bfloat16_t* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count) {
  __mlvm_stream_cycle_eq_bf16(dst, src, seg, src_elem_count, seg_elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector cycle not-equal comparison operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_cycle_ne(half* dst,
                                                         half* src,
                                                         half* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count) {
  __mlvm_stream_cycle_ne_f16(dst, src, seg, src_elem_count, seg_elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_cycle_ne(float* dst,
                                                         float* src,
                                                         float* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count) {
  __mlvm_stream_cycle_ne_f32(dst, src, seg, src_elem_count, seg_elem_count);
}
#endif  // __BANG_ARCH__ >= 200

#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_cycle_ne(bfloat16_t* dst,
                                                         bfloat16_t* src,
                                                         bfloat16_t* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count) {
  __mlvm_stream_cycle_ne_bf16(dst, src, seg, src_elem_count, seg_elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector cycle greater comparison operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_cycle_gt(half* dst,
                                                         half* src,
                                                         half* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count) {
  __mlvm_stream_cycle_gt_f16(dst, src, seg, src_elem_count, seg_elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_cycle_gt(float* dst,
                                                         float* src,
                                                         float* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count) {
  __mlvm_stream_cycle_gt_f32(dst, src, seg, src_elem_count, seg_elem_count);
}
#endif  // __BANG_ARCH__ >= 200

#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_cycle_gt(bfloat16_t* dst,
                                                         bfloat16_t* src,
                                                         bfloat16_t* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count) {
  __mlvm_stream_cycle_gt_bf16(dst, src, seg, src_elem_count, seg_elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector cycle greater-equal comparison operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_cycle_ge(half* dst,
                                                         half* src,
                                                         half* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count) {
  __mlvm_stream_cycle_ge_f16(dst, src, seg, src_elem_count, seg_elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_cycle_ge(float* dst,
                                                         float* src,
                                                         float* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count) {
  __mlvm_stream_cycle_ge_f32(dst, src, seg, src_elem_count, seg_elem_count);
}
#endif  // __BANG_ARCH__ >= 200

#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_cycle_ge(bfloat16_t* dst,
                                                         bfloat16_t* src,
                                                         bfloat16_t* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count) {
  __mlvm_stream_cycle_ge_bf16(dst, src, seg, src_elem_count, seg_elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector cycle little comparison operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_cycle_lt(half* dst,
                                                         half* src,
                                                         half* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count) {
  __mlvm_stream_cycle_lt_f16(dst, src, seg, src_elem_count, seg_elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_cycle_lt(float* dst,
                                                         float* src,
                                                         float* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count) {
  __mlvm_stream_cycle_lt_f32(dst, src, seg, src_elem_count, seg_elem_count);
}
#endif  // __BANG_ARCH__ >= 200

#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_cycle_lt(bfloat16_t* dst,
                                                         bfloat16_t* src,
                                                         bfloat16_t* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count) {
  __mlvm_stream_cycle_lt_bf16(dst, src, seg, src_elem_count, seg_elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector cycle little-equal comparison operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_cycle_le(half* dst,
                                                         half* src,
                                                         half* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count) {
  __mlvm_stream_cycle_le_f16(dst, src, seg, src_elem_count, seg_elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_cycle_le(float* dst,
                                                         float* src,
                                                         float* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count) {
  __mlvm_stream_cycle_le_f32(dst, src, seg, src_elem_count, seg_elem_count);
}
#endif  // __BANG_ARCH__ >= 200

#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_cycle_le(bfloat16_t* dst,
                                                         bfloat16_t* src,
                                                         bfloat16_t* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count) {
  __mlvm_stream_cycle_le_bf16(dst, src, seg, src_elem_count, seg_elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector cycle and operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_cycle_and(half* dst,
                                                          half* src,
                                                          half* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count) {
  __mlvm_stream_cycle_and_f16(dst, src, seg, src_elem_count, seg_elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_cycle_and(float* dst,
                                                          float* src,
                                                          float* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count) {
  __mlvm_stream_cycle_and_f32(dst, src, seg, src_elem_count, seg_elem_count);
}
#endif  // __BANG_ARCH__ >= 200
#if __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321 && \
    __BANG_ARCH__ != 303 && __BANG_ARCH__ != 306
static __mlu_func__ __mlu_builtin__ void __bang_cycle_and(int* dst,
                                                          int* src,
                                                          int* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count) {
  __mlvm_stream_cycle_and_s32(dst, src, seg, src_elem_count, seg_elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_cycle_and(short* dst,
                                                          short* src,
                                                          short* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count) {
  __mlvm_stream_cycle_and_s16(dst, src, seg, src_elem_count, seg_elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_cycle_and(char* dst,
                                                          char* src,
                                                          char* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count) {
  __mlvm_stream_cycle_and_s8(dst, src, seg, src_elem_count, seg_elem_count);
}
#endif  // __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 306
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_cycle_and(bfloat16_t* dst,
                                                          bfloat16_t* src,
                                                          bfloat16_t* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count) {
  __mlvm_stream_cycle_and_bf16(dst, src, seg, src_elem_count, seg_elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321


// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector cycle or operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_cycle_or(half* dst,
                                                         half* src,
                                                         half* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count) {
  __mlvm_stream_cycle_or_f16(dst, src, seg, src_elem_count, seg_elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_cycle_or(float* dst,
                                                         float* src,
                                                         float* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count) {
  __mlvm_stream_cycle_or_f32(dst, src, seg, src_elem_count, seg_elem_count);
}
#endif  // __BANG_ARCH__ >= 200
#if __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321 && \
    __BANG_ARCH__ != 303 && __BANG_ARCH__ != 306
static __mlu_func__ __mlu_builtin__ void __bang_cycle_or(int* dst,
                                                         int* src,
                                                         int* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count) {
  __mlvm_stream_cycle_or_s32(dst, src, seg, src_elem_count, seg_elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_cycle_or(short* dst,
                                                         short* src,
                                                         short* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count) {
  __mlvm_stream_cycle_or_s16(dst, src, seg, src_elem_count, seg_elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_cycle_or(char* dst,
                                                         char* src,
                                                         char* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count) {
  __mlvm_stream_cycle_or_s8(dst, src, seg, src_elem_count, seg_elem_count);
}
#endif  // __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 306
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_cycle_or(bfloat16_t* dst,
                                                         bfloat16_t* src,
                                                         bfloat16_t* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count) {
  __mlvm_stream_cycle_or_bf16(dst, src, seg, src_elem_count, seg_elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector cycle xor operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_cycle_xor(half* dst,
                                                          half* src,
                                                          half* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count) {
  __mlvm_stream_cycle_xor_f16(dst, src, seg, src_elem_count, seg_elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_cycle_xor(float* dst,
                                                          float* src,
                                                          float* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count) {
  __mlvm_stream_cycle_xor_f32(dst, src, seg, src_elem_count, seg_elem_count);
}
#endif  // __BANG_ARCH__ >= 200
#if __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321 && \
    __BANG_ARCH__ != 303 && __BANG_ARCH__ != 306
static __mlu_func__ __mlu_builtin__ void __bang_cycle_xor(int* dst,
                                                          int* src,
                                                          int* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count) {
  __mlvm_stream_cycle_xor_s32(dst, src, seg, src_elem_count, seg_elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_cycle_xor(short* dst,
                                                          short* src,
                                                          short* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count) {
  __mlvm_stream_cycle_xor_s16(dst, src, seg, src_elem_count, seg_elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_cycle_xor(char* dst,
                                                          char* src,
                                                          char* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count) {
  __mlvm_stream_cycle_xor_s8(dst, src, seg, src_elem_count, seg_elem_count);
}
#endif  // __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 306
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_cycle_xor(bfloat16_t* dst,
                                                          bfloat16_t* src,
                                                          bfloat16_t* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count) {
  __mlvm_stream_cycle_xor_bf16(dst, src, seg, src_elem_count, seg_elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector cycle bit operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_cycle_bxor(char* dst,
                                                           char* src,
                                                           char* seg,
                                                           int src_elem_count,
                                                           int seg_elem_count) {
  __mlvm_stream_cycle_bxor_b8(dst, src, seg, src_elem_count, seg_elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_cycle_band(char* dst,
                                                           char* src,
                                                           char* seg,
                                                           int src_elem_count,
                                                           int seg_elem_count) {
  __mlvm_stream_cycle_band_b8(dst, src, seg, src_elem_count, seg_elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_cycle_bor(char* dst,
                                                          char* src,
                                                          char* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count) {
  __mlvm_stream_cycle_bor_b8(dst, src, seg, src_elem_count, seg_elem_count);
}
#endif  // __BANG_ARCH__ >= 200
#if __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321 && \
    __BANG_ARCH__ != 303 && __BANG_ARCH__ != 306
static __mlu_func__ __mlu_builtin__ void __bang_cycle_bxor(int* dst,
                                                           int* src,
                                                           int* seg,
                                                           int src_elem_count,
                                                           int seg_elem_count) {
  __mlvm_stream_cycle_bxor_s32(dst, src, seg, src_elem_count, seg_elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_cycle_band(int* dst,
                                                           int* src,
                                                           int* seg,
                                                           int src_elem_count,
                                                           int seg_elem_count) {
  __mlvm_stream_cycle_band_s32(dst, src, seg, src_elem_count, seg_elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_cycle_bor(int* dst,
                                                          int* src,
                                                          int* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count) {
  __mlvm_stream_cycle_bor_s32(dst, src, seg, src_elem_count, seg_elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_cycle_bxor(short* dst,
                                                           short* src,
                                                           short* seg,
                                                           int src_elem_count,
                                                           int seg_elem_count) {
  __mlvm_stream_cycle_bxor_s16(dst, src, seg, src_elem_count, seg_elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_cycle_band(short* dst,
                                                           short* src,
                                                           short* seg,
                                                           int src_elem_count,
                                                           int seg_elem_count) {
  __mlvm_stream_cycle_band_s16(dst, src, seg, src_elem_count, seg_elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_cycle_bor(short* dst,
                                                          short* src,
                                                          short* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count) {
  __mlvm_stream_cycle_bor_s16(dst, src, seg, src_elem_count, seg_elem_count);
}
#endif  // __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 306

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector select operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_select(half* dst,
                                                       half* src,
                                                       half* index,
                                                       int elem_count) {
  __mlvm_stream_select_f16(dst, src, index, elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_select(float* dst,
                                                       float* src,
                                                       float* index,
                                                       int elem_count) {
  __mlvm_stream_select_f32(dst, src, index, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector select with bit index operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_select_bitindex(half* dst,
                                                                half* src,
                                                                void* bitindex,
                                                                int elem_count) {
  __mlvm_stream_select_bitindex_f16(dst, src, bitindex, elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_select_bitindex(float* dst,
                                                                float* src,
                                                                void* bitindex,
                                                                int elem_count) {
  __mlvm_stream_select_bitindex_f32(dst, src, bitindex, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector collect operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_collect(half* dst,
                                                        half* src,
                                                        half* mask,
                                                        int elem_count) {
  __mlvm_stream_collect_f16(dst, src, mask, elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_collect(float* dst,
                                                        float* src,
                                                        float* mask,
                                                        int elem_count) {
  __mlvm_stream_collect_f32(dst, src, mask, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector collect with bit index operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_collect_bitindex(half* dst,
                                                                 half* src,
                                                                 void* bitmask,
                                                                 int elem_count) {
  __mlvm_stream_collect_bitindex_f16(dst, src, bitmask, elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_collect_bitindex(float* dst,
                                                                 float* src,
                                                                 void* bitmask,
                                                                 int elem_count) {
  __mlvm_stream_collect_bitindex_f32(dst, src, bitmask, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector maskmove operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_maskmove(half* dst,
                                                         half* src,
                                                         half* mask,
                                                         int elem_count) {
  __mlvm_stream_maskmove_f16(dst, src, mask, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_maskmove(float* dst,
                                                         float* src,
                                                         float* mask,
                                                         int elem_count) {
  __mlvm_stream_maskmove_f32(dst, src, mask, elem_count);
}
#endif  // __BANG_ARCH__ >= 200
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_maskmove(bfloat16_t* dst,
                                                         bfloat16_t* src,
                                                         bfloat16_t* mask,
                                                         int elem_count) {
  __mlvm_stream_maskmove_bf16(dst, src, mask, elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector maskmove with bit index operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_maskmove_bitindex(half* dst,
                                                                  half* src,
                                                                  void* bitmask,
                                                                  int elem_count) {
  __mlvm_stream_collect_bitindex_f16(dst, src, bitmask, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_maskmove_bitindex(float* dst,
                                                                  float* src,
                                                                  void* bitmask,
                                                                  int elem_count) {
  __mlvm_stream_collect_bitindex_f32(dst, src, bitmask, elem_count);
}
#endif  // __BANG_ARCH__ >= 200
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_maskmove_bitindex(bfloat16_t* dst,
                                                                  bfloat16_t* src,
                                                                  bfloat16_t* bitmask,
                                                                  int elem_count) {
  __mlvm_stream_maskmove_bitindex_bf16(dst, src, bitmask, elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector max operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_max(half* dst,
                                                    half* src,
                                                    int elem_count) {
  __mlvm_stream_max_f16(dst, src, elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_max(float* dst,
                                                    float* src,
                                                    int elem_count) {
  __mlvm_stream_max_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 200
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_max(bfloat16_t* dst,
                                                    bfloat16_t* src,
                                                    int elem_count) {
  __mlvm_stream_max_bf16(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ void __bang_argmax(half* dst,
                                                       half* src,
                                                       int elem_count) {
  __mlvm_stream_argmax_f16(dst, src, elem_count);
}

static __mlu_func__ __mlu_builtin__ void __bang_argmax(float* dst,
                                                       float* src,
                                                       int elem_count) {
  __mlvm_stream_argmax_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 300
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_argmax(bfloat16_t* dst,
                                                       bfloat16_t* src,
                                                       int elem_count) {
  __mlvm_stream_argmax_bf16(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector min operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_min(half* dst,
                                                    half* src,
                                                    int elem_count) {
  __mlvm_stream_min_f16(dst, src, elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_min(float* dst,
                                                    float* src,
                                                    int elem_count) {
  __mlvm_stream_min_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 200
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_min(bfloat16_t* dst,
                                                    bfloat16_t* src,
                                                    int elem_count) {
  __mlvm_stream_min_bf16(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ void __bang_argmin(half* dst,
                                                       half* src,
                                                       int elem_count) {
  __mlvm_stream_argmin_f16(dst, src, elem_count);
}

static __mlu_func__ __mlu_builtin__ void __bang_argmin(float* dst,
                                                       float* src,
                                                       int elem_count) {
  __mlvm_stream_argmin_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 300
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_argmin(bfloat16_t* dst,
                                                       bfloat16_t* src,
                                                       int elem_count) {
  __mlvm_stream_argmin_bf16(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector not operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_not(half* dst,
                                                    half* src,
                                                    int elem_count) {
  __mlvm_stream_not_f16(dst, src, elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_not(float* dst,
                                                    float* src,
                                                    int elem_count) {
  __mlvm_stream_not_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 200
#if __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321 && \
    __BANG_ARCH__ != 303 && __BANG_ARCH__ != 306
static __mlu_func__ __mlu_builtin__ void __bang_not(int* dst,
                                                    int* src,
                                                    int elem_count) {
  __mlvm_stream_not_s32(dst, src, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_not(short* dst,
                                                    short* src,
                                                    int elem_count) {
  __mlvm_stream_not_s16(dst, src, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_not(char* dst,
                                                    char* src,
                                                    int elem_count) {
  __mlvm_stream_not_s8(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 306
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_not(bfloat16_t* dst,
                                                    bfloat16_t* src,
                                                    int elem_count) {
  __mlvm_stream_not_bf16(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

//-----------------------------------------------------------------------------
// Bang c/c++ math function: strem vector rand operation
// ----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_rand(short* dst,
                                                     int elem_count) {
#if __BANG_ARCH__ < 300
  __mlvm_stream_rand_s16(dst, elem_count);
#else
#define RAND_SEED_TOTAL 16
  uint32_t seed;
  uint32_t i, next;
  uint32_t result;
  uint32_t mult = 0x41c64e6d;
  uint32_t add = 12345;
  uint32_t shift_right = 16;
  uint32_t shift_left = 10;
  uint32_t and_first = 4095;
  uint32_t and_second = 1023;

  if (coreId == 0x80) {
    return;
  }

  if((elem_count % 64) != 0) {
    asm volatile("exit %[status];\n\t"
                 ::[status]"i"(TRAP_BANG_INVALID_SIZE_RESTRICTION));
    return;
  }

  __asm__ volatile("sync;\n\t"
                   "mv.gpr.sreg %[_time_stample], %%perf_time_stample_low;\n\t"
                   :[_time_stample]"+&r"(seed));
  // seed array generate
  __nram__ int seeds[RAND_SEED_TOTAL];
  next = seed;
  for(i = 0; i < RAND_SEED_TOTAL; i++) {
    next *= mult;
    next += add;
    result = (next / 65536) % 4096;

    next *= mult;
    next += add;
    result <<=10;
    result ^= (next / 65536) % 1024;

    next *= mult;
    next += add;
    result <<=10;
    result ^= (next / 65536) % 1024;

    seeds[i] = result;
  }

  // 64 bytes rand data generate onetime
  int times = elem_count * 2 / 64;
  for(int j = 0; j < times; j++) {
    void *dst_ptr = (void *)&dst[j * 32];
    __asm__ volatile(
        "tfuse.nram.u32 %[_seeds], 16, %[_seeds], .mul(%[_mult_const]),"
        " .add(%[_add_const]);\n\t"
        "tfuse.nram.u32 [%[_result]], 16, %[_seeds], .srl(%[_shift_right]),"
        " .and(%[_and_first]), .sll(%[_shift_left]);\n\t"
        "tfuse.nram.u32 %[_seeds], 16, %[_seeds], .mul(%[_mult_const]),"
        " .add(%[_add_const]);\n\t"
        "tfuse.nram.u32 [%[_result]], 16, %[_seeds], .srl(%[_shift_right]),"
        " .and(%[_and_second]), .xor([%[_result]]), .sll(%[_shift_left]);\n\t"
        "tfuse.nram.u32 %[_seeds], 16, %[_seeds], .mul(%[_mult_const]),"
        " .add(%[_add_const]);\n\t"
        "tfuse.nram.u32 [%[_result]], 16, %[_seeds], .srl(%[_shift_right]),"
        " .and(%[_and_second]), .xor([%[_result]]);\n\t"
        :: [_seeds] "m"(seeds), [_result] "r"(dst_ptr),
        [_mult_const] "r"(mult), [_add_const] "r"(add),
        [_shift_right] "r"(shift_right), [_and_first] "r"(and_first),
        [_shift_left] "r"(shift_left),  [_and_second] "r"(and_second));
  }
#endif
}
#endif  // __BANG_ARCH__ >= 200

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector count operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_count(unsigned int* dst,
                                                      half* src,
                                                      int elem_count) {
  __mlvm_stream_count_f16(dst, src, elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_count(unsigned int* dst,
                                                      float* src,
                                                      int elem_count) {
  __mlvm_stream_count_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 200
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_count(unsigned int* dst,
                                                      bfloat16_t* src,
                                                      int elem_count) {
  __mlvm_stream_count_bf16(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector count with bit index operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_count_bitindex(unsigned int* dst,
                                                               half* src,
                                                               int elem_count) {
  __mlvm_stream_count_bitindex_f16(dst, src, elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_count_bitindex(unsigned int* dst,
                                                               float* src,
                                                               int elem_count) {
  __mlvm_stream_count_bitindex_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 200
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_count_bitindex(unsigned int* dst,
                                                               bfloat16_t* src,
                                                               int elem_count) {
  __mlvm_stream_count_bitindex_bf16(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector square operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_square(half* dst,
                                                       half* src,
                                                       int elem_count) {
  __mlvm_stream_square_f16(dst, src, elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_square(float* dst,
                                                       float* src,
                                                       int elem_count) {
  __mlvm_stream_square_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 200
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_square(bfloat16_t* dst,
                                                       bfloat16_t* src,
                                                       int elem_count) {
  __mlvm_stream_square_bf16(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector find first one operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_findfirst1(unsigned int* dst,
                                                           half* src,
                                                           int elem_count) {
  __mlvm_stream_findfirst1_f16(dst, src, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_findfirst1(unsigned int* dst,
                                                           float* src,
                                                           int elem_count) {
  __mlvm_stream_findfirst1_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 200
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_findfirst1(unsigned int* dst,
                                                           bfloat16_t* src,
                                                           int elem_count) {
  __mlvm_stream_findfirst1_bf16(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector find last one operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_findlast1(unsigned int* dst,
                                                          half* src,
                                                          int elem_count) {
  __mlvm_stream_findlast1_f16(dst, src, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_findlast1(unsigned int* dst,
                                                          float* src,
                                                          int elem_count) {
  __mlvm_stream_findlast1_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 200
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_findlast1(unsigned int* dst,
                                                          bfloat16_t* src,
                                                          int elem_count) {
  __mlvm_stream_findlast1_bf16(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector reduce_sum operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_reduce_sum(half* dst,
                                                           half* src,
                                                           int elem_count) {
  __mlvm_stream_reduce_sum_f16(dst, src, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_reduce_sum(float* dst,
                                                           float* src,
                                                           int elem_count) {
  __mlvm_stream_reduce_sum_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

// -----------------------------------------------------------------------------
// Bang C/C math function: stream vector sum operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 392
static __mlu_func__ __mlu_builtin__ half __bang_sum(half* src,
                                                    int elem_count) {
  return __mlvm_stream_sum_f16(src, elem_count);
}
static __mlu_func__ __mlu_builtin__ bfloat16_t __bang_sum(bfloat16_t* src,
                                                          int elem_count) {
  bfloat16_t dst;
  dst.value = __mlvm_stream_sum_bf16(src, elem_count);
  return dst;
}
static __mlu_func__ __mlu_builtin__ float __bang_sum(float* src,
                                                     int elem_count) {
  return __mlvm_stream_sum_f32(src, elem_count);
}
#endif  // __BANG_ARCH__ >= 392

// --------------------------------------------------------------------------
// Bang C/C++ math function: stream relu/relun operation
// --------------------------------------------------------------------------
#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ void __bang_relu(half* dst,
                                                     half* src,
                                                     int elem_count) {
  __mlvm_stream_relu_f16(dst, src, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_relu(float* dst,
                                                     float* src,
                                                     int elem_count) {
  __mlvm_stream_relu_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 300
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_relu(bfloat16_t* dst,
                                                     bfloat16_t* src,
                                                     int elem_count) {
  __mlvm_stream_relu_bf16(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ void __bang_relun(half* dst,
                                                      half* src,
                                                      int elem_count,
                                                      half nvalue) {
  __mlvm_stream_relun_f16(dst, src, elem_count, nvalue);
}
static __mlu_func__ __mlu_builtin__ void __bang_relun(float* dst,
                                                      float* src,
                                                      int elem_count,
                                                      float nvalue) {
  __mlvm_stream_relun_f32(dst, src, elem_count, nvalue);
}
#endif  // __BANG_ARCH__ >= 300
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_relun(bfloat16_t* dst,
                                                      bfloat16_t* src,
                                                      int elem_count,
                                                      bfloat16_t nvalue) {
  __asm__ ("relun.nram.bf16 \t[%[dst]], [%[src]], %[size], %[nvalue];\n\t" \
           :                                                               \
           : [dst] "r"(dst), [src] "r"(src), [size] "r"(elem_count),       \
             [nvalue] "r"(nvalue));
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector write zero operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_write_zero(signed char* dst,
                                                           int elem_count) {
#if __BANG_ARCH__ < 300
  __mlvm_stream_write_zero_f16((half*)dst, elem_count >> 1);
#else
  __mlvm_stream_write_zero_b8((char*)dst, elem_count);
#endif
}
static __mlu_func__ __mlu_builtin__ void __bang_write_zero(unsigned char* dst,
                                                           int elem_count) {
#if __BANG_ARCH__ < 300
  __mlvm_stream_write_zero_f16((half*)dst, elem_count >> 1);
#else
  __mlvm_stream_write_zero_b8((char*)dst, elem_count);
#endif
}
static __mlu_func__ __mlu_builtin__ void __bang_write_zero(short* dst,
                                                           int elem_count) {
  __mlvm_stream_write_zero_f16((half*)dst, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_write_zero(unsigned short* dst,
                                                           int elem_count) {
  __mlvm_stream_write_zero_f16((half*)dst, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_write_zero(int* dst,
                                                           int elem_count) {
  __mlvm_stream_write_zero_f16((half*)dst, elem_count << 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_write_zero(unsigned int* dst,
                                                           int elem_count) {
  __mlvm_stream_write_zero_f16((half*)dst, elem_count << 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_write_zero(half* dst,
                                                           int elem_count) {
  __mlvm_stream_write_zero_f16(dst, elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_write_zero(float* dst,
                                                           int elem_count) {
  __mlvm_stream_write_zero_f32(dst, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector relu active operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_active_relu(half* dst,
                                                            half* src,
                                                            int elem_count) {
  __mlvm_stream_active_relu_f16(dst, src, elem_count);
}

#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_active_relu(float* dst,
                                                            float* src,
                                                            int elem_count) {
  __mlvm_stream_active_relu_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector pow2 active operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_active_pow2(half* dst,
                                                            half* src,
                                                            int elem_count) {
  __mlvm_stream_active_pow2_f16(dst, src, elem_count);
}

static __mlu_func__ __mlu_builtin__ void __bang_active_pow2(float* dst,
                                                            float* src,
                                                            int elem_count) {
  __mlvm_stream_active_pow2_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ void __bang_pow2(float* dst,
                                                     float* src,
                                                     int elem_count) {
  __mlvm_stream_pow2_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 300

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector gelu active operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_active_gelu(half* dst,
                                                            half* src,
                                                            int elem_count) {
  __mlvm_stream_active_gelu_f16(dst, src, elem_count);
}

#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_active_gelu(float* dst,
                                                            float* src,
                                                            int elem_count) {
  __mlvm_stream_active_gelu_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector gelu precision active operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_active_gelup(half* dst,
                                                             half* src,
                                                             int elem_count) {
  __mlvm_stream_active_gelup_f16(dst, src, elem_count);
}

#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_active_gelup(float* dst,
                                                             float* src,
                                                             int elem_count) {
  __mlvm_stream_active_gelup_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector tanh active operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_active_tanh(half* dst,
                                                            half* src,
                                                            int elem_count) {
  __mlvm_stream_active_tanh_f16(dst, src, elem_count);
}

#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_active_tanh(float* dst,
                                                            float* src,
                                                            int elem_count) {
  __mlvm_stream_active_tanh_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream abs active operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_active_abs(half* dst,
                                                           half* src,
                                                           int elem_count) {
  __mlvm_stream_active_abs_f16(dst, src, elem_count);
}

#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_active_abs(float* dst,
                                                           float* src,
                                                           int elem_count) {
  __mlvm_stream_active_abs_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector sigmoid active operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_active_sigmoid(half* dst,
                                                               half* src,
                                                               int elem_count) {
  __mlvm_stream_active_sigmoid_f16(dst, src, elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_active_sigmoid(float* dst,
                                                               float* src,
                                                               int elem_count) {
  __mlvm_stream_active_sigmoid_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

static __mlu_func__ __mlu_builtin__ void __bang_active_sigmoid_hp(half* dst,
                                                                  half* src,
                                                                  int elem_count) {
  __mlvm_stream_active_sigmoid_hp_f16(dst, src, elem_count);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_active_sigmoid_hp(float* dst,
                                                                  float* src,
                                                                  int elem_count) {
  __mlvm_stream_active_sigmoid_hp_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream taylor sine active operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_taylor3_sin(half* dst,
                                                            half* src,
                                                            half* tmp1,
                                                            half* tmp2,
                                                            int elem_count) {
  __mlvm_stream_taylor3_sin_f16(dst, src, tmp1, tmp2, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_taylor3_sin(float* dst,
                                                            float* src,
                                                            float* tmp1,
                                                            float* tmp2,
                                                            int elem_count) {
  __mlvm_stream_taylor3_sin_f32(dst, src, tmp1, tmp2, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_taylor4_sin(half* dst,
                                                            half* src,
                                                            half* tmp1,
                                                            half* tmp2,
                                                            int elem_count) {
  __mlvm_stream_taylor4_sin_f16(dst, src, tmp1, tmp2, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_taylor4_sin(float* dst,
                                                            float* src,
                                                            float* tmp1,
                                                            float* tmp2,
                                                            int elem_count) {
  __mlvm_stream_taylor4_sin_f32(dst, src, tmp1, tmp2, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_taylor3_cos(half* dst,
                                                            half* src,
                                                            half* tmp1,
                                                            half* tmp2,
                                                            int elem_count) {
  __mlvm_stream_taylor3_cos_f16(dst, src, tmp1, tmp2, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_taylor3_cos(float* dst,
                                                            float* src,
                                                            float* tmp1,
                                                            float* tmp2,
                                                            int elem_count) {
  __mlvm_stream_taylor3_cos_f32(dst, src, tmp1, tmp2, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_taylor4_cos(half* dst,
                                                            half* src,
                                                            half* tmp1,
                                                            half* tmp2,
                                                            int elem_count) {
  __mlvm_stream_taylor4_cos_f16(dst, src, tmp1, tmp2, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_taylor4_cos(float* dst,
                                                            float* src,
                                                            float* tmp1,
                                                            float* tmp2,
                                                            int elem_count) {
  __mlvm_stream_taylor4_cos_f32(dst, src, tmp1, tmp2, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_taylor3_sigmoid(half* dst,
                                                                half* src,
                                                                half* tmp1,
                                                                half* tmp2,
                                                                int elem_count) {
  __mlvm_stream_taylor3_sigmoid_f16(dst, src, tmp1, tmp2, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_taylor3_sigmoid(float* dst,
                                                                float* src,
                                                                float* tmp1,
                                                                float* tmp2,
                                                                int elem_count) {
  __mlvm_stream_taylor3_sigmoid_f32(dst, src, tmp1, tmp2, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_taylor4_sigmoid(half* dst,
                                                                half* src,
                                                                half* tmp1,
                                                                half* tmp2,
                                                                int elem_count) {
  __mlvm_stream_taylor4_sigmoid_f16(dst, src, tmp1, tmp2, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_taylor4_sigmoid(float* dst,
                                                                float* src,
                                                                float* tmp1,
                                                                float* tmp2,
                                                                int elem_count) {
  __mlvm_stream_taylor4_sigmoid_f32(dst, src, tmp1, tmp2, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_taylor3_softplus(half* dst,
                                                                 half* src,
                                                                 half* tmp1,
                                                                 half* tmp2,
                                                                 int elem_count) {
  __mlvm_stream_taylor3_softplus_f16(dst, src, tmp1, tmp2, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_taylor3_softplus(float* dst,
                                                                 float* src,
                                                                 float* tmp1,
                                                                 float* tmp2,
                                                                 int elem_count) {
  __mlvm_stream_taylor3_softplus_f32(dst, src, tmp1, tmp2, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_taylor4_softplus(half* dst,
                                                                 half* src,
                                                                 half* tmp1,
                                                                 half* tmp2,
                                                                 int elem_count) {
  __mlvm_stream_taylor4_softplus_f16(dst, src, tmp1, tmp2, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_taylor4_softplus(float* dst,
                                                                 float* src,
                                                                 float* tmp1,
                                                                 float* tmp2,
                                                                 int elem_count) {
  __mlvm_stream_taylor4_softplus_f32(dst, src, tmp1, tmp2, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_taylor3_tanh(half* dst,
                                                             half* src,
                                                             half* tmp1,
                                                             half* tmp2,
                                                             int elem_count) {
  __mlvm_stream_taylor3_tanh_f16(dst, src, tmp1, tmp2, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_taylor3_tanh(float* dst,
                                                             float* src,
                                                             float* tmp1,
                                                             float* tmp2,
                                                             int elem_count) {
  __mlvm_stream_taylor3_tanh_f32(dst, src, tmp1, tmp2, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_taylor4_tanh(half* dst,
                                                             half* src,
                                                             half* tmp1,
                                                             half* tmp2,
                                                             int elem_count) {
  __mlvm_stream_taylor4_tanh_f16(dst, src, tmp1, tmp2, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_taylor4_tanh(float* dst,
                                                             float* src,
                                                             float* tmp1,
                                                             float* tmp2,
                                                             int elem_count) {
  __mlvm_stream_taylor4_tanh_f32(dst, src, tmp1, tmp2, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector exp active operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_active_exp(half* dst,
                                                           half* src,
                                                           int elem_count) {
  __mlvm_stream_active_exp_f16(dst, src, elem_count);
}

#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_active_exp(float* dst,
                                                           float* src,
                                                           int elem_count) {
  __mlvm_stream_active_exp_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector high precision exp active operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_active_exphp(half* dst,
                                                             half* src,
                                                             int elem_count) {
  __mlvm_stream_active_exphp_f16(dst, src, elem_count);
}

#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_active_exphp(float* dst,
                                                             float* src,
                                                             int elem_count) {
  __mlvm_stream_active_exphp_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector exp less 0 active operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_active_exp_less_0(half* dst,
                                                                  half* src,
                                                                  int elem_count) {
  __mlvm_stream_active_explt0_f16(dst, src, elem_count);
}

#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_active_exp_less_0(float* dst,
                                                                  float* src,
                                                                  int elem_count) {
  __mlvm_stream_active_explt0_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector sqrt active operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_active_sqrt(half* dst,
                                                            half* src,
                                                            int elem_count) {
  __mlvm_stream_active_sqrt_f16(dst, src, elem_count);
}

#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_active_sqrt(float* dst,
                                                            float* src,
                                                            int elem_count) {
  __mlvm_stream_active_sqrt_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ void __bang_sqrt(float* dst,
                                                     float* src,
                                                     int elem_count) {
  __mlvm_stream_sqrt_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 300

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector high precision sqrt active operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_active_sqrthp(half* dst,
                                                              half* src,
                                                              int elem_count) {
  __mlvm_stream_active_sqrthp_f16(dst, src, elem_count);
}

#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_active_sqrthp(float* dst,
                                                              float* src,
                                                              int elem_count) {
  __mlvm_stream_active_sqrthp_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector sqrt and reciprocal active operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_active_rsqrt(half* dst,
                                                             half* src,
                                                             int elem_count) {
  __mlvm_stream_active_rsqrt_f16(dst, src, elem_count);
}

#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_active_rsqrt(float* dst,
                                                             float* src,
                                                             int elem_count) {
  __mlvm_stream_active_rsqrt_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ void __bang_rsqrt(float* dst,
                                                      float* src,
                                                      int elem_count) {
  __mlvm_stream_rsqrt_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 300

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector high precision sqrt and reciprocal
//                           active operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_active_rsqrthp(half* dst,
                                                               half* src,
                                                               int elem_count) {
  __mlvm_stream_active_rsqrthp_f16(dst, src, elem_count);
}

#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_active_rsqrthp(float* dst,
                                                               float* src,
                                                               int elem_count) {
  __mlvm_stream_active_rsqrthp_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector reciprocal active operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_active_recip(half* dst,
                                                             half* src,
                                                             int elem_count) {
  __mlvm_stream_active_recip_f16(dst, src, elem_count);
}

#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_active_recip(float* dst,
                                                             float* src,
                                                             int elem_count) {
  __mlvm_stream_active_recip_f32(dst, src,
                                 elem_count);
}
#endif  // __BANG_ARCH__ >= 200

#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ void __bang_recip(float* dst,
                                                      float* src,
                                                      int elem_count) {
  __mlvm_stream_recip_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 300

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector high precision reciprocal active operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_active_reciphp(half* dst,
                                                               half* src,
                                                               int elem_count) {
  __mlvm_stream_active_reciphp_f16(dst, src, elem_count);
}

#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_active_reciphp(float* dst,
                                                               float* src,
                                                               int elem_count) {
  __mlvm_stream_active_reciphp_f32(dst, src,
                                    elem_count);
}
#endif  // __BANG_ARCH__ >= 200

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector reciprocal greater 1 active operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_active_recip_greater_1(half* dst,
                                                                       half* src,
                                                                       int elem_count) {
  __mlvm_stream_active_recipgt1_f16(dst, src, elem_count);
}

#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_active_recip_greater_1(float* dst,
                                                                       float* src,
                                                                       int elem_count) {
  __mlvm_stream_active_recipgt1_f32(dst, src,
                                    elem_count);
}
#endif  // __BANG_ARCH__ >= 200

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector sine active operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_active_sin(half* dst,
                                                           half* src,
                                                           int elem_count) {
  __mlvm_stream_active_sin_f16(dst, src, elem_count);
}

#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_active_sin(float* dst,
                                                           float* src,
                                                           int elem_count) {
  __mlvm_stream_active_sin_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ void __bang_sin(float* dst,
                                                    float* src,
                                                    int elem_count) {
  __mlvm_stream_sin_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 300

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector cosine active operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_active_cos(half* dst,
                                                           half* src,
                                                           int elem_count) {
  __mlvm_stream_active_cos_f16(dst, src, elem_count);
}

#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_active_cos(float* dst,
                                                           float* src,
                                                           int elem_count) {
  __mlvm_stream_active_cos_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ void __bang_cos(float* dst,
                                                    float* src,
                                                    int elem_count) {
  __mlvm_stream_cos_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 300

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector log active operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_active_log(half* dst,
                                                           half* src,
                                                           int elem_count) {
  __mlvm_stream_active_log_f16(dst, src, elem_count);
}

#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_active_log(float* dst,
                                                           float* src,
                                                           int elem_count) {
  __mlvm_stream_active_log_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ void __bang_log(float* dst,
                                                    float* src,
                                                    int elem_count) {
  __mlvm_stream_log_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 300

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector high precision log active operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_active_loghp(half* dst,
                                                             half* src,
                                                             int elem_count) {
  __mlvm_stream_active_loghp_f16(dst, src, elem_count);
}

#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_active_loghp(float* dst,
                                                             float* src,
                                                             int elem_count) {
  __mlvm_stream_active_loghp_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector sign active operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_active_sign(half* dst,
                                                            half* src,
                                                            int elem_count) {
  __mlvm_stream_active_sign_f16(dst, src, elem_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_active_sign(float* dst,
                                                            float* src,
                                                            int elem_count) {
  __mlvm_stream_active_sign_f32(dst, src, elem_count);
}
#endif  // __BANG_ARCH__ >= 200

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector customized active operation
// -----------------------------------------------------------------------------
#define __bang_active_f16(dst, src, active_table, const_table,\
                          elem_count, every_acttab_elem_count, seg_num) \
  __mlvm_stream_active_f16(dst, src, active_table, const_table, \
                           elem_count, every_acttab_elem_count, seg_num)
#if __BANG_ARCH__ >= 200
#define __bang_active_f32(dst, src, active_table, const_table,\
                          elem_count, every_acttab_elem_count, seg_num) \
  __mlvm_stream_active_f32(dst, src, active_table, const_table, \
                           elem_count, every_acttab_elem_count, seg_num)
#endif  // __BANG_ARCH__ >= 200

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector look-up table operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ == 210 || __BANG_ARCH__ == 220 || __BANG_ARCH__ > 306
#define __bang_lut_s16(dst, src, table, elem_count, table_length) \
    __mlvm_stream_lut_s16(dst, src, table, elem_count, table_length)
#define __bang_lut_s32(dst, src, table, elem_count, table_length) \
    __mlvm_stream_lut_s32(dst, src, table, elem_count, table_length)
#endif  // __BANG_ARCH__ == 210 || __BANG_ARCH__ == 220 || __BANG_ARCH__ >= 306

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream vector maximum operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_maximum(half* dst,
                                                        half* src,
                                                        int distance,
                                                        int size) {
  __mlvm_stream_maximum_f16(dst, src, distance, size);
}

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream matrix pad operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_pad(half* dst,
                                                    half* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_height,
                                                    int pad_width) {
  __mlvm_stream_pad_b16(dst, src, channel, height, width, pad_height,
                        pad_height, pad_width, pad_width);
}
static __mlu_func__ __mlu_builtin__ void __bang_pad(half* dst,
                                                    half* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_top,
                                                    int pad_bottom,
                                                    int pad_left,
                                                    int pad_right) {
  __mlvm_stream_pad_b16(dst, src, channel, height, width, pad_top,
                        pad_bottom, pad_left, pad_right);
}
static __mlu_func__ __mlu_builtin__ void __bang_pad(short* dst,
                                                    short* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_height,
                                                    int pad_width) {
  __mlvm_stream_pad_b16(dst, src, channel, height, width, pad_height,
                        pad_height, pad_width, pad_width);
}
static __mlu_func__ __mlu_builtin__ void __bang_pad(short* dst,
                                                    short* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_top,
                                                    int pad_bottom,
                                                    int pad_left,
                                                    int pad_right) {
  __mlvm_stream_pad_b16(dst, src, channel, height, width, pad_top,
                        pad_bottom, pad_left, pad_right);
}
static __mlu_func__ __mlu_builtin__ void __bang_pad(unsigned short* dst,
                                                    unsigned short* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_height,
                                                    int pad_width) {
  __mlvm_stream_pad_b16(dst, src, channel, height, width, pad_height,
                        pad_height, pad_width, pad_width);
}
static __mlu_func__ __mlu_builtin__ void __bang_pad(unsigned short* dst,
                                                    unsigned short* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_top,
                                                    int pad_bottom,
                                                    int pad_left,
                                                    int pad_right) {
  __mlvm_stream_pad_b16(dst, src, channel, height, width, pad_top,
                        pad_bottom, pad_left, pad_right);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_pad(int8* dst,
                                                    int8* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_height,
                                                    int pad_width) {
  __mlvm_stream_pad_b8(dst, src, channel, height, width, pad_height,
                       pad_height, pad_width, pad_width);
}
static __mlu_func__ __mlu_builtin__ void __bang_pad(int8* dst,
                                                    int8* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_top,
                                                    int pad_bottom,
                                                    int pad_left,
                                                    int pad_right) {
  __mlvm_stream_pad_b8(dst, src, channel, height, width, pad_top,
                       pad_bottom, pad_left, pad_right);
}
static __mlu_func__ __mlu_builtin__ void __bang_pad(char* dst,
                                                    char* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_height,
                                                    int pad_width) {
  __mlvm_stream_pad_b8(dst, src, channel, height, width, pad_height,
                       pad_height, pad_width, pad_width);
}
static __mlu_func__ __mlu_builtin__ void __bang_pad(char* dst,
                                                    char* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_top,
                                                    int pad_bottom,
                                                    int pad_left,
                                                    int pad_right) {
  __mlvm_stream_pad_b8(dst, src, channel, height, width, pad_top,
                       pad_bottom, pad_left, pad_right);
}
static __mlu_func__ __mlu_builtin__ void __bang_pad(unsigned char* dst,
                                                    unsigned char* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_height,
                                                    int pad_width) {
  __mlvm_stream_pad_b8(dst, src, channel, height, width, pad_height,
                       pad_height, pad_width, pad_width);
}
static __mlu_func__ __mlu_builtin__ void __bang_pad(unsigned char* dst,
                                                    unsigned char* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_top,
                                                    int pad_bottom,
                                                    int pad_left,
                                                    int pad_right) {
  __mlvm_stream_pad_b8(dst, src, channel, height, width, pad_top,
                       pad_bottom, pad_left, pad_right);
}
static __mlu_func__ __mlu_builtin__ void __bang_pad(float* dst,
                                                    float* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_height,
                                                    int pad_width) {
  __mlvm_stream_pad_b32(dst, src, channel, height, width, pad_height,
                        pad_height, pad_width, pad_width);
}
static __mlu_func__ __mlu_builtin__ void __bang_pad(float* dst,
                                                    float* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_top,
                                                    int pad_bottom,
                                                    int pad_left,
                                                    int pad_right) {
  __mlvm_stream_pad_b32(dst, src, channel, height, width, pad_top,
                        pad_bottom, pad_left, pad_right);
}
static __mlu_func__ __mlu_builtin__ void __bang_pad(int* dst,
                                                    int* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_height,
                                                    int pad_width) {
  __mlvm_stream_pad_b32(dst, src, channel, height, width, pad_height,
                        pad_height, pad_width, pad_width);
}
static __mlu_func__ __mlu_builtin__ void __bang_pad(int* dst,
                                                    int* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_top,
                                                    int pad_bottom,
                                                    int pad_left,
                                                    int pad_right) {
  __mlvm_stream_pad_b32(dst, src, channel, height, width, pad_top,
                        pad_bottom, pad_left, pad_right);
}
static __mlu_func__ __mlu_builtin__ void __bang_pad(unsigned int* dst,
                                                    unsigned int* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_height,
                                                    int pad_width) {
  __mlvm_stream_pad_b32(dst, src, channel, height, width, pad_height,
                        pad_height, pad_width, pad_width);
}
static __mlu_func__ __mlu_builtin__ void __bang_pad(unsigned int* dst,
                                                    unsigned int* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_top,
                                                    int pad_bottom,
                                                    int pad_left,
                                                    int pad_right) {
  __mlvm_stream_pad_b32(dst, src, channel, height, width, pad_top,
                        pad_bottom, pad_left, pad_right);
}
#endif  // __BANG_ARCH__ >= 200

#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_pad(half* dst,
                                                    half* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_height,
                                                    int pad_width,
                                                    half pad_value) {
  __mlvm_stream_pad_b16_f16(dst, src, channel, height, width, pad_height,
                            pad_height, pad_width, pad_width, pad_value);
}
static __mlu_func__ __mlu_builtin__ void __bang_pad(half* dst,
                                                    half* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_top,
                                                    int pad_bottom,
                                                    int pad_left,
                                                    int pad_right,
                                                    half pad_value) {
  __mlvm_stream_pad_b16_f16(dst, src, channel, height, width, pad_top,
                            pad_bottom, pad_left, pad_right, pad_value);
}
static __mlu_func__ __mlu_builtin__ void __bang_pad(short* dst,
                                                    short* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_height,
                                                    int pad_width,
                                                    short pad_value) {
  __mlvm_stream_pad_b16_s16(dst, src, channel, height, width, pad_height,
                            pad_height, pad_width, pad_width, pad_value);
}
static __mlu_func__ __mlu_builtin__ void __bang_pad(short* dst,
                                                    short* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_top,
                                                    int pad_bottom,
                                                    int pad_left,
                                                    int pad_right,
                                                    short pad_value) {
  __mlvm_stream_pad_b16_s16(dst, src, channel, height, width, pad_top,
                            pad_bottom, pad_left, pad_right, pad_value);
}
static __mlu_func__ __mlu_builtin__ void __bang_pad(char* dst,
                                                    char* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_height,
                                                    int pad_width,
                                                    char pad_value) {
  __mlvm_stream_pad_b8_s8(dst, src, channel, height, width, pad_height,
                          pad_height, pad_width, pad_width, pad_value);
}
static __mlu_func__ __mlu_builtin__ void __bang_pad(char* dst,
                                                    char* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_top,
                                                    int pad_bottom,
                                                    int pad_left,
                                                    int pad_right,
                                                    char pad_value) {
  __mlvm_stream_pad_b8_s8(dst, src, channel, height, width, pad_top,
                          pad_bottom, pad_left, pad_right, pad_value);
}
static __mlu_func__ __mlu_builtin__ void __bang_pad(float* dst,
                                                    float* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_height,
                                                    int pad_width,
                                                    float pad_value) {
  __mlvm_stream_pad_b32_f32(dst, src, channel, height, width, pad_height,
                            pad_height, pad_width, pad_width, pad_value);
}
static __mlu_func__ __mlu_builtin__ void __bang_pad(float* dst,
                                                    float* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_top,
                                                    int pad_bottom,
                                                    int pad_left,
                                                    int pad_right,
                                                    float pad_value) {
  __mlvm_stream_pad_b32_f32(dst, src, channel, height, width, pad_top,
                            pad_bottom, pad_left, pad_right, pad_value);
}
static __mlu_func__ __mlu_builtin__ void __bang_pad(int* dst,
                                                    int* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_height,
                                                    int pad_width,
                                                    int pad_value) {
  __mlvm_stream_pad_b32_fix32(dst, src, channel, height, width, pad_height,
                              pad_height, pad_width, pad_width, pad_value);
}
static __mlu_func__ __mlu_builtin__ void __bang_pad(int* dst,
                                                    int* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_top,
                                                    int pad_bottom,
                                                    int pad_left,
                                                    int pad_right,
                                                    int pad_value) {
  __mlvm_stream_pad_b32_fix32(dst, src, channel, height, width, pad_top,
                              pad_bottom, pad_left, pad_right, pad_value);
}
static __mlu_func__ __mlu_builtin__ void __bang_pad(bfloat16_t* dst,
                                                    bfloat16_t* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_height,
                                                    int pad_width,
                                                    bfloat16_t pad_value) {
  __asm__ volatile("pad.nram.bf16 \t[%[dst]], [%[src]], %[c], %[h], %[w], "
                   "%[ph], %[pw], .padvalue(%[pv]);\n\t "
                    ::[dst] "r"(dst), [src] "r"(src), [c] "r"(channel),
                    [h] "r"(height), [w] "r"(width), [ph] "r"(pad_height),
                    [pw] "r"(pad_width), [pv] "r"(pad_value));
}
static __mlu_func__ __mlu_builtin__ void __bang_pad(bfloat16_t* dst,
                                                    bfloat16_t* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_top,
                                                    int pad_bottom,
                                                    int pad_left,
                                                    int pad_right,
                                                    bfloat16_t pad_value) {
  __asm__ volatile("pad.nram.bf16 \t[%[dst]], [%[src]], %[c], %[h], %[w], "
                   "%[pt], %[pb], %[pl], %[pr], .padvalue(%[pv]);\n\t "
                    ::[dst] "r"(dst), [src] "r"(src), [c] "r"(channel),
                    [h] "r"(height), [w] "r"(width), [pt] "r"(pad_top), [pb] "r"(pad_bottom),
                    [pl] "r"(pad_left), [pr] "r"(pad_right), [pv] "r"(pad_value));
}

#endif // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream matrix transpose operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_transpose(half* dst,
                                                          half* src,
                                                          int height,
                                                          int width) {
  __mlvm_stream_trans_b16(dst, src, height, width);
}
static __mlu_func__ __mlu_builtin__ void __bang_transpose(short* dst,
                                                          short* src,
                                                          int height,
                                                          int width) {
  __mlvm_stream_trans_b16(dst, src, height, width);
}
static __mlu_func__ __mlu_builtin__ void __bang_transpose(unsigned short* dst,
                                                          unsigned short* src,
                                                          int height,
                                                          int width) {
  __mlvm_stream_trans_b16(dst, src, height, width);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_transpose(int8* dst,
                                                          int8* src,
                                                          int height,
                                                          int width) {
  __mlvm_stream_trans_b8(dst, src, height, width);
}
static __mlu_func__ __mlu_builtin__ void __bang_transpose(char* dst,
                                                          char* src,
                                                          int height,
                                                          int width) {
  __mlvm_stream_trans_b8(dst, src, height, width);
}
static __mlu_func__ __mlu_builtin__ void __bang_transpose(unsigned char* dst,
                                                          unsigned char* src,
                                                          int height,
                                                          int width) {
  __mlvm_stream_trans_b8(dst, src, height, width);
}
static __mlu_func__ __mlu_builtin__ void __bang_transpose(float* dst,
                                                          float* src,
                                                          int height,
                                                          int width) {
  __mlvm_stream_trans_b32(dst, src, height, width);
}
static __mlu_func__ __mlu_builtin__ void __bang_transpose(int* dst,
                                                          int* src,
                                                          int height,
                                                          int width) {
  __mlvm_stream_trans_b32(dst, src, height, width);
}
static __mlu_func__ __mlu_builtin__ void __bang_transpose(unsigned int* dst,
                                                          unsigned int* src,
                                                          int height,
                                                          int width) {
  __mlvm_stream_trans_b32(dst, src, height, width);
}
#endif  // __BANG_ARCH__ >= 200

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream matrix rotate operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_rotate90(int8* dst,
                                                         int8* src,
                                                         int height,
                                                         int width) {
  __mlvm_stream_rotate1pi_b8(dst, src, height, width);
}
static __mlu_func__ __mlu_builtin__ void __bang_rotate90(char* dst,
                                                         char* src,
                                                         int height,
                                                         int width) {
  __mlvm_stream_rotate1pi_b8(dst, src, height, width);
}
static __mlu_func__ __mlu_builtin__ void __bang_rotate90(unsigned char* dst,
                                                         unsigned char* src,
                                                         int height,
                                                         int width) {
  __mlvm_stream_rotate1pi_b8(dst, src, height, width);
}
static __mlu_func__ __mlu_builtin__ void __bang_rotate90(half* dst,
                                                         half* src,
                                                         int height,
                                                         int width) {
  __mlvm_stream_rotate1pi_b16(dst, src, height, width);
}
static __mlu_func__ __mlu_builtin__ void __bang_rotate90(short* dst,
                                                         short* src,
                                                         int height,
                                                         int width) {
  __mlvm_stream_rotate1pi_b16(dst, src, height, width);
}
static __mlu_func__ __mlu_builtin__ void __bang_rotate90(unsigned short* dst,
                                                         unsigned short* src,
                                                         int height,
                                                         int width) {
  __mlvm_stream_rotate1pi_b16(dst, src, height, width);
}
static __mlu_func__ __mlu_builtin__ void __bang_rotate90(float* dst,
                                                         float* src,
                                                         int height,
                                                         int width) {
  __mlvm_stream_rotate1pi_b32(dst, src, height, width);
}
static __mlu_func__ __mlu_builtin__ void __bang_rotate90(int* dst,
                                                         int* src,
                                                         int height,
                                                         int width) {
  __mlvm_stream_rotate1pi_b32(dst, src, height, width);
}
static __mlu_func__ __mlu_builtin__ void __bang_rotate90(unsigned int* dst,
                                                         unsigned int* src,
                                                         int height,
                                                         int width) {
  __mlvm_stream_rotate1pi_b32(dst, src, height, width);
}
#endif  // __BANG_ARCH__ >= 200

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream select wit bit index operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_rotate180(int8* dst,
                                                          int8* src,
                                                          int height,
                                                          int width) {
  __mlvm_stream_rotate2pi_b8(dst, src, height, width);
}
static __mlu_func__ __mlu_builtin__ void __bang_rotate180(char* dst,
                                                          char* src,
                                                          int height,
                                                          int width) {
  __mlvm_stream_rotate2pi_b8(dst, src, height, width);
}
static __mlu_func__ __mlu_builtin__ void __bang_rotate180(unsigned char* dst,
                                                          unsigned char* src,
                                                          int height,
                                                          int width) {
  __mlvm_stream_rotate2pi_b8(dst, src, height, width);
}
static __mlu_func__ __mlu_builtin__ void __bang_rotate180(half* dst,
                                                          half* src,
                                                          int height,
                                                          int width) {
  __mlvm_stream_rotate2pi_b16(dst, src, height, width);
}
static __mlu_func__ __mlu_builtin__ void __bang_rotate180(short* dst,
                                                          short* src,
                                                          int height,
                                                          int width) {
  __mlvm_stream_rotate2pi_b16(dst, src, height, width);
}
static __mlu_func__ __mlu_builtin__ void __bang_rotate180(unsigned short* dst,
                                                          unsigned short* src,
                                                          int height,
                                                          int width) {
  __mlvm_stream_rotate2pi_b16(dst, src, height, width);
}
static __mlu_func__ __mlu_builtin__ void __bang_rotate180(float* dst,
                                                          float* src,
                                                          int height,
                                                          int width) {
  __mlvm_stream_rotate2pi_b32(dst, src, height, width);
}
static __mlu_func__ __mlu_builtin__ void __bang_rotate180(int* dst,
                                                          int* src,
                                                          int height,
                                                          int width) {
  __mlvm_stream_rotate2pi_b32(dst, src, height, width);
}
static __mlu_func__ __mlu_builtin__ void __bang_rotate180(unsigned int* dst,
                                                          unsigned int* src,
                                                          int height,
                                                          int width) {
  __mlvm_stream_rotate2pi_b32(dst, src, height, width);
}
#endif  // __BANG_ARCH__ >= 200

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream select wit bit index operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_rotate270(int8* dst,
                                                          int8* src,
                                                          int height,
                                                          int width) {
  __mlvm_stream_rotate3pi_b8(dst, src, height, width);
}
static __mlu_func__ __mlu_builtin__ void __bang_rotate270(char* dst,
                                                          char* src,
                                                          int height,
                                                          int width) {
  __mlvm_stream_rotate3pi_b8(dst, src, height, width);
}
static __mlu_func__ __mlu_builtin__ void __bang_rotate270(unsigned char* dst,
                                                          unsigned char* src,
                                                          int height,
                                                          int width) {
  __mlvm_stream_rotate3pi_b8(dst, src, height, width);
}
static __mlu_func__ __mlu_builtin__ void __bang_rotate270(half* dst,
                                                          half* src,
                                                          int height,
                                                          int width) {
  __mlvm_stream_rotate3pi_b16(dst, src, height, width);
}
static __mlu_func__ __mlu_builtin__ void __bang_rotate270(short* dst,
                                                          short* src,
                                                          int height,
                                                          int width) {
  __mlvm_stream_rotate3pi_b16(dst, src, height, width);
}
static __mlu_func__ __mlu_builtin__ void __bang_rotate270(unsigned short* dst,
                                                          unsigned short* src,
                                                          int height,
                                                          int width) {
  __mlvm_stream_rotate3pi_b16(dst, src, height, width);
}
static __mlu_func__ __mlu_builtin__ void __bang_rotate270(float* dst,
                                                          float* src,
                                                          int height,
                                                          int width) {
  __mlvm_stream_rotate3pi_b32(dst, src, height, width);
}
static __mlu_func__ __mlu_builtin__ void __bang_rotate270(int* dst,
                                                          int* src,
                                                          int height,
                                                          int width) {
  __mlvm_stream_rotate3pi_b32(dst, src, height, width);
}
static __mlu_func__ __mlu_builtin__ void __bang_rotate270(unsigned int* dst,
                                                          unsigned int* src,
                                                          int height,
                                                          int width) {
  __mlvm_stream_rotate3pi_b32(dst, src, height, width);
}
#endif  // __BANG_ARCH__ >= 200

// -----------------------------------------------------------------------------
// Bang C/C++ math function: tiling2d operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200

#define __bang_tiling_2d_b8(dst, src, n2, s2, n1, s1, n7, s7, n6, s6)   \
  __mlvm_stream_tiling_2d_b8(dst, src, n2, s2, n1, s1, n7, s7, n6, s6)

#define __bang_tiling_2d_b16(dst, src, n2, s2, n1, s1, n7, s7, n6, s6)  \
  __mlvm_stream_tiling_2d_b16(dst, src, n2, s2, n1, s1, n7, s7, n6, s6)

#define __bang_tiling_2d_b32(dst, src, n2, s2, n1, s1, n7, s7, n6, s6)  \
  __mlvm_stream_tiling_2d_b32(dst, src, n2, s2, n1, s1, n7, s7, n6, s6)

#define __bang_tiling_2d_b64(dst, src, n2, s2, n1, s1, n7, s7, n6, s6)  \
  __mlvm_stream_tiling_2d_b64(dst, src, n2, s2, n1, s1, n7, s7, n6, s6)

#define __bang_tiling_2d_b128(dst, src, n2, s2, n1, s1, n7, s7, n6, s6)  \
  __mlvm_stream_tiling_2d_b128(dst, src, n2, s2, n1, s1, n7, s7, n6, s6)

#define __bang_tiling_2d_b256(dst, src, n2, s2, n1, s1, n7, s7, n6, s6)  \
  __mlvm_stream_tiling_2d_b256(dst, src, n2, s2, n1, s1, n7, s7, n6, s6)
#endif  // __BANG_ARCH__ >= 200

// -----------------------------------------------------------------------------
// Bang C/C++ math function: trans tiling operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200
#define __bang_trans_tiling_b8(dst, src, n5, s5, n4, s4, n3, s3,  \
                               n2, s2, n1, s1,                    \
                               n10, s10, n9, s9, n8, s8,          \
                               n7, s7, n6, s6)                    \
  __mlvm_stream_trans_tiling_b8(dst, src, n5, s5, n4, s4, n3, s3, \
                                n2, s2, n1, s1,                   \
                                n10, s10, n9, s9, n8, s8,         \
                                n7, s7, n6, s6)

#define __bang_trans_tiling_b16(dst, src, n5, s5, n4, s4, n3, s3,  \
                                n2, s2, n1, s1,                    \
                                n10, s10, n9, s9, n8, s8,          \
                                n7, s7, n6, s6)                    \
  __mlvm_stream_trans_tiling_b16(dst, src, n5, s5, n4, s4, n3, s3, \
                                 n2, s2, n1, s1,                   \
                                 n10, s10, n9, s9, n8, s8,         \
                                 n7, s7, n6, s6)

#define __bang_trans_tiling_b32(dst, src, n5, s5, n4, s4, n3, s3,  \
                                n2, s2, n1, s1,                    \
                                n10, s10, n9, s9, n8, s8,          \
                                n7, s7, n6, s6)                    \
  __mlvm_stream_trans_tiling_b32(dst, src, n5, s5, n4, s4, n3, s3, \
                                 n2, s2, n1, s1,                   \
                                 n10, s10, n9, s9, n8, s8,         \
                                 n7, s7, n6, s6)

#define __bang_trans_tiling_b64(dst, src, n5, s5, n4, s4, n3, s3,  \
                                n2, s2, n1, s1,                    \
                                n10, s10, n9, s9, n8, s8,          \
                                n7, s7, n6, s6)                    \
  __mlvm_stream_trans_tiling_b64(dst, src, n5, s5, n4, s4, n3, s3, \
                                 n2, s2, n1, s1,                   \
                                 n10, s10, n9, s9, n8, s8,         \
                                 n7, s7, n6, s6)

#define __bang_trans_tiling_b128(dst, src, n5, s5, n4, s4, n3, s3,  \
                                 n2, s2, n1, s1,                    \
                                 n10, s10, n9, s9, n8, s8,          \
                                 n7, s7, n6, s6)                    \
  __mlvm_stream_trans_tiling_b128(dst, src, n5, s5, n4, s4, n3, s3, \
                                  n2, s2, n1, s1,                   \
                                  n10, s10, n9, s9, n8, s8,         \
                                  n7, s7, n6, s6)

#define __bang_trans_tiling_b256(dst, src, n5, s5, n4, s4, n3, s3,  \
                                 n2, s2, n1, s1,                    \
                                 n10, s10, n9, s9, n8, s8,          \
                                 n7, s7, n6, s6)                    \
  __mlvm_stream_trans_tiling_b256(dst, src, n5, s5, n4, s4, n3, s3, \
                                  n2, s2, n1, s1,                   \
                                  n10, s10, n9, s9, n8, s8,         \
                                  n7, s7, n6, s6)
#endif  // __BANG_ARCH__ >= 200

// -----------------------------------------------------------------------------
// Bang C/C++ math function: tiling3d operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200
#define __bang_tiling_3d_b1024(dst, src,                  \
                               n5, s5, n4, s4, n3, s3,    \
                               n10, s10, n9, s9, n8, s8,  \
                               op)                        \
  __mlvm_stream_tiling_3d_b1024(dst, src,                 \
                                n5, s5, n4, s4, n3, s3,   \
                                n10, s10, n9, s9, n8, s8, \
                                op)
#endif  // __BANG_ARCH__ >= 200

// -----------------------------------------------------------------------------
// Bang C/C++ math function: mirror the input matrix along w axis
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_mirror(int8* dst,
                                                       int8* src,
                                                       int height,
                                                       int width) {
  __mlvm_stream_mirror_b8(dst, src, height, width);
}
static __mlu_func__ __mlu_builtin__ void __bang_mirror(char* dst,
                                                       char* src,
                                                       int height,
                                                       int width) {
  __mlvm_stream_mirror_b8(dst, src, height, width);
}
static __mlu_func__ __mlu_builtin__ void __bang_mirror(unsigned char* dst,
                                                       unsigned char* src,
                                                       int height,
                                                       int width) {
  __mlvm_stream_mirror_b8(dst, src, height, width);
}
static __mlu_func__ __mlu_builtin__ void __bang_mirror(unsigned short* dst,
                                                       unsigned short* src,
                                                       int height,
                                                       int width) {
  __mlvm_stream_mirror_b16(dst, src, height, width);
}
static __mlu_func__ __mlu_builtin__ void __bang_mirror(short* dst,
                                                       short* src,
                                                       int height,
                                                       int width) {
  __mlvm_stream_mirror_b16(dst, src, height, width);
}
static __mlu_func__ __mlu_builtin__ void __bang_mirror(half* dst,
                                                       half* src,
                                                       int height,
                                                       int width) {
  __mlvm_stream_mirror_b16(dst, src, height, width);
}
static __mlu_func__ __mlu_builtin__ void __bang_mirror(unsigned int* dst,
                                                       unsigned int* src,
                                                       int height,
                                                       int width) {
  __mlvm_stream_mirror_b32(dst, src, height, width);
}

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream reshape operation
// -----------------------------------------------------------------------------
// filter_reshape: 16bit
static __mlu_func__ __mlu_builtin__ void __bang_reshape_filter(half* dst,
                                                               half* src,
                                                               int n,
                                                               int h,
                                                               int w,
                                                               int c) {
  __mlvm_stream_reshape_filter_b16(dst, src, n, h, w, c);
}
static __mlu_func__ __mlu_builtin__ void __bang_reshape_filter(short* dst,
                                                               short* src,
                                                               int n,
                                                               int h,
                                                               int w,
                                                               int c) {
  __mlvm_stream_reshape_filter_b16(dst, src, n, h, w, c);
}
static __mlu_func__ __mlu_builtin__ void __bang_reshape_filter(unsigned short* dst,
                                                               unsigned short* src,
                                                               int n,
                                                               int h,
                                                               int w,
                                                               int c) {
  __mlvm_stream_reshape_filter_b16(dst, src, n, h, w, c);
}
// filter_reshape: 8bit
static __mlu_func__ __mlu_builtin__ void __bang_reshape_filter(int8* dst,
                                                               int8* src,
                                                               int n,
                                                               int h,
                                                               int w,
                                                               int c) {
  __mlvm_stream_reshape_filter_b8(dst, src, n, h, w, c);
}
static __mlu_func__ __mlu_builtin__ void __bang_reshape_filter(char* dst,
                                                               char* src,
                                                               int n,
                                                               int h,
                                                               int w,
                                                               int c) {
  __mlvm_stream_reshape_filter_b8(dst, src, n, h, w, c);
}
static __mlu_func__ __mlu_builtin__ void __bang_reshape_filter(unsigned char* dst,
                                                               unsigned char* src,
                                                               int n,
                                                               int h,
                                                               int w,
                                                               int c) {
  __mlvm_stream_reshape_filter_b8(dst, src, n, h, w, c);
}
// filter_reshape: 32bit
static __mlu_func__ __mlu_builtin__ void __bang_reshape_filter(float* dst,
                                                               float* src,
                                                               int n,
                                                               int h,
                                                               int w,
                                                               int c) {
  __mlvm_stream_reshape_filter_b32(dst, src, n, h, w, c);
}
static __mlu_func__ __mlu_builtin__ void __bang_reshape_filter(int* dst,
                                                               int* src,
                                                               int n,
                                                               int h,
                                                               int w,
                                                               int c) {
  __mlvm_stream_reshape_filter_b32(dst, src, n, h, w, c);
}
static __mlu_func__ __mlu_builtin__ void __bang_reshape_filter(unsigned int* dst,
                                                               unsigned int* src,
                                                               int n,
                                                               int h,
                                                               int w,
                                                               int c) {
  __mlvm_stream_reshape_filter_b32(dst, src, n, h, w, c);
}

// nhwc2nchw: 16bit
static __mlu_func__ __mlu_builtin__ void __bang_reshape_nhwc2nchw(half* dst,
                                                                  half* src,
                                                                  int n,
                                                                  int h,
                                                                  int w,
                                                                  int c) {
  __mlvm_stream_reshape_nhwc2nchw_b16(dst, src, n, h, w, c);
}
static __mlu_func__ __mlu_builtin__ void __bang_reshape_nhwc2nchw(short* dst,
                                                                  short* src,
                                                                  int n,
                                                                  int h,
                                                                  int w,
                                                                  int c) {
  __mlvm_stream_reshape_nhwc2nchw_b16(dst, src, n, h, w, c);
}
static __mlu_func__ __mlu_builtin__ void __bang_reshape_nhwc2nchw(unsigned short* dst,
                                                                  unsigned short* src,
                                                                  int n,
                                                                  int h,
                                                                  int w,
                                                                  int c) {
  __mlvm_stream_reshape_nhwc2nchw_b16(dst, src, n, h, w, c);
}
// nhwc2nchw: 8bit
static __mlu_func__ __mlu_builtin__ void __bang_reshape_nhwc2nchw(int8* dst,
                                                                  int8* src,
                                                                  int n,
                                                                  int h,
                                                                  int w,
                                                                  int c) {
  __mlvm_stream_reshape_nhwc2nchw_b8(dst, src, n, h, w, c);
}
static __mlu_func__ __mlu_builtin__ void __bang_reshape_nhwc2nchw(char* dst,
                                                                  char* src,
                                                                  int n,
                                                                  int h,
                                                                  int w,
                                                                  int c) {
  __mlvm_stream_reshape_nhwc2nchw_b8(dst, src, n, h, w, c);
}
static __mlu_func__ __mlu_builtin__ void __bang_reshape_nhwc2nchw(unsigned char* dst,
                                                                  unsigned char* src,
                                                                  int n,
                                                                  int h,
                                                                  int w,
                                                                  int c) {
  __mlvm_stream_reshape_nhwc2nchw_b8(dst, src, n, h, w, c);
}
// nhwc2nchw: 32bit
static __mlu_func__ __mlu_builtin__ void __bang_reshape_nhwc2nchw(float* dst,
                                                                  float* src,
                                                                  int n,
                                                                  int h,
                                                                  int w,
                                                                  int c) {
  __mlvm_stream_reshape_nhwc2nchw_b32(dst, src, n, h, w, c);
}
static __mlu_func__ __mlu_builtin__ void __bang_reshape_nhwc2nchw(int* dst,
                                                                  int* src,
                                                                  int n,
                                                                  int h,
                                                                  int w,
                                                                  int c) {
  __mlvm_stream_reshape_nhwc2nchw_b32(dst, src, n, h, w, c);
}
static __mlu_func__ __mlu_builtin__ void __bang_reshape_nhwc2nchw(unsigned int* dst,
                                                                  unsigned int* src,
                                                                  int n,
                                                                  int h,
                                                                  int w,
                                                                  int c) {
  __mlvm_stream_reshape_nhwc2nchw_b32(dst, src, n, h, w, c);
}

// nchw2nhwc: 16bit
static __mlu_func__ __mlu_builtin__ void __bang_reshape_nchw2nhwc(half* dst,
                                                                  half* src,
                                                                  int n,
                                                                  int h,
                                                                  int w,
                                                                  int c) {
  __mlvm_stream_reshape_nchw2nhwc_b16(dst, src, n, h, w, c);
}
static __mlu_func__ __mlu_builtin__ void __bang_reshape_nchw2nhwc(short* dst,
                                                                  short* src,
                                                                  int n,
                                                                  int h,
                                                                  int w,
                                                                  int c) {
  __mlvm_stream_reshape_nchw2nhwc_b16(dst, src, n, h, w, c);
}
static __mlu_func__ __mlu_builtin__ void __bang_reshape_nchw2nhwc(unsigned short* dst,
                                                                  unsigned short* src,
                                                                  int n,
                                                                  int h,
                                                                  int w,
                                                                  int c) {
  __mlvm_stream_reshape_nchw2nhwc_b16(dst, src, n, h, w, c);
}
// nchw2nhwc: 8bit
static __mlu_func__ __mlu_builtin__ void __bang_reshape_nchw2nhwc(int8* dst,
                                                                  int8* src,
                                                                  int n,
                                                                  int h,
                                                                  int w,
                                                                  int c) {
  __mlvm_stream_reshape_nchw2nhwc_b8(dst, src, n, h, w, c);
}
static __mlu_func__ __mlu_builtin__ void __bang_reshape_nchw2nhwc(char* dst,
                                                                  char* src,
                                                                  int n,
                                                                  int h,
                                                                  int w,
                                                                  int c) {
  __mlvm_stream_reshape_nchw2nhwc_b8(dst, src, n, h, w, c);
}
static __mlu_func__ __mlu_builtin__ void __bang_reshape_nchw2nhwc(unsigned char* dst,
                                                                  unsigned char* src,
                                                                  int n,
                                                                  int h,
                                                                  int w,
                                                                  int c) {
  __mlvm_stream_reshape_nchw2nhwc_b8(dst, src, n, h, w, c);
}
// nchw2nhwc: 32bit
static __mlu_func__ __mlu_builtin__ void __bang_reshape_nchw2nhwc(float* dst,
                                                                  float* src,
                                                                  int n,
                                                                  int h,
                                                                  int w,
                                                                  int c) {
  __mlvm_stream_reshape_nchw2nhwc_b32(dst, src, n, h, w, c);
}
static __mlu_func__ __mlu_builtin__ void __bang_reshape_nchw2nhwc(int* dst,
                                                                  int* src,
                                                                  int n,
                                                                  int h,
                                                                  int w,
                                                                  int c) {
  __mlvm_stream_reshape_nchw2nhwc_b32(dst, src, n, h, w, c);
}
static __mlu_func__ __mlu_builtin__ void __bang_reshape_nchw2nhwc(unsigned int* dst,
                                                                  unsigned int* src,
                                                                  int n,
                                                                  int h,
                                                                  int w,
                                                                  int c) {
  __mlvm_stream_reshape_nchw2nhwc_b32(dst, src, n, h, w, c);
}

#endif  // __BANG_ARCH__ >= 200

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream sumpooling forward operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_sumpool(half* dst,
                                                        half* src,
                                                        int channel,
                                                        int height,
                                                        int width,
                                                        int kernel_height,
                                                        int kernel_width) {
  __mlvm_stream_pool_sum_f16(dst, src, channel, height, width,
                             kernel_height, kernel_width,
                             kernel_width, kernel_height);
}
static __mlu_func__ __mlu_builtin__ void __bang_sumpool(half* dst,
                                                        half* src,
                                                        int channel,
                                                        int height,
                                                        int width,
                                                        int kernel_height,
                                                        int kernel_width,
                                                        int stride_width,
                                                        int stride_height) {
  __mlvm_stream_pool_sum_f16(dst, src, channel, height, width,
                             kernel_height, kernel_width,
                             stride_width, stride_height);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_sumpool(float* dst,
                                                        float* src,
                                                        int channel,
                                                        int height,
                                                        int width,
                                                        int kernel_height,
                                                        int kernel_width,
                                                        int stride_width,
                                                        int stride_height) {
  __mlvm_stream_pool_sum_f32(dst, src, channel, height, width,
                             kernel_height, kernel_width,
                             stride_width, stride_height);
}
#endif  // __BANG_ARCH__ >= 200
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_sumpool(bfloat16_t* dst,
                                                        bfloat16_t* src,
                                                        int channel,
                                                        int height,
                                                        int width,
                                                        int kernel_height,
                                                        int kernel_width,
                                                        int stride_width,
                                                        int stride_height) {
  __mlvm_stream_pool_sum_bf16(dst, src, channel, height, width,
                              kernel_height, kernel_width,
                              stride_width, stride_height);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321


// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream unpooling backward operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_unpool(half* dst,
                                                       half* src,
                                                       int channel,
                                                       int height,
                                                       int width,
                                                       int kernel_height,
                                                       int kernel_width,
                                                       int stride_width,
                                                       int stride_height,
                                                       int index) {
  __mlvm_stream_unpool_f16(dst, src, channel, height, width,
                           kernel_height, kernel_width,
                           stride_width, stride_height, index);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_unpool(float* dst,
                                                       float* src,
                                                       int channel,
                                                       int height,
                                                       int width,
                                                       int kernel_height,
                                                       int kernel_width,
                                                       int stride_width,
                                                       int stride_height,
                                                       int index) {
  __mlvm_stream_unpool_f32(dst, src, channel, height, width,
                           kernel_height, kernel_width,
                           stride_width, stride_height, index);
}
#endif  // __BANG_ARCH__ >= 200
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_unpool(bfloat16_t* dst,
                                                       bfloat16_t* src,
                                                       int channel,
                                                       int height,
                                                       int width,
                                                       int kernel_height,
                                                       int kernel_width,
                                                       int stride_width,
                                                       int stride_height,
                                                       int index) {
  __mlvm_stream_unpool_bf16(dst, src, channel, height, width,
                            kernel_height, kernel_width,
                            stride_width, stride_height, index);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream maxpooling forward operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_maxpool(half* dst,
                                                        half* src,
                                                        int channel,
                                                        int height,
                                                        int width,
                                                        int kernel_height,
                                                        int kernel_width) {
  __mlvm_stream_pool_max_f16(dst, src, channel, height, width,
                             kernel_height, kernel_width,
                             kernel_width, kernel_height);
}

static __mlu_func__ __mlu_builtin__ void __bang_maxpool(half* dst,
                                                        half* src,
                                                        int channel,
                                                        int height,
                                                        int width,
                                                        int kernel_height,
                                                        int kernel_width,
                                                        int stride_width,
                                                        int stride_height) {
  __mlvm_stream_pool_max_f16(dst, src, channel, height, width,
                             kernel_height, kernel_width,
                             stride_width, stride_height);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_maxpool(float* dst,
                                                        float* src,
                                                        int channel,
                                                        int height,
                                                        int width,
                                                        int kernel_height,
                                                        int kernel_width,
                                                        int stride_width,
                                                        int stride_height) {
  __mlvm_stream_pool_max_f32(dst, src, channel, height, width,
                             kernel_height, kernel_width,
                             stride_width, stride_height);
}
#endif  // __BANG_ARCH__ >= 200
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_maxpool(bfloat16_t* dst,
                                                        bfloat16_t* src,
                                                        int channel,
                                                        int height,
                                                        int width,
                                                        int kernel_height,
                                                        int kernel_width,
                                                        int stride_width,
                                                        int stride_height) {
  __mlvm_stream_pool_max_bf16(dst, src, channel, height, width,
                              kernel_height, kernel_width,
                              stride_width, stride_height);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream maxpooling forward operation with index
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_maxpool_index(unsigned short* dst,
                                                              half* src,
                                                              int channel,
                                                              int height,
                                                              int width,
                                                              int kernel_height,
                                                              int kernel_width) {
  __mlvm_stream_pool_max_index_f16(dst, src, channel, height, width,
                                   kernel_height, kernel_width,
                                   kernel_width, kernel_height);
}

static __mlu_func__ __mlu_builtin__ void __bang_maxpool_index(unsigned short* dst,
                                                              half* src,
                                                              int channel,
                                                              int height,
                                                              int width,
                                                              int kernel_height,
                                                              int kernel_width,
                                                              int stride_width,
                                                              int stride_height) {
  __mlvm_stream_pool_max_index_f16(dst, src, channel, height, width,
                                   kernel_height, kernel_width,
                                   stride_width, stride_height);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_maxpool_index(unsigned int* dst,
                                                              float* src,
                                                              int channel,
                                                              int height,
                                                              int width,
                                                              int kernel_height,
                                                              int kernel_width,
                                                              int stride_width,
                                                              int stride_height) {
  __mlvm_stream_pool_max_index_f32(dst, src, channel, height, width,
                                   kernel_height, kernel_width,
                                   stride_width, stride_height);
}
#endif  // __BANG_ARCH__ >= 200
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_maxpool_index(unsigned short* dst,
                                                              bfloat16_t* src,
                                                              int channel,
                                                              int height,
                                                              int width,
                                                              int kernel_height,
                                                              int kernel_width,
                                                              int stride_width,
                                                              int stride_height) {
  __mlvm_stream_pool_max_index_bf16(dst, src, channel, height, width,
                                    kernel_height, kernel_width,
                                    stride_width, stride_height);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream minpooling forward operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_minpool(half* dst,
                                                        half* src,
                                                        int channel,
                                                        int height,
                                                        int width,
                                                        int kernel_height,
                                                        int kernel_width) {
  __mlvm_stream_pool_min_f16(dst, src, channel, height, width,
                             kernel_height, kernel_width,
                             kernel_width, kernel_height);
}

static __mlu_func__ __mlu_builtin__ void __bang_minpool(half* dst,
                                                        half* src,
                                                        int channel,
                                                        int height,
                                                        int width,
                                                        int kernel_height,
                                                        int kernel_width,
                                                        int stride_width,
                                                        int stride_height) {
  __mlvm_stream_pool_min_f16(dst, src, channel, height, width,
                             kernel_height, kernel_width,
                             stride_width, stride_height);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_minpool(float* dst,
                                                        float* src,
                                                        int channel,
                                                        int height,
                                                        int width,
                                                        int kernel_height,
                                                        int kernel_width,
                                                        int stride_width,
                                                        int stride_height) {
  __mlvm_stream_pool_min_f32(dst, src, channel, height, width,
                             kernel_height, kernel_width,
                             stride_width, stride_height);
}
#endif  // __BANG_ARCH__ >= 200
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_minpool(bfloat16_t* dst,
                                                        bfloat16_t* src,
                                                        int channel,
                                                        int height,
                                                        int width,
                                                        int kernel_height,
                                                        int kernel_width,
                                                        int stride_width,
                                                        int stride_height) {
  __mlvm_stream_pool_min_bf16(dst, src, channel, height, width,
                              kernel_height, kernel_width,
                              stride_width, stride_height);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream minpooling forward operation with index
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_minpool_index(unsigned short* dst,
                                                              half* src,
                                                              int channel,
                                                              int height,
                                                              int width,
                                                              int kernel_height,
                                                              int kernel_width) {
  __mlvm_stream_pool_min_index_f16(dst, src, channel, height, width,
                                   kernel_height, kernel_width,
                                   kernel_width, kernel_height);
}

static __mlu_func__ __mlu_builtin__ void __bang_minpool_index(unsigned short* dst,
                                                              half* src,
                                                              int channel,
                                                              int height,
                                                              int width,
                                                              int kernel_height,
                                                              int kernel_width,
                                                              int stride_width,
                                                              int stride_height) {
  __mlvm_stream_pool_min_index_f16(dst, src, channel, height, width,
                                   kernel_height, kernel_width,
                                   stride_width, stride_height);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_minpool_index(unsigned int* dst,
                                                              float* src,
                                                              int channel,
                                                              int height,
                                                              int width,
                                                              int kernel_height,
                                                              int kernel_width,
                                                              int stride_width,
                                                              int stride_height) {
  __mlvm_stream_pool_min_index_f32(dst, src, channel, height, width,
                                   kernel_height, kernel_width,
                                   stride_width, stride_height);
}
#endif  // __BANG_ARCH__ >= 200
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_minpool_index(unsigned short* dst,
                                                              bfloat16_t* src,
                                                              int channel,
                                                              int height,
                                                              int width,
                                                              int kernel_height,
                                                              int kernel_width,
                                                              int stride_width,
                                                              int stride_height) {
  __mlvm_stream_pool_min_index_bf16(dst, src, channel, height, width,
                                    kernel_height, kernel_width,
                                    stride_width, stride_height);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream avgpooling forward operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_avgpool(half* dst,
                                                        half* src,
                                                        int channel,
                                                        int height,
                                                        int width,
                                                        int kernel_height,
                                                        int kernel_width) {
  __mlvm_stream_pool_avg_f16(dst, src, channel, height, width,
                             kernel_height, kernel_width,
                             kernel_width, kernel_height);
}
static __mlu_func__ __mlu_builtin__ void __bang_avgpool(half* dst,
                                                        half* src,
                                                        int channel,
                                                        int height,
                                                        int width,
                                                        int kernel_height,
                                                        int kernel_width,
                                                        int stride_width,
                                                        int stride_height) {
  __mlvm_stream_pool_avg_f16(dst, src, channel, height, width,
                             kernel_height, kernel_width,
                             stride_width, stride_height);
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_avgpool(float* dst,
                                                        float* src,
                                                        int channel,
                                                        int height,
                                                        int width,
                                                        int kernel_height,
                                                        int kernel_width,
                                                        int stride_width,
                                                        int stride_height) {
  __mlvm_stream_pool_avg_f32(dst, src, channel, height, width,
                             kernel_height, kernel_width,
                             stride_width, stride_height);
}
#endif  // __BANG_ARCH__ >= 200
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_avgpool(bfloat16_t* dst,
                                                        bfloat16_t* src,
                                                        int channel,
                                                        int height,
                                                        int width,
                                                        int kernel_height,
                                                        int kernel_width,
                                                        int stride_width,
                                                        int stride_height) {
  __mlvm_stream_pool_avg_bf16(dst, src, channel, height, width,
                              kernel_height, kernel_width,
                              stride_width, stride_height);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream avgpooling backward operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_avgpool_bp(half* dst,
                                                           half* src,
                                                           int channel,
                                                           int height,
                                                           int width,
                                                           int kernel_height,
                                                           int kernel_width,
                                                           int stride_width,
                                                           int stride_height,
                                                           mluPoolBPOverlap overlap = OVERLAP_ACC) {
  switch (overlap) {
    case OVERLAP_ACC: {
      __mlvm_stream_pool_avg_bp_f16(dst, src, channel, height, width,
                                    kernel_height, kernel_width,
                                    stride_width, stride_height);
      break;
    }
    case OVERLAP_COVER: {
      __mlvm_stream_pool_avg_bp_cover_f16(dst, src, channel, height, width,
                                          kernel_height, kernel_width,
                                          stride_width, stride_height);
      break;
    }
    default: {
      // Invalid mluPoolBPOverlap option.
      asm volatile("exit %[status];\n\t"
                    ::[status] "i"(TRAP_BANG_INVALID_POOLBP_OVERLAP_OPTION));
      break;
    }
  }
}
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_avgpool_bp(float* dst,
                                                           float* src,
                                                           int channel,
                                                           int height,
                                                           int width,
                                                           int kernel_height,
                                                           int kernel_width,
                                                           int stride_width,
                                                           int stride_height,
                                                           mluPoolBPOverlap overlap = OVERLAP_ACC) {
  switch (overlap) {
    case OVERLAP_ACC: {
      __mlvm_stream_pool_avg_bp_f32(dst, src, channel, height, width,
                                    kernel_height, kernel_width,
                                    stride_width, stride_height);
      break;
    }
    case OVERLAP_COVER: {
      __mlvm_stream_pool_avg_bp_cover_f32(dst, src, channel, height, width,
                                          kernel_height, kernel_width,
                                          stride_width, stride_height);
      break;
    }
    default: {
      // Invalid mluPoolBPOverlap option.
      asm volatile("exit %[status];\n\t"
                    ::[status] "i"(TRAP_BANG_INVALID_POOLBP_OVERLAP_OPTION));
      break;
    }
  }
}
#endif  // __BANG_ARCH__ >= 200
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_avgpool_bp(bfloat16_t* dst,
                                                           bfloat16_t* src,
                                                           int channel,
                                                           int height,
                                                           int width,
                                                           int kernel_height,
                                                           int kernel_width,
                                                           int stride_width,
                                                           int stride_height,
                                                           mluPoolBPOverlap overlap = OVERLAP_ACC) {
  switch (overlap) {
    case OVERLAP_ACC: {
      __mlvm_stream_pool_avg_bp_bf16(dst, src, channel, height, width,
                                     kernel_height, kernel_width,
                                     stride_width, stride_height);
      break;
    }
    case OVERLAP_COVER: {
      __mlvm_stream_pool_avg_bp_cover_bf16(dst, src, channel, height, width,
                                           kernel_height, kernel_width,
                                           stride_width, stride_height);
      break;
    }
    default: {
      // Invalid mluPoolBPOverlap option.
      asm volatile("exit %[status];\n\t"
                    ::[status] "i"(TRAP_BANG_INVALID_POOLBP_OVERLAP_OPTION));
      break;
    }
  }
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream maxpooling backward operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_maxpool_bp(half* dst,
                                                           half* src,
                                                           int16* mask,
                                                           int channel,
                                                           int height,
                                                           int width,
                                                           int kernel_height,
                                                           int kernel_width,
                                                           int stride_width,
                                                           int stride_height,
                                                           mluPoolBPOverlap overlap = OVERLAP_ACC) {
  switch (overlap) {
    case OVERLAP_ACC: {
      __mlvm_stream_pool_max_bp_f16(dst, src, mask, channel, height, width,
                                    kernel_height, kernel_width,
                                    stride_width, stride_height);
      break;
    }
    case OVERLAP_COVER: {
      __mlvm_stream_pool_max_bp_cover_f16(dst, src, mask, channel, height,
                                          width, kernel_height, kernel_width,
                                          stride_width, stride_height);
      break;
    }
    default: {
      // Invalid mluPoolBPOverlap option.
      asm volatile("exit %[status];\n\t"
                    ::[status] "i"(TRAP_BANG_INVALID_POOLBP_OVERLAP_OPTION));
      break;
    }
  }
}
static __mlu_func__ __mlu_builtin__ void __bang_maxpool_bp(float* dst,
                                                           float* src,
                                                           int* mask,
                                                           int channel,
                                                           int height,
                                                           int width,
                                                           int kernel_height,
                                                           int kernel_width,
                                                           int stride_width,
                                                           int stride_height,
                                                           mluPoolBPOverlap overlap = OVERLAP_ACC) {
  switch (overlap) {
    case OVERLAP_ACC: {
      __mlvm_stream_pool_max_bp_f32(dst, src, mask, channel, height, width,
                                    kernel_height, kernel_width,
                                    stride_width, stride_height);
      break;
    }
    case OVERLAP_COVER: {
      __mlvm_stream_pool_max_bp_cover_f32(dst, src, mask, channel, height,
                                          width, kernel_height, kernel_width,
                                          stride_width, stride_height);
      break;
    }
    default: {
      // Invalid mluPoolBPOverlap option.
      asm volatile("exit %[status];\n\t"
                    ::[status] "i"(TRAP_BANG_INVALID_POOLBP_OVERLAP_OPTION));
      break;
    }
  }
}
#endif  // __BANG_ARCH__ >= 200
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_maxpool_bp(bfloat16_t* dst,
                                                           bfloat16_t* src,
                                                           unsigned short* mask,
                                                           int channel,
                                                           int height,
                                                           int width,
                                                           int kernel_height,
                                                           int kernel_width,
                                                           int stride_width,
                                                           int stride_height,
                                                           mluPoolBPOverlap overlap = OVERLAP_ACC) {
  switch (overlap) {
    case OVERLAP_ACC: {
      __mlvm_stream_pool_max_bp_bf16(dst, src, mask, channel, height, width,
                                     kernel_height, kernel_width,
                                     stride_width, stride_height);
      break;
    }
    case OVERLAP_COVER: {
      __mlvm_stream_pool_max_bp_cover_bf16(dst, src, mask, channel, height,
                                           width, kernel_height, kernel_width,
                                           stride_width, stride_height);
      break;
    }
    default: {
      // Invalid mluPoolBPOverlap option.
      asm volatile("exit %[status];\n\t"
                    ::[status] "i"(TRAP_BANG_INVALID_POOLBP_OVERLAP_OPTION));
      break;
    }
  }
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// --------------------------------------------------------------------------------
// Bang C/C++ math function: stream maximun/minimum pool instruction with dilation.
// --------------------------------------------------------------------------------
#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ void __bang_maxpool_value_index(half* dst,
                                                                    half* src,
                                                                    int channel,
                                                                    int height,
                                                                    int width,
                                                                    int kernel_height,
                                                                    int kernel_width,
                                                                    int stride_width,
                                                                    int stride_height,
                                                                    int value_index_stride,
                                                                    int in_dh,
                                                                    int in_dw,
                                                                    int out_dh,
                                                                    int out_dw) {
  __mlvm_stream_pool_max_value_index_f16(dst, src, channel, height, width,
                                         kernel_height, kernel_width,
                                         stride_width, stride_height,
                                         value_index_stride,
                                         in_dh, in_dw, out_dh, out_dw);
}
static __mlu_func__ __mlu_builtin__ void __bang_maxpool_value_index(float* dst,
                                                                    float* src,
                                                                    int channel,
                                                                    int height,
                                                                    int width,
                                                                    int kernel_height,
                                                                    int kernel_width,
                                                                    int stride_width,
                                                                    int stride_height,
                                                                    int value_index_stride,
                                                                    int in_dh,
                                                                    int in_dw,
                                                                    int out_dh,
                                                                    int out_dw) {
  __mlvm_stream_pool_max_value_index_f32(dst, src, channel, height, width,
                                         kernel_height, kernel_width,
                                         stride_width, stride_height,
                                         value_index_stride,
                                         in_dh, in_dw, out_dh, out_dw);
}
static __mlu_func__ __mlu_builtin__ void __bang_minpool_value_index(half* dst,
                                                                    half* src,
                                                                    int channel,
                                                                    int height,
                                                                    int width,
                                                                    int kernel_height,
                                                                    int kernel_width,
                                                                    int stride_width,
                                                                    int stride_height,
                                                                    int value_index_stride,
                                                                    int in_dh,
                                                                    int in_dw,
                                                                    int out_dh,
                                                                    int out_dw) {
  __mlvm_stream_pool_min_value_index_f16(dst, src, channel, height, width,
                                         kernel_height, kernel_width,
                                         stride_width, stride_height,
                                         value_index_stride,
                                         in_dh, in_dw, out_dh, out_dw);
}
static __mlu_func__ __mlu_builtin__ void __bang_minpool_value_index(float* dst,
                                                                    float* src,
                                                                    int channel,
                                                                    int height,
                                                                    int width,
                                                                    int kernel_height,
                                                                    int kernel_width,
                                                                    int stride_width,
                                                                    int stride_height,
                                                                    int value_index_stride,
                                                                    int in_dh,
                                                                    int in_dw,
                                                                    int out_dh,
                                                                    int out_dw) {
  __mlvm_stream_pool_min_value_index_f32(dst, src, channel, height, width,
                                         kernel_height, kernel_width,
                                         stride_width, stride_height,
                                         value_index_stride,
                                         in_dh, in_dw, out_dh, out_dw);
}
#endif  // __BANG_ARCH__ >= 300
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321
static __mlu_func__ __mlu_builtin__ void __bang_maxpool_value_index(bfloat16_t* dst,
                                                                    bfloat16_t* src,
                                                                    int channel,
                                                                    int height,
                                                                    int width,
                                                                    int kernel_height,
                                                                    int kernel_width,
                                                                    int stride_width,
                                                                    int stride_height,
                                                                    int value_index_stride,
                                                                    int in_dh,
                                                                    int in_dw,
                                                                    int out_dh,
                                                                    int out_dw) {
  __mlvm_stream_pool_max_value_index_bf16(dst, src, channel, height, width,
                                          kernel_height, kernel_width,
                                          stride_width, stride_height,
                                          value_index_stride,
                                          in_dh, in_dw, out_dh, out_dw);
}
static __mlu_func__ __mlu_builtin__ void __bang_minpool_value_index(bfloat16_t* dst,
                                                                    bfloat16_t* src,
                                                                    int channel,
                                                                    int height,
                                                                    int width,
                                                                    int kernel_height,
                                                                    int kernel_width,
                                                                    int stride_width,
                                                                    int stride_height,
                                                                    int value_index_stride,
                                                                    int in_dh,
                                                                    int in_dw,
                                                                    int out_dh,
                                                                    int out_dw) {
  __mlvm_stream_pool_min_value_index_bf16(dst, src, channel, height, width,
                                          kernel_height, kernel_width,
                                          stride_width, stride_height,
                                          value_index_stride,
                                          in_dh, in_dw, out_dh, out_dw);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 320 || __BANG_ARCH__ == 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream histogram operation
// -----------------------------------------------------------------------------
//   | dst-type | src-type | kernel-type |  __BANG_ARCH__             |
//   +----------+----------+-------------+----------------------------+
//   |   half   |   int8   |    int8     |    >=320                   |
//   |   float  |   int8   |    int8     |    >=320                   |
//   |   int16  |   int8   |    int8     |    >=320                   |
//   |   int32  |   int8   |    int8     |    ==220 or >=320          |
//   |   half   |   int16  |    int16    |    ==322 or ==372          |
//   |   float  |   int16  |    int16    |    ==322 or ==372          |
//   |   int16  |   int16  |    int16    |    ==322 or ==372          |
//   |   int32  |   int16  |    int16    |    ==220 or ==322 or ==372 |
//   |   float  |   half   |    int16    |    >=372                   |
//   |   float  |   int16  |    int16    |    >=372                   |
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ == 210 || __BANG_ARCH__ == 220 || __BANG_ARCH__ >= 320
static __mlu_func__ __mlu_builtin__ void __bang_histogram(int* dst,
                                                          int8* src,
                                                          int8* kernel,
                                                          int size) {
  __mlvm_stream_histogram_s32_fix8_fix8(dst, src, kernel, size);
}
#endif
#if __BANG_ARCH__ == 220 || __BANG_ARCH__ == 322 || \
    __BANG_ARCH__ == 372 || __BANG_ARCH__ == 210
static __mlu_func__ __mlu_builtin__ void __bang_histogram(int* dst,
                                                          int16* src,
                                                          int16* kernel,
                                                          int size) {
  __mlvm_stream_histogram_s32_fix16_fix16(dst, src, kernel, size);
}
#endif
#if __BANG_ARCH__ >= 320
static __mlu_func__ __mlu_builtin__ void __bang_histogram(half* dst,
                                                          int8* src,
                                                          int8* kernel,
                                                          int size) {
  __mlvm_stream_histogram_f16_fix8_fix8(dst, src, kernel, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_histogram(float* dst,
                                                          int8* src,
                                                          int8* kernel,
                                                          int size) {
  __mlvm_stream_histogram_f32_fix8_fix8(dst, src, kernel, size);
}

static __mlu_func__ __mlu_builtin__ void __bang_histogram(int16* dst,
                                                          int8* src,
                                                          int8* kernel,
                                                          int size) {
  __mlvm_stream_histogram_s16_fix8_fix8(dst, src, kernel, size);
}
#endif
#if __BANG_ARCH__ >= 372
static __mlu_func__ __mlu_builtin__ void __bang_histogram(float* dst,
                                                          half* src,
                                                          half* kernel,
                                                          int size) {
  __mlvm_stream_histogram_f32_f16_f16(dst, src, kernel, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_histogram(float* dst,
                                                          bfloat16_t* src,
                                                          bfloat16_t* kernel,
                                                          int size) {
  __mlvm_stream_histogram_f32_bf16_bf16(dst, src, kernel, size);
}
#endif
#if __BANG_ARCH__ == 322 || __BANG_ARCH__ == 372
static __mlu_func__ __mlu_builtin__ void __bang_histogram(half* dst,
                                                          int16* src,
                                                          int16* kernel,
                                                          int size) {
  __mlvm_stream_histogram_f16_fix16_fix16(dst, src, kernel, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_histogram(float* dst,
                                                          int16* src,
                                                          int16* kernel,
                                                          int size) {
  __mlvm_stream_histogram_f32_fix16_fix16(dst, src, kernel, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_histogram(int16* dst,
                                                          int16* src,
                                                          int16* kernel,
                                                          int size) {
  __mlvm_stream_histogram_s16_fix16_fix16(dst, src, kernel, size);
}
#endif

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream integral operation
// -----------------------------------------------------------------------------
//   | dst-type | src-type | kernel-type |    __BANG_ARCH__       |
//   +----------+----------+-------------+------------------------+
//   |   int    |   short  |    short    |     >= 322 && != 392   |
//   |   short  |   short  |    short    |     >= 322 && != 392   |
//   |   float  |   int16  |    int16    |     >= 322 && != 392   |
//   |   half   |   int16  |    int16    |     >= 322 && != 392   |
//   |   int    |   char   |    char     |     >= 320             |
//   |   short  |   char   |    char     |     >= 320             |
//   |   float  |   int8   |    int8     |     >= 320             |
//   |   half   |   int8   |    int8     |     >= 320             |
//   |   float  |   float  |    float    |     >= 372             |
//   |   float  |   half   |    half     |     >= 372             |
// -----------------------------------------------------------------------------
#if (__BANG_ARCH__ >= 322) && (__BANG_ARCH__ != 392)
static __mlu_func__ __mlu_builtin__ void __bang_integral(int* dst,
                                                         short* src,
                                                         short* kernel,
                                                         int size) {
  __mlvm_stream_integral_s32_s16_s16(dst, src, kernel, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_integral(short* dst,
                                                         short* src,
                                                         short* kernel,
                                                         int size) {
  __mlvm_stream_integral_s16_s16_s16(dst, src, kernel, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_integral(float* dst,
                                                         int16* src,
                                                         int16* kernel,
                                                         int size,
                                                         int fix_position = 0) {
  __mlvm_stream_integral_f32_fix16_fix16(dst, src, kernel, size, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_integral(half* dst,
                                                         int16* src,
                                                         int16* kernel,
                                                         int size,
                                                         int fix_position = 0) {
  __mlvm_stream_integral_f16_fix16_fix16(dst, src, kernel, size, fix_position);
}
#endif
#if __BANG_ARCH__ >= 320
static __mlu_func__ __mlu_builtin__ void __bang_integral(int* dst,
                                                         char* src,
                                                         char* kernel,
                                                         int size) {
  __mlvm_stream_integral_s32_s8_s8(dst, src, kernel, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_integral(short* dst,
                                                         char* src,
                                                         char* kernel,
                                                         int size) {
  __mlvm_stream_integral_s16_s8_s8(dst, src, kernel, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_integral(float* dst,
                                                         int8* src,
                                                         int8* kernel,
                                                         int size,
                                                         int fix_position = 0) {
  __mlvm_stream_integral_f32_fix8_fix8(dst, src, kernel, size, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_integral(half* dst,
                                                         int8* src,
                                                         int8* kernel,
                                                         int size,
                                                         int fix_position = 0) {
  __mlvm_stream_integral_f16_fix8_fix8(dst, src, kernel, size, fix_position);
}
#endif
#if __BANG_ARCH__ >= 372
static __mlu_func__ __mlu_builtin__ void __bang_integral(float* dst,
                                                         float* src,
                                                         float* kernel,
                                                         int size) {
  __mlvm_stream_integral_f32_f32_f32(dst, src, kernel, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_integral(float* dst,
                                                         half* src,
                                                         half* kernel,
                                                         int size) {
  __mlvm_stream_integral_f32_f16_f16(dst, src, kernel, size);
}
#endif

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream conv operation
// -----------------------------------------------------------------------------
//   | dst-type |   src-type    |  kernel-type  | bias-type | __BANG_ARCH__ |
//   +----------+---------------+---------------+-----------+---------------+
//   |   half   |   half        |   half        |   half    |     <  200    |
//   |   half   |   int8        |   int8        |   half    |     >= 100    |
//   |   half   |   int4        |   int4        |   half    |     >= 200    |
//   |   half   |   int8        |   int4        |   half    |     >= 200    |
//   |   half   |   int16       |   int16       |   half    |     >= 200    |
//   |   half   |   int16       |   int8        |   half    |     >= 200    |
//   |   float  |   int4        |   int4        |   float   |     >= 200    |
//   |   float  |   int8        |   int4        |   float   |     >= 200    |
//   |   float  |   int8        |   int8        |   float   |     >= 200    |
//   |   float  |   int16       |   int8        |   float   |     >= 200    |
//   |   float  |   int16       |   int16       |   float   |     >= 200    |
//   |   int16  |   int8        |   int8        |   int16   |     >= 200    |
//   |   int16  |   int16       |   int8        |   int16   |     >= 200    |
//   |   int16  |   int16       |   int16       |   int16   |     >= 200    |
//   |   half   |   int16       |   int4        |   half    |     >= 200    |
//   |   float  |   int16       |   int4        |   float   |     >= 200    |
//   |   half   |   int4        |   int8        |   half    |     >= 300    |
//   |   float  |   int4        |   int8        |   float   |     >= 300    |
//   |   half   |   int4        |   int16       |   half    |     >= 300    |
//   |   float  |   int4        |   int16       |   float   |     >= 300    |
//   |   half   |   int4        |   int4        |           |     >= 200    |
//   |   half   |   int8        |   int4        |           |     >= 200    |
//   |   float  |   int4        |   int4        |           |     >= 200    |
//   |   float  |   int8        |   int4        |           |     >= 200    |
//   |   half   |   int16       |   int4        |           |     >= 200    |
//   |   float  |   int16       |   int4        |           |     >= 200    |
//   |   half   |   int4        |   int8        |           |     >= 300    |
//   |   float  |   int4        |   int8        |           |     >= 300    |
//   |   half   |   int4        |   int16       |           |     >= 300    |
//   |   float  |   int4        |   int16       |           |     >= 300    |
//   |   float  |   half        |   half        |           |     >= 372    |
//   |   float  |   half        |   float       |           |     >= 372    |
//   |   float  |   float       |   half        |           |     >= 372    |
//   |   float  |   float       |   float       |           |     >= 372    |
//   |   float  |   bfloat16_t  |   bfloat16_t  |           |     >= 372    |
//   |   float  |   bfloat16_t  |   float       |           |     >= 372    |
//   |   float  |   float       |   bfloat16_t  |           |     >= 372    |
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int8* src,
                                                     int8* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position) {
  __mlvm_stream_conv_f16_fix8_fix8(dst, src, kernel,
                                   channel_input, height, width,
                                   kernel_height, kernel_width,
                                   stride_width, stride_height,
                                   channel_output, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int8* src,
                                                     int8* kernel,
                                                     half* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position) {
  __mlvm_stream_conv_f16_fix8_fix8_f16(dst, src, kernel, bias,
                                       channel_input, height, width,
                                       kernel_height, kernel_width,
                                       stride_width, stride_height,
                                       channel_output, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int16* src,
                                                     int16* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position) {
  __mlvm_stream_conv_f16_fix16_fix16(dst, src, kernel,
                                     channel_input, height, width,
                                     kernel_height, kernel_width,
                                     stride_width, stride_height,
                                     channel_output, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int16* src,
                                                     int16* kernel,
                                                     half* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position) {
  __mlvm_stream_conv_f16_fix16_fix16_f16(dst, src, kernel, bias,
                                         channel_input, height, width,
                                         kernel_height, kernel_width,
                                         stride_width, stride_height,
                                         channel_output, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int16* src,
                                                     int8* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position) {
  __mlvm_stream_conv_f16_fix16_fix8(dst, src, kernel,
                                    channel_input, height, width,
                                    kernel_height, kernel_width,
                                    stride_width, stride_height,
                                    channel_output, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int16* src,
                                                     int8* kernel,
                                                     half* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position) {
  __mlvm_stream_conv_f16_fix16_fix8_f16(dst, src, kernel, bias,
                                        channel_input, height, width,
                                        kernel_height, kernel_width,
                                        stride_width, stride_height,
                                        channel_output, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int8* src,
                                                     int8* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position) {
  __mlvm_stream_conv_f32_fix8_fix8(dst, src, kernel,
                                   channel_input, height, width,
                                   kernel_height, kernel_width,
                                   stride_width, stride_height,
                                   channel_output, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int8* src,
                                                     int8* kernel,
                                                     float* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position) {
  __mlvm_stream_conv_f32_fix8_fix8_f32(dst, src, kernel, bias,
                                       channel_input, height, width,
                                       kernel_height, kernel_width,
                                       stride_width, stride_height,
                                       channel_output, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int16* src,
                                                     int8* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position) {
  __mlvm_stream_conv_f32_fix16_fix8(dst, src, kernel,
                                    channel_input, height, width,
                                    kernel_height, kernel_width,
                                    stride_width, stride_height,
                                    channel_output, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int16* src,
                                                     int8* kernel,
                                                     float* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position) {
  __mlvm_stream_conv_f32_fix16_fix8_f32(dst, src, kernel, bias,
                                        channel_input, height, width,
                                        kernel_height, kernel_width,
                                        stride_width, stride_height,
                                        channel_output, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int16* src,
                                                     int16* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position) {
  __mlvm_stream_conv_f32_fix16_fix16(dst, src, kernel,
                                     channel_input, height, width,
                                     kernel_height, kernel_width,
                                     stride_width, stride_height,
                                     channel_output, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int16* src,
                                                     int16* kernel,
                                                     float* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position) {
  __mlvm_stream_conv_f32_fix16_fix16_f32(dst, src, kernel, bias,
                                         channel_input, height, width,
                                         kernel_height, kernel_width,
                                         stride_width, stride_height,
                                         channel_output, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(int16* dst,
                                                     int8* src,
                                                     int8* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position) {
  __mlvm_stream_conv_fix16_fix8_fix8(dst, src, kernel,
                                     channel_input, height, width,
                                     kernel_height, kernel_width,
                                     stride_width, stride_height,
                                     channel_output, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(int16* dst,
                                                     int8* src,
                                                     int8* kernel,
                                                     int16* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position) {
  __mlvm_stream_conv_fix16_fix8_fix8_fix16(dst, src, kernel, bias,
                                           channel_input, height, width,
                                           kernel_height, kernel_width,
                                           stride_width, stride_height,
                                           channel_output, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(int16* dst,
                                                     int16* src,
                                                     int8* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position) {
  __mlvm_stream_conv_fix16_fix16_fix8(dst, src, kernel,
                                      channel_input, height, width,
                                      kernel_height, kernel_width,
                                      stride_width, stride_height,
                                      channel_output, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(int16* dst,
                                                     int16* src,
                                                     int8* kernel,
                                                     int16* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position) {
  __mlvm_stream_conv_fix16_fix16_fix8_fix16(dst, src, kernel, bias,
                                            channel_input, height, width,
                                            kernel_height, kernel_width,
                                            stride_width, stride_height,
                                            channel_output, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(int16* dst,
                                                     int16* src,
                                                     int16* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position) {
  __mlvm_stream_conv_fix16_fix16_fix16(dst, src, kernel,
                                       channel_input, height, width,
                                       kernel_height, kernel_width,
                                       stride_width, stride_height,
                                       channel_output, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(int16* dst,
                                                     int16* src,
                                                     int16* kernel,
                                                     int16* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position) {
  __mlvm_stream_conv_fix16_fix16_fix16_fix16(dst, src, kernel, bias,
                                             channel_input, height, width,
                                             kernel_height, kernel_width,
                                             stride_width, stride_height,
                                             channel_output, fix_position);
}

// conv with dilation
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int8* src,
                                                     int8* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int dilation_width,
                                                     int dilation_height) {
  __mlvm_stream_conv_f16_fix8_fix8_dilation(dst, src, kernel,
                                            channel_input, height, width,
                                            kernel_height, kernel_width,
                                            stride_width, stride_height,
                                            channel_output, fix_position,
                                            dilation_width, dilation_height);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int8* src,
                                                     int8* kernel,
                                                     half* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int dilation_width,
                                                     int dilation_height) {
  __mlvm_stream_conv_f16_fix8_fix8_f16_dilation(dst, src, kernel, bias,
                                                channel_input, height, width,
                                                kernel_height, kernel_width,
                                                stride_width, stride_height,
                                                channel_output, fix_position,
                                                dilation_width, dilation_height);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int16* src,
                                                     int16* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int dilation_width,
                                                     int dilation_height) {
  __mlvm_stream_conv_f16_fix16_fix16_dilation(dst, src, kernel,
                                              channel_input, height, width,
                                              kernel_height, kernel_width,
                                              stride_width, stride_height,
                                              channel_output, fix_position,
                                              dilation_width, dilation_height);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int16* src,
                                                     int16* kernel,
                                                     half* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int dilation_width,
                                                     int dilation_height) {
  __mlvm_stream_conv_f16_fix16_fix16_f16_dilation(dst, src, kernel, bias,
                                                  channel_input, height, width,
                                                  kernel_height, kernel_width,
                                                  stride_width, stride_height,
                                                  channel_output, fix_position,
                                                  dilation_width, dilation_height);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int16* src,
                                                     int8* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int dilation_width,
                                                     int dilation_height) {
  __mlvm_stream_conv_f16_fix16_fix8_dilation(dst, src, kernel,
                                             channel_input, height, width,
                                             kernel_height, kernel_width,
                                             stride_width, stride_height,
                                             channel_output, fix_position,
                                             dilation_width, dilation_height);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int16* src,
                                                     int8* kernel,
                                                     half* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int dilation_width,
                                                     int dilation_height) {
  __mlvm_stream_conv_f16_fix16_fix8_f16_dilation(dst, src, kernel, bias,
                                                 channel_input, height, width,
                                                 kernel_height, kernel_width,
                                                 stride_width, stride_height,
                                                 channel_output, fix_position,
                                                 dilation_width, dilation_height);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int8* src,
                                                     int8* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int dilation_width,
                                                     int dilation_height) {
  __mlvm_stream_conv_f32_fix8_fix8_dilation(dst, src, kernel,
                                            channel_input, height, width,
                                            kernel_height, kernel_width,
                                            stride_width, stride_height,
                                            channel_output, fix_position,
                                            dilation_width, dilation_height);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int8* src,
                                                     int8* kernel,
                                                     float* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int dilation_width,
                                                     int dilation_height) {
  __mlvm_stream_conv_f32_fix8_fix8_f32_dilation(dst, src, kernel, bias,
                                                channel_input, height, width,
                                                kernel_height, kernel_width,
                                                stride_width, stride_height,
                                                channel_output, fix_position,
                                                dilation_width, dilation_height);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int16* src,
                                                     int8* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int dilation_width,
                                                     int dilation_height) {
  __mlvm_stream_conv_f32_fix16_fix8_dilation(dst, src, kernel,
                                             channel_input, height, width,
                                             kernel_height, kernel_width,
                                             stride_width, stride_height,
                                             channel_output, fix_position,
                                             dilation_width, dilation_height);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int16* src,
                                                     int8* kernel,
                                                     float* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int dilation_width,
                                                     int dilation_height) {
  __mlvm_stream_conv_f32_fix16_fix8_f32_dilation(dst, src, kernel, bias,
                                                 channel_input, height, width,
                                                 kernel_height, kernel_width,
                                                 stride_width, stride_height,
                                                 channel_output, fix_position,
                                                 dilation_width, dilation_height);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int16* src,
                                                     int16* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int dilation_width,
                                                     int dilation_height) {
  __mlvm_stream_conv_f32_fix16_fix16_dilation(dst, src, kernel,
                                              channel_input, height, width,
                                              kernel_height, kernel_width,
                                              stride_width, stride_height,
                                              channel_output, fix_position,
                                              dilation_width, dilation_height);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int16* src,
                                                     int16* kernel,
                                                     float* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int dilation_width,
                                                     int dilation_height) {
  __mlvm_stream_conv_f32_fix16_fix16_f32_dilation(dst, src, kernel, bias,
                                                  channel_input, height, width,
                                                  kernel_height, kernel_width,
                                                  stride_width, stride_height,
                                                  channel_output, fix_position,
                                                  dilation_width, dilation_height);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(int16* dst,
                                                     int8* src,
                                                     int8* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int dilation_width,
                                                     int dilation_height) {
  __mlvm_stream_conv_fix16_fix8_fix8_dilation(dst, src, kernel,
                                              channel_input, height, width,
                                              kernel_height, kernel_width,
                                              stride_width, stride_height,
                                              channel_output, fix_position,
                                              dilation_width, dilation_height);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(int16* dst,
                                                     int8* src,
                                                     int8* kernel,
                                                     int16* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int dilation_width,
                                                     int dilation_height) {
  __mlvm_stream_conv_fix16_fix8_fix8_fix16_dilation(dst, src, kernel, bias,
                                                    channel_input,
                                                    height, width,
                                                    kernel_height, kernel_width,
                                                    stride_width, stride_height,
                                                    channel_output,
                                                    fix_position,
                                                    dilation_width, dilation_height);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(int16* dst,
                                                     int16* src,
                                                     int8* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int dilation_width,
                                                     int dilation_height) {
  __mlvm_stream_conv_fix16_fix16_fix8_dilation(dst, src, kernel,
                                               channel_input, height, width,
                                               kernel_height, kernel_width,
                                               stride_width, stride_height,
                                               channel_output, fix_position,
                                               dilation_width, dilation_height);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(int16* dst,
                                                     int16* src,
                                                     int8* kernel,
                                                     int16* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int dilation_width,
                                                     int dilation_height) {
  __mlvm_stream_conv_fix16_fix16_fix8_fix16_dilation(dst, src, kernel, bias,
                                                     channel_input,
                                                     height, width,
                                                     kernel_height, kernel_width,
                                                     stride_width, stride_height,
                                                     channel_output,
                                                     fix_position,
                                                     dilation_width, dilation_height);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(int16* dst,
                                                     int16* src,
                                                     int16* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int dilation_width,
                                                     int dilation_height) {
  __mlvm_stream_conv_fix16_fix16_fix16_dilation(dst, src, kernel,
                                                channel_input, height, width,
                                                kernel_height, kernel_width,
                                                stride_width, stride_height,
                                                channel_output, fix_position,
                                                dilation_width, dilation_height);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(int16* dst,
                                                     int16* src,
                                                     int16* kernel,
                                                     int16* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int dilation_width,
                                                     int dilation_height) {
  __mlvm_stream_conv_fix16_fix16_fix16_fix16_dilation(dst, src, kernel, bias,
                                                      channel_input,
                                                      height, width,
                                                      kernel_height, kernel_width,
                                                      stride_width, stride_height,
                                                      channel_output,
                                                      fix_position,
                                                      dilation_width, dilation_height);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int4x2_t* src,
                                                     int4x2_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position) {
  __mlvm_stream_conv_dilation_f16_fix4_fix4(dst, src, kernel, channel_input, height,
                                            width, kernel_height, kernel_width, stride_width,
                                            stride_height, channel_output, fix_position,
                                            1, 1, 1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int4x2_t* src,
                                                     int4x2_t* kernel,
                                                     half* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position) {
  __mlvm_stream_conv_dilation_f16_fix4_fix4_f16(dst, src, kernel, bias,
                                                channel_input, height, width,
                                                kernel_height, kernel_width,
                                                stride_width, stride_height,
                                                channel_output, fix_position,
                                                1, 1, 1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int4x2_t* src,
                                                     int4x2_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position) {
  __mlvm_stream_conv_dilation_f32_fix4_fix4(dst, src, kernel, channel_input, height,
                                            width, kernel_height, kernel_width, stride_width,
                                            stride_height, channel_output, fix_position,
                                            1, 1, 1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int4x2_t* src,
                                                     int4x2_t* kernel,
                                                     float* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position) {
  __mlvm_stream_conv_dilation_f32_fix4_fix4_f32(dst, src, kernel, bias, channel_input, height,
                                                width, kernel_height, kernel_width, stride_width,
                                                stride_height, channel_output, fix_position,
                                                1, 1, 1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int8* src,
                                                     int4x2_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position) {
  __mlvm_stream_conv_dilation_f16_fix8_fix4(dst, src, kernel, channel_input, height,
                                            width, kernel_height, kernel_width, stride_width,
                                            stride_height, channel_output, fix_position,
                                            1, 1, 1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int8* src,
                                                     int4x2_t* kernel,
                                                     half* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position) {
  __mlvm_stream_conv_dilation_f16_fix8_fix4_f16(dst, src, kernel, bias, channel_input, height,
                                                width, kernel_height, kernel_width, stride_width,
                                                stride_height, channel_output, fix_position,
                                                1, 1, 1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int8* src,
                                                     int4x2_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position) {
  __mlvm_stream_conv_dilation_f32_fix8_fix4(dst, src, kernel, channel_input, height,
                                            width, kernel_height, kernel_width, stride_width,
                                            stride_height, channel_output, fix_position,
                                            1, 1, 1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int8* src,
                                                     int4x2_t* kernel,
                                                     float* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position) {
  __mlvm_stream_conv_dilation_f32_fix8_fix4_f32(dst, src, kernel, bias, channel_input, height,
                                                width, kernel_height, kernel_width, stride_width,
                                                stride_height, channel_output, fix_position,
                                                1, 1, 1, 1);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int4x2_t* src,
                                                     int4x2_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int in_dilation_width,
                                                     int in_dilation_height) {
  __mlvm_stream_conv_dilation_f16_fix4_fix4(dst, src, kernel, channel_input, height,
                                            width, kernel_height, kernel_width, stride_width,
                                            stride_height, channel_output, fix_position,
                                            in_dilation_width, in_dilation_height, 1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int4x2_t* src,
                                                     int4x2_t* kernel,
                                                     half* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int in_dilation_width,
                                                     int in_dilation_height) {
  __mlvm_stream_conv_dilation_f16_fix4_fix4_f16(dst, src, kernel, bias,
                                                channel_input, height, width,
                                                kernel_height, kernel_width,
                                                stride_width, stride_height,
                                                channel_output, fix_position,
                                                in_dilation_width, in_dilation_height, 1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int4x2_t* src,
                                                     int4x2_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int in_dilation_width,
                                                     int in_dilation_height) {
  __mlvm_stream_conv_dilation_f32_fix4_fix4(dst, src, kernel, channel_input, height,
                                            width, kernel_height, kernel_width, stride_width,
                                            stride_height, channel_output, fix_position,
                                            in_dilation_width, in_dilation_height, 1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int4x2_t* src,
                                                     int4x2_t* kernel,
                                                     float* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int in_dilation_width,
                                                     int in_dilation_height) {
  __mlvm_stream_conv_dilation_f32_fix4_fix4_f32(dst, src, kernel, bias, channel_input, height,
                                                width, kernel_height, kernel_width, stride_width,
                                                stride_height, channel_output, fix_position,
                                                in_dilation_width, in_dilation_height, 1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int8* src,
                                                     int4x2_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int in_dilation_width,
                                                     int in_dilation_height) {
  __mlvm_stream_conv_dilation_f16_fix8_fix4(dst, src, kernel, channel_input, height,
                                            width, kernel_height, kernel_width, stride_width,
                                            stride_height, channel_output, fix_position,
                                            in_dilation_width, in_dilation_height, 1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int8* src,
                                                     int4x2_t* kernel,
                                                     half* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int in_dilation_width,
                                                     int in_dilation_height) {
  __mlvm_stream_conv_dilation_f16_fix8_fix4_f16(dst, src, kernel, bias, channel_input, height,
                                                width, kernel_height, kernel_width, stride_width,
                                                stride_height, channel_output, fix_position,
                                                in_dilation_width, in_dilation_height, 1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int8* src,
                                                     int4x2_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int in_dilation_width,
                                                     int in_dilation_height) {
  __mlvm_stream_conv_dilation_f32_fix8_fix4(dst, src, kernel, channel_input, height,
                                            width, kernel_height, kernel_width, stride_width,
                                            stride_height, channel_output, fix_position,
                                            in_dilation_width, in_dilation_height, 1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int8* src,
                                                     int4x2_t* kernel,
                                                     float* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int in_dilation_width,
                                                     int in_dilation_height) {
  __mlvm_stream_conv_dilation_f32_fix8_fix4_f32(dst, src, kernel, bias, channel_input, height,
                                                width, kernel_height, kernel_width, stride_width,
                                                stride_height, channel_output, fix_position,
                                                in_dilation_width, in_dilation_height, 1, 1);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int4x2_t* src,
                                                     int4x2_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int in_dilation_width,
                                                     int in_dilation_height,
                                                     int out_dilation_width,
                                                     int out_dilation_height) {
  __mlvm_stream_conv_dilation_f16_fix4_fix4(dst, src, kernel, channel_input, height,
                                            width, kernel_height, kernel_width, stride_width,
                                            stride_height, channel_output, fix_position,
                                            in_dilation_width, in_dilation_height,
                                            out_dilation_width, out_dilation_height);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int4x2_t* src,
                                                     int4x2_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int in_dilation_width,
                                                     int in_dilation_height,
                                                     int out_dilation_width,
                                                     int out_dilation_height) {
  __mlvm_stream_conv_dilation_f32_fix4_fix4(dst, src, kernel, channel_input, height,
                                            width, kernel_height, kernel_width, stride_width,
                                            stride_height, channel_output, fix_position,
                                            in_dilation_width, in_dilation_height,
                                            out_dilation_width, out_dilation_height);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int8* src,
                                                     int4x2_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int in_dilation_width,
                                                     int in_dilation_height,
                                                     int out_dilation_width,
                                                     int out_dilation_height) {
  __mlvm_stream_conv_dilation_f16_fix8_fix4(dst, src, kernel, channel_input, height,
                                            width, kernel_height, kernel_width, stride_width,
                                            stride_height, channel_output, fix_position,
                                            in_dilation_width, in_dilation_height,
                                            out_dilation_width, out_dilation_height);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int8* src,
                                                     int4x2_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int in_dilation_width,
                                                     int in_dilation_height,
                                                     int out_dilation_width,
                                                     int out_dilation_height) {
  __mlvm_stream_conv_dilation_f32_fix8_fix4(dst, src, kernel, channel_input, height,
                                            width, kernel_height, kernel_width, stride_width,
                                            stride_height, channel_output, fix_position,
                                            in_dilation_width, in_dilation_height,
                                            out_dilation_width, out_dilation_height);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int16* src,
                                                     int4x2_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position) {
  __mlvm_stream_conv_dilation_f16_fix16_fix4(dst, src, kernel, channel_input, height,
                                             width, kernel_height, kernel_width, stride_width,
                                             stride_height, channel_output, fix_position,
                                             1, 1, 1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int16* src,
                                                     int4x2_t* kernel,
                                                     half* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position) {
  __mlvm_stream_conv_dilation_f16_fix16_fix4_f16(dst, src, kernel, bias, channel_input, height,
                                                 width, kernel_height, kernel_width, stride_width,
                                                 stride_height, channel_output, fix_position,
                                                 1, 1, 1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int16* src,
                                                     int4x2_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position) {
  __mlvm_stream_conv_dilation_f32_fix16_fix4(dst, src, kernel, channel_input, height,
                                             width, kernel_height, kernel_width, stride_width,
                                             stride_height, channel_output, fix_position,
                                             1, 1, 1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int16* src,
                                                     int4x2_t* kernel,
                                                     float* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position) {
  __mlvm_stream_conv_dilation_f32_fix16_fix4_f32(dst, src, kernel, bias, channel_input, height,
                                                 width, kernel_height, kernel_width, stride_width,
                                                 stride_height, channel_output, fix_position,
                                                 1, 1, 1, 1);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int16* src,
                                                     int4x2_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int in_dilation_width,
                                                     int in_dilation_height) {
  __mlvm_stream_conv_dilation_f16_fix16_fix4(dst, src, kernel, channel_input, height,
                                             width, kernel_height, kernel_width, stride_width,
                                             stride_height, channel_output, fix_position,
                                             in_dilation_width, in_dilation_height, 1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int16* src,
                                                     int4x2_t* kernel,
                                                     half* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int in_dilation_width,
                                                     int in_dilation_height) {
  __mlvm_stream_conv_dilation_f16_fix16_fix4_f16(dst, src, kernel, bias, channel_input, height,
                                                 width, kernel_height, kernel_width, stride_width,
                                                 stride_height, channel_output, fix_position,
                                                 in_dilation_width, in_dilation_height, 1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int16* src,
                                                     int4x2_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int in_dilation_width,
                                                     int in_dilation_height) {
  __mlvm_stream_conv_dilation_f32_fix16_fix4(dst, src, kernel, channel_input, height,
                                             width, kernel_height, kernel_width, stride_width,
                                             stride_height, channel_output, fix_position,
                                             in_dilation_width, in_dilation_height, 1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int16* src,
                                                     int4x2_t* kernel,
                                                     float* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int in_dilation_width,
                                                     int in_dilation_height) {
  __mlvm_stream_conv_dilation_f32_fix16_fix4_f32(dst, src, kernel, bias, channel_input, height,
                                                 width, kernel_height, kernel_width, stride_width,
                                                 stride_height, channel_output, fix_position,
                                                 in_dilation_width, in_dilation_height, 1, 1);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int16* src,
                                                     int4x2_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int in_dilation_width,
                                                     int in_dilation_height,
                                                     int out_dilation_width,
                                                     int out_dilation_height) {
  __mlvm_stream_conv_dilation_f16_fix16_fix4(dst, src, kernel, channel_input, height,
                                             width, kernel_height, kernel_width, stride_width,
                                             stride_height, channel_output, fix_position,
                                             in_dilation_width, in_dilation_height,
                                             out_dilation_width, out_dilation_height);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int16* src,
                                                     int4x2_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int in_dilation_width,
                                                     int in_dilation_height,
                                                     int out_dilation_width,
                                                     int out_dilation_height) {
  __mlvm_stream_conv_dilation_f32_fix16_fix4(dst, src, kernel, channel_input, height,
                                             width, kernel_height, kernel_width, stride_width,
                                             stride_height, channel_output, fix_position,
                                             in_dilation_width, in_dilation_height,
                                             out_dilation_width, out_dilation_height);
}

#else  // __BANG_ARCH__ < 200

#define __conv_f16(dst, src, kernel,                              \
                   channel_input, height, width,                  \
                   kernel_height, kernel_width,                   \
                   stride_width, stride_height, channel_output)            \
  ({ __mlvm_stream_conv_f16_f16_f16(dst, src, kernel,             \
                                    channel_input, height, width, \
                                    kernel_height, kernel_width,  \
                                    stride_width, stride_height,           \
                                    channel_output);              \
  })

#define __conv_type(dst, src, kernel,                             \
                    channel_input, height, width,                 \
                    kernel_height, kernel_width,                  \
                    stride_width, stride_height, channel_output,           \
                    Type, fix_position)                           \
  __conv_##Type(dst, src, kernel, channel_input, height, width,   \
                kernel_height, kernel_width, stride_width, stride_height,  \
                channel_output, fix_position)

#define __conv_F16_F16_F16(dst, src, kernel,                      \
                           channel_input, height, width,          \
                           kernel_height, kernel_width,           \
                           stride_width, stride_height,                    \
                           channel_output, fix_position)          \
  ({ __mlvm_stream_conv_f16_f16_f16(dst, src, kernel,             \
                                    channel_input, height, width, \
                                    kernel_height, kernel_width,  \
                                    stride_width, stride_height,           \
                                    channel_output);              \
  })

#define __conv_F16_FIX16_FIX16(dst, src, kernel,                        \
                               channel_input, height, width,            \
                               kernel_height, kernel_width,             \
                               stride_width, stride_height,                      \
                               channel_output, fix_position)            \
  ({ __mlvm_stream_conv_f16_fix16_fix16(dst, src, kernel,               \
                                        channel_input, height, width,   \
                                        kernel_height, kernel_width,    \
                                        stride_width, stride_height,             \
                                        channel_output, fix_position);  \
  })

#define __conv_F16_INT16_INT16(dst, src, kernel,                      \
                               channel_input, height, width,          \
                               kernel_height, kernel_width,           \
                               stride_width, stride_height,                    \
                               channel_output, fix_position)          \
  ({ __mlvm_stream_conv_f16_fix16_fix16(dst, src, kernel,             \
                                        channel_input, height, width, \
                                        kernel_height, kernel_width,  \
                                        stride_width, stride_height,           \
                                        channel_output,               \
                                        fix_position);                \
  })

#define __conv_F16_FIX8_FIX8(dst, src, kernel,                        \
                             channel_input, height, width,            \
                             kernel_height, kernel_width,             \
                             stride_width, stride_height,                      \
                             channel_output, fix_position)            \
  ({ __mlvm_stream_conv_f16_fix8_fix8(dst, src, kernel,               \
                                      channel_input, height, width,   \
                                      kernel_height, kernel_width,    \
                                      stride_width, stride_height,             \
                                      channel_output, fix_position);  \
  })

#define __conv_F16_INT8_INT8(dst, src, kernel,                        \
                             channel_input, height, width,            \
                             kernel_height, kernel_width,             \
                             stride_width, stride_height,                      \
                             channel_output, fix_position)            \
  ({ __mlvm_stream_conv_f16_fix8_fix8(dst, src, kernel,               \
                                      channel_input, height, width,   \
                                      kernel_height, kernel_width,    \
                                      stride_width, stride_height,             \
                                      channel_output, fix_position);  \
  })

#define CONV_MACRO(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, NAME, ...) NAME  // NOLINT

#define __bang_conv(...) CONV_MACRO(__VA_ARGS__,                  \
                                    __conv_type,                  \
                                    __conv_type,                  \
                                    __conv_f16, ...)(__VA_ARGS__)
#endif  // __BANG_ARCH__ >= 200

#if (__BANG_ARCH__ >= 300) && (__BANG_ARCH__ != 322) && (__BANG_ARCH__ != 303) && \
    (__BANG_ARCH__ != 306) && (__BANG_ARCH__ != 320) && (__BANG_ARCH__ != 321)
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     float* src,
                                                     float* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output) {
  __mlvm_stream_conv_f32_f32_f32(dst, src, kernel,
                                 channel_input, height, width,
                                 kernel_height, kernel_width,
                                 stride_width, stride_height,
                                 channel_output);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     half* src,
                                                     half* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output) {
  __mlvm_stream_conv_f32_f16_f16(dst, src, kernel,
                                 channel_input, height, width,
                                 kernel_height, kernel_width,
                                 stride_width, stride_height,
                                 channel_output);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     float* src,
                                                     half* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output) {
  __mlvm_stream_conv_f32_f32_f16(dst, src, kernel,
                                 channel_input, height, width,
                                 kernel_height, kernel_width,
                                 stride_width, stride_height,
                                 channel_output);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     half* src,
                                                     float* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output) {
  __mlvm_stream_conv_f32_f16_f32(dst, src, kernel,
                                 channel_input, height, width,
                                 kernel_height, kernel_width,
                                 stride_width, stride_height,
                                 channel_output);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     bfloat16_t* src,
                                                     float* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output) {
  __mlvm_stream_conv_f32_bf16_f32(dst, src, kernel,
                                  channel_input, height, width,
                                  kernel_height, kernel_width,
                                  stride_width, stride_height,
                                  channel_output);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     float* src,
                                                     bfloat16_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output) {
  __mlvm_stream_conv_f32_f32_bf16(dst, src, kernel,
                                  channel_input, height, width,
                                  kernel_height, kernel_width,
                                  stride_width, stride_height,
                                  channel_output);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     bfloat16_t* src,
                                                     bfloat16_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output) {
  __mlvm_stream_conv_f32_bf16_bf16(dst, src, kernel,
                                  channel_input, height, width,
                                  kernel_height, kernel_width,
                                  stride_width, stride_height,
                                  channel_output);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     float* src,
                                                     float* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int indilation_width,
                                                     int indilation_height,
                                                     int outdilation_width,
                                                     int outdilation_height) {
  __mlvm_stream_conv_dilation_f32_f32_f32(dst, src, kernel,
                                          channel_input, height, width,
                                          kernel_height, kernel_width,
                                          stride_width, stride_height, channel_output,
                                          indilation_width, indilation_height,
                                          outdilation_width, outdilation_height);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     half* src,
                                                     half* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int indilation_width,
                                                     int indilation_height,
                                                     int outdilation_width,
                                                     int outdilation_height) {
  __mlvm_stream_conv_dilation_f32_f16_f16(dst, src, kernel,
                                          channel_input, height, width,
                                          kernel_height, kernel_width,
                                          stride_width, stride_height, channel_output,
                                          indilation_width, indilation_height,
                                          outdilation_width, outdilation_height);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     float* src,
                                                     half* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int indilation_width,
                                                     int indilation_height,
                                                     int outdilation_width,
                                                     int outdilation_height) {
  __mlvm_stream_conv_dilation_f32_f32_f16(dst, src, kernel,
                                          channel_input, height, width,
                                          kernel_height, kernel_width,
                                          stride_width, stride_height, channel_output,
                                          indilation_width, indilation_height,
                                          outdilation_width, outdilation_height);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     half* src,
                                                     float* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int indilation_width,
                                                     int indilation_height,
                                                     int outdilation_width,
                                                     int outdilation_height) {
  __mlvm_stream_conv_dilation_f32_f16_f32(dst, src, kernel,
                                          channel_input, height, width,
                                          kernel_height, kernel_width,
                                          stride_width, stride_height, channel_output,
                                          indilation_width, indilation_height,
                                          outdilation_width, outdilation_height);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     bfloat16_t* src,
                                                     float* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int indilation_width,
                                                     int indilation_height,
                                                     int outdilation_width,
                                                     int outdilation_height) {
  __mlvm_stream_conv_dilation_f32_bf16_f32(dst, src, kernel,
                                           channel_input, height, width,
                                           kernel_height, kernel_width,
                                           stride_width, stride_height, channel_output,
                                           indilation_width, indilation_height,
                                           outdilation_width, outdilation_height);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     float* src,
                                                     bfloat16_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int indilation_width,
                                                     int indilation_height,
                                                     int outdilation_width,
                                                     int outdilation_height) {
  __mlvm_stream_conv_dilation_f32_f32_bf16(dst, src, kernel,
                                           channel_input, height, width,
                                           kernel_height, kernel_width,
                                           stride_width, stride_height, channel_output,
                                           indilation_width, indilation_height,
                                           outdilation_width, outdilation_height);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     bfloat16_t* src,
                                                     bfloat16_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int indilation_width,
                                                     int indilation_height,
                                                     int outdilation_width,
                                                     int outdilation_height) {
  __mlvm_stream_conv_dilation_f32_bf16_bf16(dst, src, kernel,
                                            channel_input, height, width,
                                            kernel_height, kernel_width,
                                            stride_width, stride_height, channel_output,
                                            indilation_width, indilation_height,
                                            outdilation_width, outdilation_height);
}

#endif  // __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 322 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 306 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321

#if (__BANG_ARCH__ >= 300) && (__BANG_ARCH__ != 303) && (__BANG_ARCH__ != 306)
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int4x2_t* src,
                                                     int8* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position) {
  __mlvm_stream_conv_dilation_f16_fix4_fix8(dst, src, kernel, channel_input, height,
                                            width, kernel_height, kernel_width, stride_width,
                                            stride_height, channel_output, fix_position,
                                            1, 1, 1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int4x2_t* src,
                                                     int8* kernel,
                                                     half* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position) {
  __mlvm_stream_conv_dilation_f16_fix4_fix8_f16(dst, src, kernel, bias, channel_input, height,
                                                width, kernel_height, kernel_width, stride_width,
                                                stride_height, channel_output, fix_position,
                                                1, 1, 1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int4x2_t* src,
                                                     int8* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position) {
  __mlvm_stream_conv_dilation_f32_fix4_fix8(dst, src, kernel, channel_input, height,
                                            width, kernel_height, kernel_width, stride_width,
                                            stride_height, channel_output, fix_position,
                                            1, 1, 1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int4x2_t* src,
                                                     int8* kernel,
                                                     float* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position) {
  __mlvm_stream_conv_dilation_f32_fix4_fix8_f32(dst, src, kernel, bias, channel_input, height,
                                                width, kernel_height, kernel_width, stride_width,
                                                stride_height, channel_output, fix_position,
                                                1, 1, 1, 1);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int4x2_t* src,
                                                     int8* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int in_dilation_width,
                                                     int in_dilation_height) {
  __mlvm_stream_conv_dilation_f16_fix4_fix8(dst, src, kernel, channel_input, height,
                                            width, kernel_height, kernel_width, stride_width,
                                            stride_height, channel_output, fix_position,
                                            in_dilation_width, in_dilation_height, 1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int4x2_t* src,
                                                     int8* kernel,
                                                     half* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int in_dilation_width,
                                                     int in_dilation_height) {
  __mlvm_stream_conv_dilation_f16_fix4_fix8_f16(dst, src, kernel, bias, channel_input, height,
                                                width, kernel_height, kernel_width, stride_width,
                                                stride_height, channel_output, fix_position,
                                                in_dilation_width, in_dilation_height, 1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int4x2_t* src,
                                                     int8* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int in_dilation_width,
                                                     int in_dilation_height) {
  __mlvm_stream_conv_dilation_f32_fix4_fix8(dst, src, kernel, channel_input, height,
                                            width, kernel_height, kernel_width, stride_width,
                                            stride_height, channel_output, fix_position,
                                            in_dilation_width, in_dilation_height, 1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int4x2_t* src,
                                                     int8* kernel,
                                                     float* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int in_dilation_width,
                                                     int in_dilation_height) {
  __mlvm_stream_conv_dilation_f32_fix4_fix8_f32(dst, src, kernel, bias, channel_input, height,
                                                width, kernel_height, kernel_width, stride_width,
                                                stride_height, channel_output, fix_position,
                                                in_dilation_width, in_dilation_height, 1, 1);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int4x2_t* src,
                                                     int8* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int in_dilation_width,
                                                     int in_dilation_height,
                                                     int out_dilation_width,
                                                     int out_dilation_height) {
  __mlvm_stream_conv_dilation_f16_fix4_fix8(dst, src, kernel, channel_input, height,
                                            width, kernel_height, kernel_width, stride_width,
                                            stride_height, channel_output, fix_position,
                                            in_dilation_width, in_dilation_height,
                                            out_dilation_width, out_dilation_height);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int4x2_t* src,
                                                     int8* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int in_dilation_width,
                                                     int in_dilation_height,
                                                     int out_dilation_width,
                                                     int out_dilation_height) {
  __mlvm_stream_conv_dilation_f32_fix4_fix8(dst, src, kernel, channel_input, height,
                                            width, kernel_height, kernel_width, stride_width,
                                            stride_height, channel_output, fix_position,
                                            in_dilation_width, in_dilation_height,
                                            out_dilation_width, out_dilation_height);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int4x2_t* src,
                                                     int16* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position) {
  __mlvm_stream_conv_dilation_f16_fix4_fix16(dst, src, kernel, channel_input, height,
                                             width, kernel_height, kernel_width, stride_width,
                                             stride_height, channel_output, fix_position,
                                             1, 1, 1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int4x2_t* src,
                                                     int16* kernel,
                                                     half* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position) {
  __mlvm_stream_conv_dilation_f16_fix4_fix16_f16(dst, src, kernel, bias, channel_input, height,
                                                 width, kernel_height, kernel_width, stride_width,
                                                 stride_height, channel_output, fix_position,
                                                 1, 1, 1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int4x2_t* src,
                                                     int16* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position) {
  __mlvm_stream_conv_dilation_f32_fix4_fix16(dst, src, kernel, channel_input, height,
                                             width, kernel_height, kernel_width, stride_width,
                                             stride_height, channel_output, fix_position,
                                             1, 1, 1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int4x2_t* src,
                                                     int16* kernel,
                                                     float* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position) {
  __mlvm_stream_conv_dilation_f32_fix4_fix16_f32(dst, src, kernel, bias, channel_input, height,
                                                 width, kernel_height, kernel_width, stride_width,
                                                 stride_height, channel_output, fix_position,
                                                 1, 1, 1, 1);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int4x2_t* src,
                                                     int16* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int in_dilation_width,
                                                     int in_dilation_height) {
  __mlvm_stream_conv_dilation_f16_fix4_fix16(dst, src, kernel, channel_input, height,
                                             width, kernel_height, kernel_width, stride_width,
                                             stride_height, channel_output, fix_position,
                                             in_dilation_width, in_dilation_height, 1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int4x2_t* src,
                                                     int16* kernel,
                                                     half* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int in_dilation_width,
                                                     int in_dilation_height) {
  __mlvm_stream_conv_dilation_f16_fix4_fix16_f16(dst, src, kernel, bias, channel_input, height,
                                                 width, kernel_height, kernel_width, stride_width,
                                                 stride_height, channel_output, fix_position,
                                                 in_dilation_width, in_dilation_height, 1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int4x2_t* src,
                                                     int16* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int in_dilation_width,
                                                     int in_dilation_height) {
  __mlvm_stream_conv_dilation_f32_fix4_fix16(dst, src, kernel, channel_input, height,
                                             width, kernel_height, kernel_width, stride_width,
                                             stride_height, channel_output, fix_position,
                                             in_dilation_width, in_dilation_height, 1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int4x2_t* src,
                                                     int16* kernel,
                                                     float* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int in_dilation_width,
                                                     int in_dilation_height) {
  __mlvm_stream_conv_dilation_f32_fix4_fix16_f32(dst, src, kernel, bias, channel_input, height,
                                                 width, kernel_height, kernel_width, stride_width,
                                                 stride_height, channel_output, fix_position,
                                                 in_dilation_width, in_dilation_height, 1, 1);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int4x2_t* src,
                                                     int16* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int in_dilation_width,
                                                     int in_dilation_height,
                                                     int out_dilation_width,
                                                     int out_dilation_height) {
  __mlvm_stream_conv_dilation_f16_fix4_fix16(dst, src, kernel, channel_input, height,
                                             width, kernel_height, kernel_width, stride_width,
                                             stride_height, channel_output, fix_position,
                                             in_dilation_width, in_dilation_height,
                                             out_dilation_width, out_dilation_height);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int4x2_t* src,
                                                     int16* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int in_dilation_width,
                                                     int in_dilation_height,
                                                     int out_dilation_width,
                                                     int out_dilation_height) {
  __mlvm_stream_conv_dilation_f32_fix4_fix16(dst, src, kernel, channel_input, height,
                                             width, kernel_height, kernel_width, stride_width,
                                             stride_height, channel_output, fix_position,
                                             in_dilation_width, in_dilation_height,
                                             out_dilation_width, out_dilation_height);
}
#endif  // (__BANG_ARCH__) >= 300 && (__BANG_ARCH__) != 303 && (__BANG_ARCH__ != 306)

// --------------------------------------------------------------------------------
// Bang C/C++ math function: stream conv parital sum operation
// --------------------------------------------------------------------------------
//   | dst-type |   src-type    |  kernel-type | partial-type |  __BANG_ARCH__ |
//   +----------+---------------+--------------+--------------+-------------------------+
//   |   half   |   int4        |  int4        |    half      |     >= 200     |
//   |   half   |   int8        |  int4        |    half      |     >= 200     |
//   |   half   |   int8        |  int8        |    half      |     >= 200     |
//   |   half   |   int16       |  int8        |    half      |     >= 200     |
//   |   half   |   int16       |  int16       |    half      |     >= 200     |
//   |   float  |   int4        |  int4        |    float     |     >= 200     |
//   |   float  |   int8        |  int4        |    float     |     >= 200     |
//   |   float  |   int8        |  int8        |    float     |     >= 200     |
//   |   float  |   int16       |  int8        |    float     |     >= 200     |
//   |   float  |   int16       |  int16       |    float     |     >= 200     |
//   |   half   |   int16       |  int4        |    half      |     >= 200     |
//   |   float  |   int16       |  int4        |    float     |     >= 200     |
//   |   half   |   int4        |  int8        |    half      |     >= 300     |
//   |   float  |   int4        |  int8        |    float     |     >= 300     |
//   |   half   |   int4        |  int16       |    half      |     >= 300     |
//   |   float  |   int4        |  int16       |    float     |     >= 300     |
//   |   float  |   half        |  half        |    float     |     >= 372     |
//   |   float  |   half        |  float       |    float     |     >= 372     |
//   |   float  |   float       |  half        |    float     |     >= 372     |
//   |   float  |   float       |  float       |    float     |     >= 372     |
//   |   float  |   bfloat16_t  |  bfloat16_t  |    float     |     >= 372     |
//   |   float  |   bfloat16_t  |  float       |    float     |     >= 372     |
//   |   float  |   float       |  bfloat16_t  |    float     |     >= 372     |
// --------------------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int8* src,
                                                             int8* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position) {
  __mlvm_stream_conv_partial_f16_fix8_fix8_f16(dst, src, kernel, partial,
                                               channel_input, height, width,
                                               kernel_height, kernel_width,
                                               stride_width, stride_height,
                                               channel_output, fix_position);

}
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int16* src,
                                                             int8* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position) {
  __mlvm_stream_conv_partial_f16_fix16_fix8_f16(dst, src, kernel, partial,
                                                channel_input, height, width,
                                                kernel_height, kernel_width,
                                                stride_width, stride_height,
                                                channel_output, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int16* src,
                                                             int16* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position) {
  __mlvm_stream_conv_partial_f16_fix16_fix16_f16(dst, src, kernel, partial,
                                                 channel_input, height, width,
                                                 kernel_height, kernel_width,
                                                 stride_width, stride_height,
                                                 channel_output, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int8* src,
                                                             int8* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position) {
  __mlvm_stream_conv_partial_f32_fix8_fix8_f32(dst, src, kernel, partial,
                                               channel_input, height, width,
                                               kernel_height, kernel_width,
                                               stride_width, stride_height,
                                               channel_output, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int16* src,
                                                             int8* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position) {
  __mlvm_stream_conv_partial_f32_fix16_fix8_f32(dst, src, kernel, partial,
                                                channel_input, height, width,
                                                kernel_height, kernel_width,
                                                stride_width, stride_height,
                                                channel_output, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int16* src,
                                                             int16* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position) {
  __mlvm_stream_conv_partial_f32_fix16_fix16_f32(dst, src, kernel, partial,
                                                 channel_input, height, width,
                                                 kernel_height, kernel_width,
                                                 stride_width, stride_height,
                                                 channel_output, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int8* src,
                                                             int8* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int dilation_width,
                                                             int dilation_height) {
  __mlvm_stream_conv_partial_f16_int8_int8_f16_dilation(dst, src, kernel, partial,
                                                        channel_input, height, width,
                                                        kernel_height, kernel_width,
                                                        stride_width, stride_height,
                                                        channel_output, fix_position,
                                                        dilation_width, dilation_height);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int16* src,
                                                             int8* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int dilation_width,
                                                             int dilation_height) {
  __mlvm_stream_conv_partial_f16_int16_int8_f16_dilation(dst, src, kernel, partial,
                                                         channel_input, height, width,
                                                         kernel_height, kernel_width,
                                                         stride_width, stride_height,
                                                         channel_output, fix_position,
                                                         dilation_width, dilation_height);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int16* src,
                                                             int16* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int dilation_width,
                                                             int dilation_height) {
  __mlvm_stream_conv_partial_f16_int16_int16_f16_dilation(dst, src, kernel, partial,
                                                          channel_input, height, width,
                                                          kernel_height, kernel_width,
                                                          stride_width, stride_height,
                                                          channel_output, fix_position,
                                                          dilation_width, dilation_height);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int8* src,
                                                             int8* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int dilation_width,
                                                             int dilation_height) {
  __mlvm_stream_conv_partial_f32_int8_int8_f32_dilation(dst, src, kernel, partial,
                                                        channel_input, height, width,
                                                        kernel_height, kernel_width,
                                                        stride_width, stride_height,
                                                        channel_output, fix_position,
                                                        dilation_width, dilation_height);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int16* src,
                                                             int8* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int dilation_width,
                                                             int dilation_height) {
  __mlvm_stream_conv_partial_f32_int16_int8_f32_dilation(dst, src, kernel, partial,
                                                         channel_input, height, width,
                                                         kernel_height, kernel_width,
                                                         stride_width, stride_height,
                                                         channel_output, fix_position,
                                                         dilation_width, dilation_height);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int16* src,
                                                             int16* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int dilation_width,
                                                             int dilation_height) {
  __mlvm_stream_conv_partial_f32_int16_int16_f32_dilation(dst, src, kernel, partial,
                                                          channel_input, height, width,
                                                          kernel_height, kernel_width,
                                                          stride_width, stride_height,
                                                          channel_output, fix_position,
                                                          dilation_width, dilation_height);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int4x2_t* src,
                                                             int4x2_t* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position) {
  __mlvm_stream_conv_partial_dilation_f16_fix4_fix4_f16(dst, src, kernel, partial, channel_input,
                                                        height, width, kernel_height, kernel_width,
                                                        stride_width, stride_height, channel_output,
                                                        fix_position, 1, 1, 1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int4x2_t* src,
                                                             int4x2_t* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position) {
  __mlvm_stream_conv_partial_dilation_f32_fix4_fix4_f32(dst, src, kernel, partial, channel_input,
                                                        height, width, kernel_height, kernel_width,
                                                        stride_width, stride_height, channel_output,
                                                        fix_position, 1, 1, 1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int8* src,
                                                             int4x2_t* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position) {
  __mlvm_stream_conv_partial_dilation_f16_fix8_fix4_f16(dst, src, kernel, partial, channel_input,
                                                        height, width, kernel_height, kernel_width,
                                                        stride_width, stride_height, channel_output,
                                                        fix_position, 1, 1, 1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int8* src,
                                                             int4x2_t* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position) {
  __mlvm_stream_conv_partial_dilation_f32_fix8_fix4_f32(dst, src, kernel, partial, channel_input,
                                                        height, width, kernel_height, kernel_width,
                                                        stride_width, stride_height, channel_output,
                                                        fix_position, 1, 1, 1, 1);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int4x2_t* src,
                                                             int4x2_t* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int in_dilation_width,
                                                             int in_dilation_height) {
  __mlvm_stream_conv_partial_dilation_f16_fix4_fix4_f16(dst, src, kernel, partial, channel_input,
                                                        height, width, kernel_height, kernel_width,
                                                        stride_width, stride_height, channel_output,
                                                        fix_position, in_dilation_width, in_dilation_height,
                                                        1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int4x2_t* src,
                                                             int4x2_t* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int in_dilation_width,
                                                             int in_dilation_height) {
  __mlvm_stream_conv_partial_dilation_f32_fix4_fix4_f32(dst, src, kernel, partial, channel_input,
                                                        height, width, kernel_height, kernel_width,
                                                        stride_width, stride_height, channel_output,
                                                        fix_position, in_dilation_width, in_dilation_height,
                                                        1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int8* src,
                                                             int4x2_t* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int in_dilation_width,
                                                             int in_dilation_height) {
  __mlvm_stream_conv_partial_dilation_f16_fix8_fix4_f16(dst, src, kernel, partial, channel_input,
                                                        height, width, kernel_height, kernel_width,
                                                        stride_width, stride_height, channel_output,
                                                        fix_position, in_dilation_width, in_dilation_height,
                                                        1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int8* src,
                                                             int4x2_t* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int in_dilation_width,
                                                             int in_dilation_height) {
  __mlvm_stream_conv_partial_dilation_f32_fix8_fix4_f32(dst, src, kernel, partial, channel_input,
                                                        height, width, kernel_height, kernel_width,
                                                        stride_width, stride_height, channel_output,
                                                        fix_position, in_dilation_width, in_dilation_height,
                                                        1, 1);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int4x2_t* src,
                                                             int4x2_t* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int in_dilation_width,
                                                             int in_dilation_height,
                                                             int out_dilation_width,
                                                             int out_dilation_height) {
  __mlvm_stream_conv_partial_dilation_f16_fix4_fix4_f16(dst, src, kernel, partial, channel_input,
                                                        height, width, kernel_height, kernel_width,
                                                        stride_width, stride_height, channel_output,
                                                        fix_position, in_dilation_width, in_dilation_height,
                                                        out_dilation_width, out_dilation_height);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int4x2_t* src,
                                                             int4x2_t* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int in_dilation_width,
                                                             int in_dilation_height,
                                                             int out_dilation_width,
                                                             int out_dilation_height) {
   __mlvm_stream_conv_partial_dilation_f32_fix4_fix4_f32(dst, src, kernel, partial, channel_input,
                                                        height, width, kernel_height, kernel_width,
                                                        stride_width, stride_height, channel_output,
                                                        fix_position, in_dilation_width, in_dilation_height,
                                                        out_dilation_width, out_dilation_height);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int8* src,
                                                             int4x2_t* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int in_dilation_width,
                                                             int in_dilation_height,
                                                             int out_dilation_width,
                                                             int out_dilation_height) {
  __mlvm_stream_conv_partial_dilation_f16_fix8_fix4_f16(dst, src, kernel, partial, channel_input,
                                                        height, width, kernel_height, kernel_width,
                                                        stride_width, stride_height, channel_output,
                                                        fix_position, in_dilation_width, in_dilation_height,
                                                        out_dilation_width, out_dilation_height);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int8* src,
                                                             int4x2_t* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int in_dilation_width,
                                                             int in_dilation_height,
                                                             int out_dilation_width,
                                                             int out_dilation_height) {
  __mlvm_stream_conv_partial_dilation_f32_fix8_fix4_f32(dst, src, kernel, partial, channel_input,
                                                        height, width, kernel_height, kernel_width,
                                                        stride_width, stride_height, channel_output,
                                                        fix_position, in_dilation_width, in_dilation_height,
                                                        out_dilation_width, out_dilation_height);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int16* src,
                                                             int4x2_t* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position) {
  __mlvm_stream_conv_partial_dilation_f16_fix16_fix4_f16(dst, src, kernel, partial, channel_input,
                                                         height, width, kernel_height, kernel_width,
                                                         stride_width, stride_height, channel_output,
                                                         fix_position, 1, 1, 1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int16* src,
                                                             int4x2_t* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position) {
  __mlvm_stream_conv_partial_dilation_f32_fix16_fix4_f32(dst, src, kernel, partial, channel_input,
                                                         height, width, kernel_height, kernel_width,
                                                         stride_width, stride_height, channel_output,
                                                         fix_position, 1, 1, 1, 1);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int16* src,
                                                             int4x2_t* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int in_dilation_width,
                                                             int in_dilation_height) {
  __mlvm_stream_conv_partial_dilation_f16_fix16_fix4_f16(dst, src, kernel, partial, channel_input,
                                                         height, width, kernel_height, kernel_width,
                                                         stride_width, stride_height, channel_output,
                                                         fix_position, in_dilation_width, in_dilation_height,
                                                         1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int16* src,
                                                             int4x2_t* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int in_dilation_width,
                                                             int in_dilation_height) {
  __mlvm_stream_conv_partial_dilation_f32_fix16_fix4_f32(dst, src, kernel, partial, channel_input,
                                                         height, width, kernel_height, kernel_width,
                                                         stride_width, stride_height, channel_output,
                                                         fix_position, in_dilation_width, in_dilation_height,
                                                         1, 1);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int16* src,
                                                             int4x2_t* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int in_dilation_width,
                                                             int in_dilation_height,
                                                             int out_dilation_width,
                                                             int out_dilation_height) {
  __mlvm_stream_conv_partial_dilation_f16_fix16_fix4_f16(dst, src, kernel, partial, channel_input,
                                                         height, width, kernel_height, kernel_width,
                                                         stride_width, stride_height, channel_output,
                                                         fix_position, in_dilation_width, in_dilation_height,
                                                         out_dilation_width, out_dilation_height);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int16* src,
                                                             int4x2_t* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int in_dilation_width,
                                                             int in_dilation_height,
                                                             int out_dilation_width,
                                                             int out_dilation_height) {
  __mlvm_stream_conv_partial_dilation_f32_fix16_fix4_f32(dst, src, kernel, partial, channel_input,
                                                         height, width, kernel_height, kernel_width,
                                                         stride_width, stride_height, channel_output,
                                                         fix_position, in_dilation_width, in_dilation_height,
                                                         out_dilation_width, out_dilation_height);
}
#endif  // __BANG_ARCH__ >= 200

#if (__BANG_ARCH__ >= 300) && (__BANG_ARCH__ != 322) && (__BANG_ARCH__ != 303) &&  \
    (__BANG_ARCH__ != 306) && (__BANG_ARCH__ != 320) && (__BANG_ARCH__ != 321)
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             half* src,
                                                             half* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output) {
  __mlvm_stream_conv_partial_f32_f16_f16_f32(dst, src, kernel, partial,
                                             channel_input, height, width,
                                             kernel_height, kernel_width,
                                             stride_width, stride_height, channel_output);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             float* src,
                                                             half* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output) {
  __mlvm_stream_conv_partial_f32_f32_f16_f32(dst, src, kernel, partial,
                                             channel_input, height, width,
                                             kernel_height, kernel_width,
                                             stride_width, stride_height, channel_output);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             half* src,
                                                             float* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output) {
  __mlvm_stream_conv_partial_f32_f16_f32_f32(dst, src, kernel, partial,
                                             channel_input, height, width,
                                             kernel_height, kernel_width,
                                             stride_width, stride_height, channel_output);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             float* src,
                                                             float* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output) {
  __mlvm_stream_conv_partial_f32_f32_f32_f32(dst, src, kernel, partial,
                                             channel_input, height, width,
                                             kernel_height, kernel_width,
                                             stride_width, stride_height, channel_output);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             bfloat16_t* src,
                                                             bfloat16_t* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output) {
  __mlvm_stream_conv_partial_f32_bf16_bf16_f32(dst, src, kernel, partial,
                                               channel_input, height, width,
                                               kernel_height, kernel_width,
                                               stride_width, stride_height, channel_output);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             float* src,
                                                             bfloat16_t* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output) {
  __mlvm_stream_conv_partial_f32_f32_bf16_f32(dst, src, kernel, partial,
                                              channel_input, height, width,
                                              kernel_height, kernel_width,
                                              stride_width, stride_height, channel_output);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             bfloat16_t* src,
                                                             float* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output) {
  __mlvm_stream_conv_partial_f32_bf16_f32_f32(dst, src, kernel, partial,
                                              channel_input, height, width,
                                              kernel_height, kernel_width,
                                              stride_width, stride_height, channel_output);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             half* src,
                                                             half* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int indilation_width,
                                                             int indilation_height,
                                                             int outdilation_width,
                                                             int outdilation_height) {
  __mlvm_stream_conv_partial_dilation_f32_f16_f16_f32(dst, src, kernel, partial,
                                                      channel_input, height, width,
                                                      kernel_height, kernel_width,
                                                      stride_width, stride_height, channel_output,
                                                      indilation_width, indilation_height,
                                                      outdilation_width, outdilation_height);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             float* src,
                                                             half* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int indilation_width,
                                                             int indilation_height,
                                                             int outdilation_width,
                                                             int outdilation_height) {
  __mlvm_stream_conv_partial_dilation_f32_f32_f16_f32(dst, src, kernel, partial,
                                                      channel_input, height, width,
                                                      kernel_height, kernel_width,
                                                      stride_width, stride_height, channel_output,
                                                      indilation_width, indilation_height,
                                                      outdilation_width, outdilation_height);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             half* src,
                                                             float* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int indilation_width,
                                                             int indilation_height,
                                                             int outdilation_width,
                                                             int outdilation_height) {
  __mlvm_stream_conv_partial_dilation_f32_f16_f32_f32(dst, src, kernel, partial,
                                                      channel_input, height, width,
                                                      kernel_height, kernel_width,
                                                      stride_width, stride_height, channel_output,
                                                      indilation_width, indilation_height,
                                                      outdilation_width, outdilation_height);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             float* src,
                                                             float* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int indilation_width,
                                                             int indilation_height,
                                                             int outdilation_width,
                                                             int outdilation_height) {
  __mlvm_stream_conv_partial_dilation_f32_f32_f32_f32(dst, src, kernel, partial,
                                                      channel_input, height, width,
                                                      kernel_height, kernel_width,
                                                      stride_width, stride_height, channel_output,
                                                      indilation_width, indilation_height,
                                                      outdilation_width, outdilation_height);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             bfloat16_t* src,
                                                             bfloat16_t* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int indilation_width,
                                                             int indilation_height,
                                                             int outdilation_width,
                                                             int outdilation_height) {
  __mlvm_stream_conv_partial_dilation_f32_bf16_bf16_f32(dst, src, kernel, partial,
                                                        channel_input, height, width,
                                                        kernel_height, kernel_width,
                                                        stride_width, stride_height, channel_output,
                                                        indilation_width, indilation_height,
                                                        outdilation_width, outdilation_height);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             float* src,
                                                             bfloat16_t* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int indilation_width,
                                                             int indilation_height,
                                                             int outdilation_width,
                                                             int outdilation_height) {
  __mlvm_stream_conv_partial_dilation_f32_f32_bf16_f32(dst, src, kernel, partial,
                                                       channel_input, height, width,
                                                       kernel_height, kernel_width,
                                                       stride_width, stride_height, channel_output,
                                                       indilation_width, indilation_height,
                                                       outdilation_width, outdilation_height);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             bfloat16_t* src,
                                                             float* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int indilation_width,
                                                             int indilation_height,
                                                             int outdilation_width,
                                                             int outdilation_height) {
  __mlvm_stream_conv_partial_dilation_f32_bf16_f32_f32(dst, src, kernel, partial,
                                                       channel_input, height, width,
                                                       kernel_height, kernel_width,
                                                       stride_width, stride_height, channel_output,
                                                       indilation_width, indilation_height,
                                                       outdilation_width, outdilation_height);
}

#endif // (__BANG_ARCH__ >= 300) && (__BANG_ARCH__ != 322) && (__BANG_ARCH__ != 303) && (__BANG_ARCH__ != 306) && (__BANG_ARCH__ != 320) && (__BANG_ARCH__ != 321)

#if (__BANG_ARCH__ >= 300) && (__BANG_ARCH__ != 303) && (__BANG_ARCH__ != 306)
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int4x2_t* src,
                                                             int8* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position) {
  __mlvm_stream_conv_partial_dilation_f16_fix4_fix8_f16(dst, src, kernel, partial, channel_input,
                                                        height, width, kernel_height, kernel_width,
                                                        stride_width, stride_height, channel_output,
                                                        fix_position, 1, 1, 1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int4x2_t* src,
                                                             int8* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position) {
  __mlvm_stream_conv_partial_dilation_f32_fix4_fix8_f32(dst, src, kernel, partial, channel_input,
                                                        height, width, kernel_height, kernel_width,
                                                        stride_width, stride_height, channel_output,
                                                        fix_position, 1, 1, 1, 1);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int4x2_t* src,
                                                             int8* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int in_dilation_width,
                                                             int in_dilation_height) {
  __mlvm_stream_conv_partial_dilation_f16_fix4_fix8_f16(dst, src, kernel, partial, channel_input,
                                                        height, width, kernel_height, kernel_width,
                                                        stride_width, stride_height, channel_output,
                                                        fix_position, in_dilation_width, in_dilation_height,
                                                        1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int4x2_t* src,
                                                             int8* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int in_dilation_width,
                                                             int in_dilation_height) {
  __mlvm_stream_conv_partial_dilation_f32_fix4_fix8_f32(dst, src, kernel, partial, channel_input,
                                                        height, width, kernel_height, kernel_width,
                                                        stride_width, stride_height, channel_output,
                                                        fix_position, in_dilation_width, in_dilation_height,
                                                        1, 1);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int4x2_t* src,
                                                             int8* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int in_dilation_width,
                                                             int in_dilation_height,
                                                             int out_dilation_width,
                                                             int out_dilation_height) {
  __mlvm_stream_conv_partial_dilation_f16_fix4_fix8_f16(dst, src, kernel, partial, channel_input,
                                                        height, width, kernel_height, kernel_width,
                                                        stride_width, stride_height, channel_output,
                                                        fix_position, in_dilation_width, in_dilation_height,
                                                        out_dilation_width, out_dilation_height);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int4x2_t* src,
                                                             int8* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int in_dilation_width,
                                                             int in_dilation_height,
                                                             int out_dilation_width,
                                                             int out_dilation_height) {
  __mlvm_stream_conv_partial_dilation_f32_fix4_fix8_f32(dst, src, kernel, partial, channel_input,
                                                        height, width, kernel_height, kernel_width,
                                                        stride_width, stride_height, channel_output,
                                                        fix_position, in_dilation_width, in_dilation_height,
                                                        out_dilation_width, out_dilation_height);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int4x2_t* src,
                                                             int16* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position) {
  __mlvm_stream_conv_partial_dilation_f16_fix4_fix16_f16(dst, src, kernel, partial, channel_input,
                                                         height, width, kernel_height, kernel_width,
                                                         stride_width, stride_height, channel_output,
                                                         fix_position, 1, 1, 1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int4x2_t* src,
                                                             int16* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position) {
  __mlvm_stream_conv_partial_dilation_f32_fix4_fix16_f32(dst, src, kernel, partial, channel_input,
                                                         height, width, kernel_height, kernel_width,
                                                         stride_width, stride_height, channel_output,
                                                         fix_position, 1, 1, 1, 1);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int4x2_t* src,
                                                             int16* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int in_dilation_width,
                                                             int in_dilation_height) {
  __mlvm_stream_conv_partial_dilation_f16_fix4_fix16_f16(dst, src, kernel, partial, channel_input,
                                                         height, width, kernel_height, kernel_width,
                                                         stride_width, stride_height, channel_output,
                                                         fix_position, in_dilation_width, in_dilation_height,
                                                         1, 1);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int4x2_t* src,
                                                             int16* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int in_dilation_width,
                                                             int in_dilation_height) {
  __mlvm_stream_conv_partial_dilation_f32_fix4_fix16_f32(dst, src, kernel, partial, channel_input,
                                                         height, width, kernel_height, kernel_width,
                                                         stride_width, stride_height, channel_output,
                                                         fix_position, in_dilation_width, in_dilation_height,
                                                         1, 1);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int4x2_t* src,
                                                             int16* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int in_dilation_width,
                                                             int in_dilation_height,
                                                             int out_dilation_width,
                                                             int out_dilation_height) {
  __mlvm_stream_conv_partial_dilation_f16_fix4_fix16_f16(dst, src, kernel, partial, channel_input,
                                                         height, width, kernel_height, kernel_width,
                                                         stride_width, stride_height, channel_output,
                                                         fix_position, in_dilation_width, in_dilation_height,
                                                         out_dilation_width, out_dilation_height);
}
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int4x2_t* src,
                                                             int16* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int in_dilation_width,
                                                             int in_dilation_height,
                                                             int out_dilation_width,
                                                             int out_dilation_height) {
  __mlvm_stream_conv_partial_dilation_f32_fix4_fix16_f32(dst, src, kernel, partial, channel_input,
                                                         height, width, kernel_height, kernel_width,
                                                         stride_width, stride_height, channel_output,
                                                         fix_position, in_dilation_width, in_dilation_height,
                                                         out_dilation_width, out_dilation_height);
}
#endif  // (__BANG_ARCH__ >= 300) && (__BANG_ARCH__ != 392) && (__BANG_ARCH__ != 303) && (__BANG_ARCH__ != 306)

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream structurally sparse operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 392

static __mlu_func__ __mlu_builtin__ void __bang_conv_sparse(float* dst,
                                                            float* src,
                                                            float* kernel,
                                                            int channel_input,
                                                            int height,
                                                            int width,
                                                            int kernel_height,
                                                            int kernel_width,
                                                            int stride_width,
                                                            int stride_height,
                                                            int channel_output) {
  __mlvm_stream_conv_sparse_f32_f32_f32(dst,
                                        src,
                                        kernel,
                                        channel_input,
                                        height,
                                        width,
                                        kernel_height,
                                        kernel_width,
                                        stride_width,
                                        stride_height,
                                        channel_output);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv_sparse(float* dst,
                                                            half* src,
                                                            half* kernel,
                                                            int channel_input,
                                                            int height,
                                                            int width,
                                                            int kernel_height,
                                                            int kernel_width,
                                                            int stride_width,
                                                            int stride_height,
                                                            int channel_output) {
  __mlvm_stream_conv_sparse_f32_f16_f16(dst,
                                        src,
                                        kernel,
                                        channel_input,
                                        height,
                                        width,
                                        kernel_height,
                                        kernel_width,
                                        stride_width,
                                        stride_height,
                                        channel_output);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv_sparse(float* dst,
                                                            int8* src,
                                                            int8* kernel,
                                                            int channel_input,
                                                            int height,
                                                            int width,
                                                            int kernel_height,
                                                            int kernel_width,
                                                            int stride_width,
                                                            int stride_height,
                                                            int channel_output,
                                                            int fix_position) {
  __mlvm_stream_conv_sparse_f32_fix8_fix8(dst,
                                          src,
                                          kernel,
                                          channel_input,
                                          height,
                                          width,
                                          kernel_height,
                                          kernel_width,
                                          stride_width,
                                          stride_height,
                                          channel_output,
                                          fix_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv_sparse(float* dst,
                                                            int8* src,
                                                            int16* kernel,
                                                            int channel_input,
                                                            int height,
                                                            int width,
                                                            int kernel_height,
                                                            int kernel_width,
                                                            int stride_width,
                                                            int stride_height,
                                                            int channel_output,
                                                            int fix_position) {
  __mlvm_stream_conv_sparse_f32_fix8_fix16(dst,
                                           src,
                                           kernel,
                                           channel_input,
                                           height,
                                           width,
                                           kernel_height,
                                           kernel_width,
                                           stride_width,
                                           stride_height,
                                           channel_output,
                                           fix_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv_sparse(float* dst,
                                                            int16* src,
                                                            int8* kernel,
                                                            int channel_input,
                                                            int height,
                                                            int width,
                                                            int kernel_height,
                                                            int kernel_width,
                                                            int stride_width,
                                                            int stride_height,
                                                            int channel_output,
                                                            int fix_position) {
  __mlvm_stream_conv_sparse_f32_fix16_fix8(dst,
                                           src,
                                           kernel,
                                           channel_input,
                                           height,
                                           width,
                                           kernel_height,
                                           kernel_width,
                                           stride_width,
                                           stride_height,
                                           channel_output,
                                           fix_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv_sparse(float* dst,
                                                            int16* src,
                                                            int16* kernel,
                                                            int channel_input,
                                                            int height,
                                                            int width,
                                                            int kernel_height,
                                                            int kernel_width,
                                                            int stride_width,
                                                            int stride_height,
                                                            int channel_output,
                                                            int fix_position) {
  __mlvm_stream_conv_sparse_f32_fix16_fix16(dst,
                                            src,
                                            kernel,
                                            channel_input,
                                            height,
                                            width,
                                            kernel_height,
                                            kernel_width,
                                            stride_width,
                                            stride_height,
                                            channel_output,
                                            fix_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv_sparse(half* dst,
                                                            int8* src,
                                                            int8* kernel,
                                                            int channel_input,
                                                            int height,
                                                            int width,
                                                            int kernel_height,
                                                            int kernel_width,
                                                            int stride_width,
                                                            int stride_height,
                                                            int channel_output,
                                                            int fix_position) {
  __mlvm_stream_conv_sparse_f16_fix8_fix8(dst,
                                          src,
                                          kernel,
                                          channel_input,
                                          height,
                                          width,
                                          kernel_height,
                                          kernel_width,
                                          stride_width,
                                          stride_height,
                                          channel_output,
                                          fix_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv_sparse(half* dst,
                                                            int8* src,
                                                            int16* kernel,
                                                            int channel_input,
                                                            int height,
                                                            int width,
                                                            int kernel_height,
                                                            int kernel_width,
                                                            int stride_width,
                                                            int stride_height,
                                                            int channel_output,
                                                            int fix_position) {
  __mlvm_stream_conv_sparse_f16_fix8_fix16(dst,
                                           src,
                                           kernel,
                                           channel_input,
                                           height,
                                           width,
                                           kernel_height,
                                           kernel_width,
                                           stride_width,
                                           stride_height,
                                           channel_output,
                                           fix_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv_sparse(half* dst,
                                                            int16* src,
                                                            int8* kernel,
                                                            int channel_input,
                                                            int height,
                                                            int width,
                                                            int kernel_height,
                                                            int kernel_width,
                                                            int stride_width,
                                                            int stride_height,
                                                            int channel_output,
                                                            int fix_position) {
  __mlvm_stream_conv_sparse_f16_fix16_fix8(dst,
                                           src,
                                           kernel,
                                           channel_input,
                                           height,
                                           width,
                                           kernel_height,
                                           kernel_width,
                                           stride_width,
                                           stride_height,
                                           channel_output,
                                           fix_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv_sparse(half* dst,
                                                            int16* src,
                                                            int16* kernel,
                                                            int channel_input,
                                                            int height,
                                                            int width,
                                                            int kernel_height,
                                                            int kernel_width,
                                                            int stride_width,
                                                            int stride_height,
                                                            int channel_output,
                                                            int fix_position) {
  __mlvm_stream_conv_sparse_f16_fix16_fix16(dst,
                                            src,
                                            kernel,
                                            channel_input,
                                            height,
                                            width,
                                            kernel_height,
                                            kernel_width,
                                            stride_width,
                                            stride_height,
                                            channel_output,
                                            fix_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv_sparse(int16* dst,
                                                            int8* src,
                                                            int8* kernel,
                                                            int channel_input,
                                                            int height,
                                                            int width,
                                                            int kernel_height,
                                                            int kernel_width,
                                                            int stride_width,
                                                            int stride_height,
                                                            int channel_output,
                                                            int fix_position) {
  __mlvm_stream_conv_sparse_fix16_fix8_fix8(dst,
                                            src,
                                            kernel,
                                            channel_input,
                                            height,
                                            width,
                                            kernel_height,
                                            kernel_width,
                                            stride_width,
                                            stride_height,
                                            channel_output,
                                            fix_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv_sparse(int16* dst,
                                                            int16* src,
                                                            int8* kernel,
                                                            int channel_input,
                                                            int height,
                                                            int width,
                                                            int kernel_height,
                                                            int kernel_width,
                                                            int stride_width,
                                                            int stride_height,
                                                            int channel_output,
                                                            int fix_position) {
  __mlvm_stream_conv_sparse_fix16_fix16_fix8(dst,
                                             src,
                                             kernel,
                                             channel_input,
                                             height,
                                             width,
                                             kernel_height,
                                             kernel_width,
                                             stride_width,
                                             stride_height,
                                             channel_output,
                                             fix_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_conv_sparse(int16* dst,
                                                            int16* src,
                                                            int16* kernel,
                                                            int channel_input,
                                                            int height,
                                                            int width,
                                                            int kernel_height,
                                                            int kernel_width,
                                                            int stride_width,
                                                            int stride_height,
                                                            int channel_output,
                                                            int fix_position) {
  __mlvm_stream_conv_sparse_fix16_fix16_fix16(dst,
                                              src,
                                              kernel,
                                              channel_input,
                                              height,
                                              width,
                                              kernel_height,
                                              kernel_width,
                                              stride_width,
                                              stride_height,
                                              channel_output,
                                              fix_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_union(half* dst,
                                                                     half* src,
                                                                     int input_channel,
                                                                     int src_height,
                                                                     int src_width,
                                                                     int output_channel) {
  __mlvm_stream_ssparse_filter_union_f16(dst, src, input_channel, src_height,
                                         src_width, output_channel);
}

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_union(float* dst,
                                                                     float* src,
                                                                     int input_channel,
                                                                     int src_height,
                                                                     int src_width,
                                                                     int output_channel) {
  __mlvm_stream_ssparse_filter_union_f32(dst, src, input_channel, src_height,
                                         src_width, output_channel);
}

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_union(int8* dst,
                                                                     int8* src,
                                                                     int input_channel,
                                                                     int src_height,
                                                                     int src_width,
                                                                     int output_channel) {
  __mlvm_stream_ssparse_filter_union_fix8(dst, src, input_channel, src_height,
                                          src_width, output_channel);
}

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_union(int16* dst,
                                                                     int16* src,
                                                                     int input_channel,
                                                                     int src_height,
                                                                     int src_width,
                                                                     int output_channel) {
  __mlvm_stream_ssparse_filter_union_fix16(dst, src, input_channel, src_height,
                                           src_width, output_channel);
}

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_union(int* dst,
                                                                     int* src,
                                                                     int input_channel,
                                                                     int src_height,
                                                                     int src_width,
                                                                     int output_channel) {
  __mlvm_stream_ssparse_filter_union_fix32(dst, src, input_channel, src_height,
                                           src_width, output_channel);
}

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_union(bfloat16_t* dst,
                                                                     bfloat16_t* src,
                                                                     int input_channel,
                                                                     int src_height,
                                                                     int src_width,
                                                                     int output_channel) {
  __mlvm_stream_ssparse_filter_union_bf16(dst, src, input_channel, src_height,
                                          src_width, output_channel);
}

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_index(half* dst,
                                                                     half* src,
                                                                     int input_channel,
                                                                     int src_height,
                                                                     int src_width,
                                                                     int output_channel) {
  __mlvm_stream_ssparse_filter_index_f16(dst, src, input_channel, src_height,
                                         src_width, output_channel);
}

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_index(float* dst,
                                                                     float* src,
                                                                     int input_channel,
                                                                     int src_height,
                                                                     int src_width,
                                                                     int output_channel) {
  __mlvm_stream_ssparse_filter_index_f32(dst, src, input_channel, src_height,
                                         src_width, output_channel);
}

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_index(int8* dst,
                                                                     int8* src,
                                                                     int input_channel,
                                                                     int src_height,
                                                                     int src_width,
                                                                     int output_channel) {
  __mlvm_stream_ssparse_filter_index_fix8(dst, src, input_channel, src_height,
                                          src_width, output_channel);
}

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_index(int16* dst,
                                                                     int16* src,
                                                                     int input_channel,
                                                                     int src_height,
                                                                     int src_width,
                                                                     int output_channel) {
  __mlvm_stream_ssparse_filter_index_fix16(dst, src, input_channel, src_height,
                                           src_width, output_channel);
}

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_index(int* dst,
                                                                     int* src,
                                                                     int input_channel,
                                                                     int src_height,
                                                                     int src_width,
                                                                     int output_channel) {
  __mlvm_stream_ssparse_filter_index_fix32(dst, src, input_channel, src_height,
                                           src_width, output_channel);
}

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_index(bfloat16_t* dst,
                                                                     bfloat16_t* src,
                                                                     int input_channel,
                                                                     int src_height,
                                                                     int src_width,
                                                                     int output_channel) {
  __mlvm_stream_ssparse_filter_index_bf16(dst, src, input_channel, src_height,
                                          src_width, output_channel);
}

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_union_index(half* dst,
                                                                           half* src,
                                                                           half* index,
                                                                           int input_channel,
                                                                           int src_height,
                                                                           int src_width,
                                                                           int output_channel) {
  __mlvm_stream_ssparse_filter_union_index_f16(dst, src, index, input_channel, src_height,
                                               src_width, output_channel);
}

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_union_index(float* dst,
                                                                           float* src,
                                                                           float* index,
                                                                           int input_channel,
                                                                           int src_height,
                                                                           int src_width,
                                                                           int output_channel) {
  __mlvm_stream_ssparse_filter_union_index_f32(dst, src, index, input_channel, src_height,
                                               src_width, output_channel);
}

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_union_index(int8* dst,
                                                                           int8* src,
                                                                           int8* index,
                                                                           int input_channel,
                                                                           int src_height,
                                                                           int src_width,
                                                                           int output_channel) {
  __mlvm_stream_ssparse_filter_union_index_fix8(dst, src, index, input_channel, src_height,
                                                src_width, output_channel);
}

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_union_index(int16* dst,
                                                                           int16* src,
                                                                           int16* index,
                                                                           int input_channel,
                                                                           int src_height,
                                                                           int src_width,
                                                                           int output_channel) {
  __mlvm_stream_ssparse_filter_union_index_fix16(dst, src, index, input_channel, src_height,
                                                 src_width, output_channel);
}

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_union_index(int* dst,
                                                                           int* src,
                                                                           int* index,
                                                                           int input_channel,
                                                                           int src_height,
                                                                           int src_width,
                                                                           int output_channel) {
  __mlvm_stream_ssparse_filter_union_index_fix32(dst, src, index, input_channel, src_height,
                                                 src_width, output_channel);
}

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_union_index(bfloat16_t* dst,
                                                                           bfloat16_t* src,
                                                                           bfloat16_t* index,
                                                                           int input_channel,
                                                                           int src_height,
                                                                           int src_width,
                                                                           int output_channel) {
  __mlvm_stream_ssparse_filter_union_index_bf16(dst, src, index, input_channel, src_height,
                                                src_width, output_channel);
}

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_sparse_index(half* dst,
                                                                            half* src,
                                                                            half* index,
                                                                            int input_channel,
                                                                            int src_height,
                                                                            int src_width,
                                                                            int output_channel) {
  __mlvm_stream_ssparse_filter_sparse_index_f16(dst, src, index, input_channel, src_height,
                                                src_width, output_channel);
}

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_sparse_index(float* dst,
                                                                            float* src,
                                                                            float* index,
                                                                            int input_channel,
                                                                            int src_height,
                                                                            int src_width,
                                                                            int output_channel) {
  __mlvm_stream_ssparse_filter_sparse_index_f32(dst, src, index, input_channel, src_height,
                                                src_width, output_channel);
}

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_sparse_index(int8* dst,
                                                                            int8* src,
                                                                            int8* index,
                                                                            int input_channel,
                                                                            int src_height,
                                                                            int src_width,
                                                                            int output_channel) {
  __mlvm_stream_ssparse_filter_sparse_index_fix8(dst, src, index, input_channel, src_height,
                                                 src_width, output_channel);
}

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_sparse_index(int16* dst,
                                                                            int16* src,
                                                                            int16* index,
                                                                            int input_channel,
                                                                            int src_height,
                                                                            int src_width,
                                                                            int output_channel) {
  __mlvm_stream_ssparse_filter_sparse_index_fix16(dst, src, index, input_channel, src_height,
                                                  src_width, output_channel);
}

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_sparse_index(int* dst,
                                                                            int* src,
                                                                            int* index,
                                                                            int input_channel,
                                                                            int src_height,
                                                                            int src_width,
                                                                            int output_channel) {
  __mlvm_stream_ssparse_filter_sparse_index_fix32(dst, src, index, input_channel, src_height,
                                                  src_width, output_channel);
}

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_sparse_index(bfloat16_t* dst,
                                                                            bfloat16_t* src,
                                                                            bfloat16_t* index,
                                                                            int input_channel,
                                                                            int src_height,
                                                                            int src_width,
                                                                            int output_channel) {
  __mlvm_stream_ssparse_filter_sparse_index_bf16(dst, src, index, input_channel, src_height,
                                                 src_width, output_channel);
}

#endif  // __BANG_ARCH__ >= 392

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream mlp operation
// -----------------------------------------------------------------------------
//   | dst-type | src-type | kernel-type | __BANG_ARCH__ |
//   +----------+----------+-------------+---------------+
//   |   half   |   int8   |    int8     |     >= 200    |
//   |   half   |   int16  |    int8     |     >= 200    |
//   |   half   |   int16  |    int16    |     >= 200    |
//   |   float  |   int8   |    int8     |     >= 200    |
//   |   float  |   int16  |    int8     |     >= 200    |
//   |   float  |   int16  |    int16    |     >= 200    |
//   |   int16  |   int8   |    int8     |     >= 200    |
//   |   int16  |   int16  |    int8     |     >= 200    |
//   |   int16  |   int16  |    int16    |     >= 200    |
// -----------------------------------------------------------------------------
//   | dst-type | src-type | bias-type | kernel-type | __BANG_ARCH__ |
//   +----------+----------+-----------+-------------+---------------+
//   |   half   |   half   |    half   |    half     |     <  200    |
//   |   half   |   int8   |    half   |    int8     |     >= 100    |
//   |   half   |   int16  |    half   |    int16    |     >= 200    |
//   |   half   |   int16  |    half   |    int8     |     >= 200    |
//   |   float  |   int8   |    float  |    int8     |     >= 200    |
//   |   float  |   int16  |    float  |    int8     |     >= 200    |
//   |   float  |   int16  |    float  |    int16    |     >= 200    |
//   |   int16  |   int8   |    int16  |    int8     |     >= 200    |
//   |   int16  |   int16  |    int16  |    int8     |     >= 200    |
//   |   int16  |   int16  |    int16  |    int16    |     >= 200    |
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ void __bang_mlp(half* dst,
                                                    int8* src,
                                                    int8* weight,
                                                    int height,
                                                    int width,
                                                    int fix_position) {
  __mlvm_stream_mlp_f16_fix8_fix8(dst, src, weight,
                                  height, width, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_mlp(half* dst,
                                                    int16* src,
                                                    int8* weight,
                                                    int height,
                                                    int width,
                                                    int fix_position) {
  __mlvm_stream_mlp_f16_fix16_fix8(dst, src, weight,
                                   height, width, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_mlp(half* dst,
                                                    int16* src,
                                                    int16* weight,
                                                    int height,
                                                    int width,
                                                    int fix_position) {
  __mlvm_stream_mlp_f16_fix16_fix16(dst, src, weight,
                                    height, width, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_mlp(float* dst,
                                                    int8* src,
                                                    int8* weight,
                                                    int height,
                                                    int width,
                                                    int fix_position) {
  __mlvm_stream_mlp_f32_fix8_fix8(dst, src, weight,
                                  height, width, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_mlp(float* dst,
                                                    int16* src,
                                                    int8* weight,
                                                    int height,
                                                    int width,
                                                    int fix_position) {
  __mlvm_stream_mlp_f32_fix16_fix8(dst, src, weight,
                                   height, width, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_mlp(float* dst,
                                                    int16* src,
                                                    int16* weight,
                                                    int height,
                                                    int width,
                                                    int fix_position) {
  __mlvm_stream_mlp_f32_fix16_fix16(dst, src, weight,
                                    height, width, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_mlp(int16* dst,
                                                    int8* src,
                                                    int8* weight,
                                                    int height,
                                                    int width,
                                                    int fix_position) {
  __mlvm_stream_mlp_fix16_fix8_fix8(dst, src, weight,
                                    height, width, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_mlp(int16* dst,
                                                    int16* src,
                                                    int8* weight,
                                                    int height,
                                                    int width,
                                                    int fix_position) {
  __mlvm_stream_mlp_fix16_fix16_fix8(dst, src, weight,
                                     height, width, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_mlp(int16* dst,
                                                    int16* src,
                                                    int16* weight,
                                                    int height,
                                                    int width,
                                                    int fix_position) {
  __mlvm_stream_mlp_fix16_fix16_fix16(dst, src, weight,
                                      height, width, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_mlp(half* dst,
                                                    int8* src,
                                                    half* bias,
                                                    int8* weight,
                                                    int height,
                                                    int width,
                                                    int fix_position) {
  __mlvm_stream_mlp_f16_fix8_f16_fix8(dst, src, bias, weight,
                                      height, width, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_mlp(half* dst,
                                                    int16* src,
                                                    half* bias,
                                                    int8* weight,
                                                    int height,
                                                    int width,
                                                    int fix_position) {
  __mlvm_stream_mlp_f16_fix16_f16_fix8(dst, src, bias, weight,
                                       height, width, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_mlp(half* dst,
                                                    int16* src,
                                                    half* bias,
                                                    int16* weight,
                                                    int height,
                                                    int width,
                                                    int fix_position) {
  __mlvm_stream_mlp_f16_fix16_f16_fix16(dst, src, bias, weight,
                                        height, width, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_mlp(float* dst,
                                                    int8* src,
                                                    float* bias,
                                                    int8* weight,
                                                    int height,
                                                    int width,
                                                    int fix_position) {
  __mlvm_stream_mlp_f32_fix8_f32_fix8(dst, src, bias, weight,
                                      height, width, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_mlp(float* dst,
                                                    int16* src,
                                                    float* bias,
                                                    int8* weight,
                                                    int height,
                                                    int width,
                                                    int fix_position) {
  __mlvm_stream_mlp_f32_fix16_f32_fix8(dst, src, bias, weight,
                                       height, width, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_mlp(float* dst,
                                                    int16* src,
                                                    float* bias,
                                                    int16* weight,
                                                    int height,
                                                    int width,
                                                    int fix_position) {
  __mlvm_stream_mlp_f32_fix16_f32_fix16(dst, src, bias, weight,
                                        height, width, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_mlp(int16* dst,
                                                    int8* src,
                                                    int16* bias,
                                                    int8* weight,
                                                    int height,
                                                    int width,
                                                    int fix_position) {
  __mlvm_stream_mlp_fix16_fix8_fix16_fix8(dst, src, bias, weight,
                                          height, width, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_mlp(int16* dst,
                                                    int16* src,
                                                    int16* bias,
                                                    int8* weight,
                                                    int height,
                                                    int width,
                                                    int fix_position) {
  __mlvm_stream_mlp_fix16_fix16_fix16_fix8(dst, src, bias, weight,
                                           height, width, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_mlp(int16* dst,
                                                    int16* src,
                                                    int16* bias,
                                                    int16* weight,
                                                    int height,
                                                    int width,
                                                    int fix_position) {
  __mlvm_stream_mlp_fix16_fix16_fix16_fix16(dst, src, bias, weight,
                                            height, width, fix_position);
}


#else  // __BANG_ARCH__ < 200

#define __mlp_f16(dst, src, bias, weight, height, width)                \
  ({ __mlvm_stream_mlp_f16_f16_f16_f16(dst, src, bias, weight, height, width); })  // NOLINT

#define __mlp_type(dst, src, bias, weight, height, width,           \
                   Type, fix_position)                              \
  __mlp_##Type(dst, src, bias, weight, height, width, fix_position)

#define __mlp_F16_F16_F16_F16(dst, src, bias, weight,                   \
                              height, width, fix_position)              \
  ({ __mlvm_stream_mlp_f16_f16_f16_f16(dst, src, bias, weight, height, width); })  // NOLINT

#define __mlp_F16_FIX16_F16_FIX16(dst, src, bias, weight,               \
                                  height, width, fix_position)          \
  ({ __mlvm_stream_mlp_f16_fix16_f16_fix16(dst, src, bias, weight,      \
                                           height, width, fix_position); \
  })

#define __mlp_F16_FIX8_F16_FIX8(dst, src, bias, weight,                 \
                                height, width, fix_position)            \
  ({ __mlvm_stream_mlp_f16_fix8_f16_fix8(dst, src, bias, weight,        \
                                         height, width, fix_position);  \
  })

#define __mlp_F16_INT8_F16_INT8(dst, src, bias, weight,                 \
                                height, width, fix_position)            \
  ({ __mlvm_stream_mlp_f16_fix8_f16_fix8(dst, src, bias, weight,        \
                                         height, width, fix_position);  \
  })

#define MLP_MACRO(_1, _2, _3, _4, _5, _6, _7, _8, NAME, ...) NAME
#define __bang_mlp(...) MLP_MACRO(__VA_ARGS__,                  \
                                  __mlp_type,                   \
                                  __mlp_type,                   \
                                  __mlp_f16, ...)(__VA_ARGS__)
#endif  // __BANG_ARCH__ >= 200
#endif // __BANG_ARCH__ != 303 && __BANG_ARCH__ != 306

#if __BANG_ARCH__ < 300
#define __POSITIVE_INF_HALF(a) ({                       \
  if (a > MAX_HALF_VALUE) {                             \
    unsigned short tmp = P_HALF_INF;                    \
    return *((half*)&tmp);                              \
  }                                                     \
})

#define __NEGATIVE_INF_HALF(a) ({                       \
  if (a < MIN_HALF_VALUE) {                             \
    unsigned short tmp = N_HALF_INF;                    \
    return *((half*)&tmp);                              \
  }                                                     \
})

#define __INF_HALF_TO_FLOAT(a) ({                       \
   if ((*((unsigned short*)&a)) == P_HALF_INF) {        \
     unsigned int tmp = 0x7F800000;                     \
     return *((float*)&tmp);                            \
   } else if ((*((unsigned short*)&a)) == N_HALF_INF) { \
     unsigned int tmp = 0xFF800000;                     \
     return *((float*)&tmp);                            \
   }                                                    \
})

#define __NAN_FLOAT_TO_INT(a)
#define __NAN_HALF_TO_INT(a)
#elif __BANG_ARCH__ == 303 || __BANG_ARCH__ == 322 || __BANG_ARCH__ == 372
#define __POSITIVE_INF_HALF(a) ({                       \
  if (a > MAX_HALF_VALUE) {                             \
    unsigned short tmp = P_HALF_INF;                    \
    return *((half*)&tmp);                              \
  }                                                     \
})

#define __NEGATIVE_INF_HALF(a) ({                       \
  if (a < MIN_HALF_VALUE) {                             \
    unsigned short tmp = N_HALF_INF;                    \
    return *((half*)&tmp);                              \
  }                                                     \
})

#define __INF_HALF_TO_FLOAT(a)
#define __NAN_FLOAT_TO_INT(a) ({                      \
  if (((*(int*)&a) & 0x7FFFFFFF) - 0x7F800000 > 0) {  \
    return 0;                                         \
  }                                                   \
})

#define __NAN_HALF_TO_INT(a) ({                      \
  if (((*(short*)&a) & 0x7FFF) - 0x7C00 > 0) {       \
    return 0;                                        \
  }                                                  \
})
#else // __BANG_ARCH__ == {306, 320, 321, 392}
#define __POSITIVE_INF_HALF(a)
#define __NEGATIVE_INF_HALF(a)
#define __INF_HALF_TO_FLOAT(a)
#define __NAN_FLOAT_TO_INT(a)
#define __NAN_HALF_TO_INT(a)
#endif

// -----------------------------------------------------------------------------
// Bang C/C++ math function: scalar convert half to int operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ int __half2int(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvti32_f16_tz(a);
}
static __mlu_func__ __mlu_builtin__ int __half2int_tz(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvti32_f16_tz(a);
}
static __mlu_func__ __mlu_builtin__ int __half2int_oz(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvti32_f16_oz(a);
}
static __mlu_func__ __mlu_builtin__ int __half2int_up(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvti32_f16_up(a);
}
static __mlu_func__ __mlu_builtin__ int __half2int_dn(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvti32_f16_dn(a);
}
static __mlu_func__ __mlu_builtin__ int __half2int_rd(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvti32_f16_rd(a);
}
#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ int __half2int_rm(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvti32_f16_rm(a);
}
static __mlu_func__ __mlu_builtin__ int __half2int_rn(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvti32_f16_rn(a);
}
#endif

// -----------------------------------------------------------------------------
// Bang C/C++ math function: scalar convert int to half operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ half __int2half(int a) {
  return __mlvm_scalar_cvtf16_s32_tz(a);
}
static __mlu_func__ __mlu_builtin__ half __int2half_tz(int a) {
  return __mlvm_scalar_cvtf16_s32_tz(a);
}
static __mlu_func__ __mlu_builtin__ half __int2half_oz(int a) {
  __POSITIVE_INF_HALF(a);
  __NEGATIVE_INF_HALF(a);
  return __mlvm_scalar_cvtf16_s32_oz(a);
}
static __mlu_func__ __mlu_builtin__ half __int2half_up(int a) {
  __POSITIVE_INF_HALF(a);
  return __mlvm_scalar_cvtf16_s32_up(a);
}
static __mlu_func__ __mlu_builtin__ half __int2half_dn(int a) {
  __NEGATIVE_INF_HALF(a);
  return __mlvm_scalar_cvtf16_s32_dn(a);
}
static __mlu_func__ __mlu_builtin__ half __int2half_rd(int a) {
  __POSITIVE_INF_HALF(a);
  __NEGATIVE_INF_HALF(a);
  return __mlvm_scalar_cvtf16_s32_rd(a);
}
#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ half __int2half_rm(int a) {
  __POSITIVE_INF_HALF(a);
  __NEGATIVE_INF_HALF(a);
  return __mlvm_scalar_cvtf16_s32_rm(a);
}

static __mlu_func__ __mlu_builtin__ half __int2half_rn(int a) {
  __POSITIVE_INF_HALF(a);
  __NEGATIVE_INF_HALF(a);
  return __mlvm_scalar_cvtf16_s32_rn(a);
}
#endif

// -----------------------------------------------------------------------------
// Bang C/C++ math function: scalar convert unsigned int to half operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ half __uint2half(unsigned int a) {
  return __mlvm_scalar_cvtf16_u32_tz(a);
}
static __mlu_func__ __mlu_builtin__ half __uint2half_tz(unsigned int a) {
  return __mlvm_scalar_cvtf16_u32_tz(a);
}
static __mlu_func__ __mlu_builtin__ half __uint2half_oz(unsigned int a) {
  __POSITIVE_INF_HALF(a);
  return __mlvm_scalar_cvtf16_u32_oz(a);
}
static __mlu_func__ __mlu_builtin__ half __uint2half_up(unsigned int a) {
  __POSITIVE_INF_HALF(a);
  return __mlvm_scalar_cvtf16_u32_up(a);
}
static __mlu_func__ __mlu_builtin__ half __uint2half_dn(unsigned int a) {
  return __mlvm_scalar_cvtf16_u32_dn(a);
}
static __mlu_func__ __mlu_builtin__ half __uint2half_rd(unsigned int a) {
  __POSITIVE_INF_HALF(a);
  return __mlvm_scalar_cvtf16_u32_rd(a);
}

#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ half __uint2half_rm(unsigned int a) {
  __POSITIVE_INF_HALF(a);
  return __mlvm_scalar_cvtf16_u32_rm(a);
}
static __mlu_func__ __mlu_builtin__ half __uint2half_rn(unsigned int a) {
  __POSITIVE_INF_HALF(a);
  return __mlvm_scalar_cvtf16_u32_rn(a);
}
#endif

static __mlu_func__ __mlu_builtin__ half __char2half(char a) {
  return __mlvm_scalar_cvtf16_s8_tz(a);
}

static __mlu_func__ __mlu_builtin__ half __char2half_tz(char a) {
  return __mlvm_scalar_cvtf16_s8_tz(a);
}

static __mlu_func__ __mlu_builtin__ half __char2half_oz(char a) {
  return __mlvm_scalar_cvtf16_s8_oz(a);
}

static __mlu_func__ __mlu_builtin__ half __char2half_up(char a) {
  return __mlvm_scalar_cvtf16_s8_up(a);
}

static __mlu_func__ __mlu_builtin__ half __char2half_dn(char a) {
  return __mlvm_scalar_cvtf16_s8_dn(a);
}

static __mlu_func__ __mlu_builtin__ half __char2half_rd(char a) {
  return __mlvm_scalar_cvtf16_s8_rd(a);
}

#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ half __char2half_rm(char a) {
  return __mlvm_scalar_cvtf16_s8_rm(a);
}

static __mlu_func__ __mlu_builtin__ half __char2half_rn(char a) {
  return __mlvm_scalar_cvtf16_s8_rn(a);
}
#endif

static __mlu_func__ __mlu_builtin__ half __uchar2half(unsigned char a) {
  return __mlvm_scalar_cvtf16_u8_tz(a);
}

static __mlu_func__ __mlu_builtin__ half __uchar2half_tz(unsigned char a) {
  return __mlvm_scalar_cvtf16_u8_tz(a);
}

static __mlu_func__ __mlu_builtin__ half __uchar2half_oz(unsigned char a) {
  return __mlvm_scalar_cvtf16_u8_oz(a);
}

static __mlu_func__ __mlu_builtin__ half __uchar2half_up(unsigned char a) {
  return __mlvm_scalar_cvtf16_u8_up(a);
}

static __mlu_func__ __mlu_builtin__ half __uchar2half_dn(unsigned char a) {
  return __mlvm_scalar_cvtf16_u8_dn(a);
}

static __mlu_func__ __mlu_builtin__ half __uchar2half_rd(unsigned char a) {
  return __mlvm_scalar_cvtf16_u8_rd(a);
}

#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ half __uchar2half_rm(unsigned char a) {
  return __mlvm_scalar_cvtf16_u8_rm(a);
}

static __mlu_func__ __mlu_builtin__ half __uchar2half_rn(unsigned char a) {
  return __mlvm_scalar_cvtf16_u8_rn(a);
}
#endif

static __mlu_func__ __mlu_builtin__ float __char2float(char a) {
  return __mlvm_scalar_cvtf32_s8_tz(a);
}

static __mlu_func__ __mlu_builtin__ float __char2float_tz(char a) {
  return __mlvm_scalar_cvtf32_s8_tz(a);
}

static __mlu_func__ __mlu_builtin__ float __char2float_oz(char a) {
  return __mlvm_scalar_cvtf32_s8_oz(a);
}

static __mlu_func__ __mlu_builtin__ float __char2float_up(char a) {
  return __mlvm_scalar_cvtf32_s8_up(a);
}

static __mlu_func__ __mlu_builtin__ float __char2float_dn(char a) {
  return __mlvm_scalar_cvtf32_s8_dn(a);
}

static __mlu_func__ __mlu_builtin__ float __char2float_rd(char a) {
  return __mlvm_scalar_cvtf32_s8_rd(a);
}

#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ float __char2float_rm(char a) {
  return __mlvm_scalar_cvtf32_s8_rm(a);
}

static __mlu_func__ __mlu_builtin__ float __char2float_rn(char a) {
  return __mlvm_scalar_cvtf32_s8_rn(a);
}
#endif

static __mlu_func__ __mlu_builtin__ float __uchar2float(unsigned char a) {
  return __mlvm_scalar_cvtf32_u8_tz(a);
}

static __mlu_func__ __mlu_builtin__ float __uchar2float_tz(unsigned char a) {
  return __mlvm_scalar_cvtf32_u8_tz(a);
}

static __mlu_func__ __mlu_builtin__ float __uchar2float_oz(unsigned char a) {
  return __mlvm_scalar_cvtf32_u8_oz(a);
}

static __mlu_func__ __mlu_builtin__ float __uchar2float_up(unsigned char a) {
  return __mlvm_scalar_cvtf32_u8_up(a);
}

static __mlu_func__ __mlu_builtin__ float __uchar2float_dn(unsigned char a) {
  return __mlvm_scalar_cvtf32_u8_dn(a);
}

static __mlu_func__ __mlu_builtin__ float __uchar2float_rd(unsigned char a) {
  return __mlvm_scalar_cvtf32_u8_rd(a);
}

#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ float __uchar2float_rm(unsigned char a) {
  return __mlvm_scalar_cvtf32_u8_rm(a);
}

static __mlu_func__ __mlu_builtin__ float __uchar2float_rn(unsigned char a) {
  return __mlvm_scalar_cvtf32_u8_rn(a);
}
#endif

// -----------------------------------------------------------------------------
// Bang C/C++ math function: scalar convert half to short operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ short __half2short(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvti16_f16_tz(a);
}

static __mlu_func__ __mlu_builtin__ short __half2short_tz(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvti16_f16_tz(a);
}
static __mlu_func__ __mlu_builtin__ short __half2short_oz(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvti16_f16_oz(a);
}
static __mlu_func__ __mlu_builtin__ short __half2short_up(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvti16_f16_up(a);
}
static __mlu_func__ __mlu_builtin__ short __half2short_dn(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvti16_f16_dn(a);
}
static __mlu_func__ __mlu_builtin__ short __half2short_rd(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvti16_f16_rd(a);
}
#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ short __half2short_rm(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvti16_f16_rm(a);
}
static __mlu_func__ __mlu_builtin__ short __half2short_rn(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvti16_f16_rn(a);
}
#endif

static __mlu_func__ __mlu_builtin__ char __half2char(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvts8_f16_tz(a);
}

static __mlu_func__ __mlu_builtin__ char __half2char_tz(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvts8_f16_tz(a);
}
static __mlu_func__ __mlu_builtin__ char __half2char_oz(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvts8_f16_oz(a);
}
static __mlu_func__ __mlu_builtin__ char __half2char_up(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvts8_f16_up(a);
}
static __mlu_func__ __mlu_builtin__ char __half2char_dn(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvts8_f16_dn(a);
}
static __mlu_func__ __mlu_builtin__ char __half2char_rd(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvts8_f16_rd(a);
}
#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ char __half2char_rm(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvts8_f16_rm(a);
}
static __mlu_func__ __mlu_builtin__ char __half2char_rn(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvts8_f16_rn(a);
}
#endif

static __mlu_func__ __mlu_builtin__ unsigned char __half2uchar(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvtu8_f16_tz(a);
}

static __mlu_func__ __mlu_builtin__ unsigned char __half2uchar_tz(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvtu8_f16_tz(a);
}
static __mlu_func__ __mlu_builtin__ unsigned char __half2uchar_oz(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvtu8_f16_oz(a);
}
static __mlu_func__ __mlu_builtin__ unsigned char __half2uchar_up(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvtu8_f16_up(a);
}
static __mlu_func__ __mlu_builtin__ unsigned char __half2uchar_dn(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvtu8_f16_dn(a);
}
static __mlu_func__ __mlu_builtin__ unsigned char __half2uchar_rd(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvtu8_f16_rd(a);
}
#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ unsigned char __half2uchar_rm(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvtu8_f16_rm(a);
}
static __mlu_func__ __mlu_builtin__ unsigned char __half2uchar_rn(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvtu8_f16_rn(a);
}
#endif

static __mlu_func__ __mlu_builtin__ char __float2char(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvts8_f32_tz(a);
}

static __mlu_func__ __mlu_builtin__ char __float2char_tz(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvts8_f32_tz(a);
}
static __mlu_func__ __mlu_builtin__ char __float2char_oz(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvts8_f32_oz(a);
}
static __mlu_func__ __mlu_builtin__ char __float2char_up(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvts8_f32_up(a);
}
static __mlu_func__ __mlu_builtin__ char __float2char_dn(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvts8_f32_dn(a);
}
static __mlu_func__ __mlu_builtin__ char __float2char_rd(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvts8_f32_rd(a);
}
#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ char __float2char_rm(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvts8_f32_rm(a);
}
static __mlu_func__ __mlu_builtin__ char __float2char_rn(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvts8_f32_rn(a);
}
#endif

static __mlu_func__ __mlu_builtin__ unsigned char __float2uchar(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvtu8_f32_tz(a);
}

static __mlu_func__ __mlu_builtin__ unsigned char __float2uchar_tz(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvtu8_f32_tz(a);
}
static __mlu_func__ __mlu_builtin__ unsigned char __float2uchar_oz(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvtu8_f32_oz(a);
}
static __mlu_func__ __mlu_builtin__ unsigned char __float2uchar_up(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvtu8_f32_up(a);
}
static __mlu_func__ __mlu_builtin__ unsigned char __float2uchar_dn(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvtu8_f32_dn(a);
}
static __mlu_func__ __mlu_builtin__ unsigned char __float2uchar_rd(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvtu8_f32_rd(a);
}
#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ unsigned char __float2uchar_rm(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvtu8_f32_rm(a);
}
static __mlu_func__ __mlu_builtin__ unsigned char __float2uchar_rn(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvtu8_f32_rn(a);
}
#endif


static __mlu_func__ __mlu_builtin__ unsigned int __half2uint(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvtu32_f16_tz(a);
}

static __mlu_func__ __mlu_builtin__ unsigned int __half2uint_tz(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvtu32_f16_tz(a);
}
static __mlu_func__ __mlu_builtin__ unsigned int __half2uint_oz(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvtu32_f16_oz(a);
}
static __mlu_func__ __mlu_builtin__ unsigned int __half2uint_up(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvtu32_f16_up(a);
}
static __mlu_func__ __mlu_builtin__ unsigned int __half2uint_dn(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvtu32_f16_dn(a);
}
static __mlu_func__ __mlu_builtin__ unsigned int __half2uint_rd(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvtu32_f16_rd(a);
}
#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ unsigned int __half2uint_rm(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvtu32_f16_rm(a);
}
static __mlu_func__ __mlu_builtin__ unsigned int __half2uint_rn(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvtu32_f16_rn(a);
}
#endif

static __mlu_func__ __mlu_builtin__ unsigned short __half2ushort(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvtu16_f16_tz(a);
}

static __mlu_func__ __mlu_builtin__ unsigned short __half2ushort_tz(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvtu16_f16_tz(a);
}
static __mlu_func__ __mlu_builtin__ unsigned short __half2ushort_oz(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvtu16_f16_oz(a);
}
static __mlu_func__ __mlu_builtin__ unsigned short __half2ushort_up(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvtu16_f16_up(a);
}
static __mlu_func__ __mlu_builtin__ unsigned short __half2ushort_dn(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvtu16_f16_dn(a);
}
static __mlu_func__ __mlu_builtin__ unsigned short __half2ushort_rd(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvtu16_f16_rd(a);
}
#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ unsigned short __half2ushort_rm(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvtu16_f16_rm(a);
}
static __mlu_func__ __mlu_builtin__ unsigned short __half2ushort_rn(half a) {
  __NAN_HALF_TO_INT(a);
  return __mlvm_scalar_cvtu16_f16_rn(a);
}
#endif

static __mlu_func__ __mlu_builtin__ unsigned int __float2uint(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvtu32_f32_tz(a);
}

static __mlu_func__ __mlu_builtin__ unsigned int __float2uint_tz(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvtu32_f32_tz(a);
}
static __mlu_func__ __mlu_builtin__ unsigned int __float2uint_oz(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvtu32_f32_oz(a);
}
static __mlu_func__ __mlu_builtin__ unsigned int __float2uint_up(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvtu32_f32_up(a);
}
static __mlu_func__ __mlu_builtin__ unsigned int __float2uint_dn(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvtu32_f32_dn(a);
}
static __mlu_func__ __mlu_builtin__ unsigned int __float2uint_rd(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvtu32_f32_rd(a);
}
#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ unsigned int __float2uint_rm(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvtu32_f32_rm(a);
}
static __mlu_func__ __mlu_builtin__ unsigned int __float2uint_rn(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvtu32_f32_rn(a);
}
#endif

static __mlu_func__ __mlu_builtin__ unsigned short __float2ushort(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvtu16_f32_tz(a);
}

static __mlu_func__ __mlu_builtin__ unsigned short __float2ushort_tz(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvtu16_f32_tz(a);
}
static __mlu_func__ __mlu_builtin__ unsigned short __float2ushort_oz(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvtu16_f32_oz(a);
}
static __mlu_func__ __mlu_builtin__ unsigned short __float2ushort_up(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvtu16_f32_up(a);
}
static __mlu_func__ __mlu_builtin__ unsigned short __float2ushort_dn(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvtu16_f32_dn(a);
}
static __mlu_func__ __mlu_builtin__ unsigned short __float2ushort_rd(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvtu16_f32_rd(a);
}
#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ unsigned short __float2ushort_rm(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvtu16_f32_rm(a);
}
static __mlu_func__ __mlu_builtin__ unsigned short __float2ushort_rn(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvtu16_f32_rn(a);
}
#endif

// -----------------------------------------------------------------------------
// Bang C/C++ math function: scalar convert short to half operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ half __short2half(short a) {
  return __mlvm_scalar_cvtf16_s16_tz(a);
}
static __mlu_func__ __mlu_builtin__ half __short2half_tz(short a) {
  return __mlvm_scalar_cvtf16_s16_tz(a);
}
static __mlu_func__ __mlu_builtin__ half __short2half_oz(short a) {
  return __mlvm_scalar_cvtf16_s16_oz(a);
}
static __mlu_func__ __mlu_builtin__ half __short2half_up(short a) {
  return __mlvm_scalar_cvtf16_s16_up(a);
}
static __mlu_func__ __mlu_builtin__ half __short2half_dn(short a) {
  return __mlvm_scalar_cvtf16_s16_dn(a);
}
static __mlu_func__ __mlu_builtin__ half __short2half_rd(short a) {
  return __mlvm_scalar_cvtf16_s16_rd(a);
}
#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ half __short2half_rm(short a) {
  return __mlvm_scalar_cvtf16_s16_rm(a);
}
static __mlu_func__ __mlu_builtin__ half __short2half_rn(short a) {
  return __mlvm_scalar_cvtf16_s16_rn(a);
}
#endif

// -----------------------------------------------------------------------------
// Bang C/C++ math function: scalar convert unsigned short to half operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ half __ushort2half_tz(unsigned short a) {
  return __mlvm_scalar_cvtf16_u16_tz(a);
}
static __mlu_func__ __mlu_builtin__ half __ushort2half_oz(unsigned short a) {
  __POSITIVE_INF_HALF(a);
  return __mlvm_scalar_cvtf16_u16_oz(a);
}
static __mlu_func__ __mlu_builtin__ half __ushort2half_up(unsigned short a) {
  __POSITIVE_INF_HALF(a);
  return __mlvm_scalar_cvtf16_u16_up(a);
}
static __mlu_func__ __mlu_builtin__ half __ushort2half_dn(unsigned short a) {
  return __mlvm_scalar_cvtf16_u16_dn(a);
}
static __mlu_func__ __mlu_builtin__ half __ushort2half_rd(unsigned short a) {
  __POSITIVE_INF_HALF(a);
  return __mlvm_scalar_cvtf16_u16_rd(a);
}
#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ half __ushort2half_rm(unsigned short a) {
  __POSITIVE_INF_HALF(a);
  return __mlvm_scalar_cvtf16_u16_rm(a);
}
static __mlu_func__ __mlu_builtin__ half __ushort2half_rn(unsigned short a) {
  __POSITIVE_INF_HALF(a);
  return __mlvm_scalar_cvtf16_u16_rn(a);
}
#endif

// -----------------------------------------------------------------------------
// Bang C/C++ math function: scalar convert float to int operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ int __float2int_tz(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvti32_f32_tz(a);
}
static __mlu_func__ __mlu_builtin__ int __float2int_oz(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvti32_f32_oz(a);
}
static __mlu_func__ __mlu_builtin__ int __float2int_up(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvti32_f32_up(a);
}
static __mlu_func__ __mlu_builtin__ int __float2int_dn(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvti32_f32_dn(a);
}
static __mlu_func__ __mlu_builtin__ int __float2int_rd(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvti32_f32_rd(a);
}
#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ int __float2int_rm(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvti32_f32_rm(a);
}

static __mlu_func__ __mlu_builtin__ int __float2int_rn(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvti32_f32_rn(a);
}
#endif
static __mlu_func__ __mlu_builtin__ int __float2int(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvti32_f32_tz(a);
}

// -----------------------------------------------------------------------------
// Bang C/C++ math function: scalar convert float to short operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ short __float2short_tz(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvti16_f32_tz(a);
}
static __mlu_func__ __mlu_builtin__ short __float2short_oz(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvti16_f32_oz(a);
}
static __mlu_func__ __mlu_builtin__ short __float2short_up(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvti16_f32_up(a);
}
static __mlu_func__ __mlu_builtin__ short __float2short_dn(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvti16_f32_dn(a);
}
static __mlu_func__ __mlu_builtin__ short __float2short_rd(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvti16_f32_rd(a);
}
#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ short __float2short_rm(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvti16_f32_rm(a);
}

static __mlu_func__ __mlu_builtin__ short __float2short_rn(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvti16_f32_rn(a);
}
#endif
static __mlu_func__ __mlu_builtin__ short __float2short(float a) {
  __NAN_FLOAT_TO_INT(a);
  return __mlvm_scalar_cvti16_f32_tz(a);
}

// -----------------------------------------------------------------------------
// Bang C/C++ math function: scalar convert int to float operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ float __int2float(int a) {
  return __mlvm_scalar_cvtf32_s32_tz(a);
}
static __mlu_func__ __mlu_builtin__ float __int2float_tz(int a) {
  return __mlvm_scalar_cvtf32_s32_tz(a);
}
static __mlu_func__ __mlu_builtin__ float __int2float_oz(int a) {
  return __mlvm_scalar_cvtf32_s32_oz(a);
}
static __mlu_func__ __mlu_builtin__ float __int2float_up(int a) {
  return __mlvm_scalar_cvtf32_s32_up(a);
}
static __mlu_func__ __mlu_builtin__ float __int2float_dn(int a) {
  return __mlvm_scalar_cvtf32_s32_dn(a);
}
static __mlu_func__ __mlu_builtin__ float __int2float_rd(int a) {
  return __mlvm_scalar_cvtf32_s32_rd(a);
}
#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ float __int2float_rm(int a) {
  return __mlvm_scalar_cvtf32_s32_rm(a);
}
static __mlu_func__ __mlu_builtin__ float __int2float_rn(int a) {
  return __mlvm_scalar_cvtf32_s32_rn(a);
}
#endif
// -----------------------------------------------------------------------------
// Bang C/C++ math function: scalar convert unsigned int to float operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ float __uint2float_tz(unsigned int a) {
  return __mlvm_scalar_cvtf32_u32_tz(a);
}
static __mlu_func__ __mlu_builtin__ float __uint2float_oz(unsigned int a) {
  return __mlvm_scalar_cvtf32_u32_oz(a);
}
static __mlu_func__ __mlu_builtin__ float __uint2float_up(unsigned int a) {
  return __mlvm_scalar_cvtf32_u32_up(a);
}
static __mlu_func__ __mlu_builtin__ float __uint2float_dn(unsigned int a) {
  return __mlvm_scalar_cvtf32_u32_dn(a);
}
static __mlu_func__ __mlu_builtin__ float __uint2float_rd(unsigned int a) {
  return __mlvm_scalar_cvtf32_u32_rd(a);
}
#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ float __uint2float_rm(unsigned int a) {
  return __mlvm_scalar_cvtf32_u32_rm(a);
}
static __mlu_func__ __mlu_builtin__ float __uint2float_rn(unsigned int a) {
  return __mlvm_scalar_cvtf32_u32_rn(a);
}
#endif
static __mlu_func__ __mlu_builtin__ float __uint2float(unsigned int a) {
  return __mlvm_scalar_cvtf32_u32_tz(a);
}

// -----------------------------------------------------------------------------
// Bang C/C++ math function: scalar convert short to float operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ float __short2float_tz(short a) {
  return __mlvm_scalar_cvtf32_s16_tz(a);
}
static __mlu_func__ __mlu_builtin__ float __short2float_oz(short a) {
  return __mlvm_scalar_cvtf32_s16_oz(a);
}
static __mlu_func__ __mlu_builtin__ float __short2float_up(short a) {
  return __mlvm_scalar_cvtf32_s16_up(a);
}
static __mlu_func__ __mlu_builtin__ float __short2float_dn(short a) {
  return __mlvm_scalar_cvtf32_s16_dn(a);
}
static __mlu_func__ __mlu_builtin__ float __short2float_rd(short a) {
  return __mlvm_scalar_cvtf32_s16_rd(a);
}
#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ float __short2float_rm(short a) {
  return __mlvm_scalar_cvtf32_s16_rm(a);
}
static __mlu_func__ __mlu_builtin__ float __short2float_rn(short a) {
  return __mlvm_scalar_cvtf32_s16_rn(a);
}
#endif
static __mlu_func__ __mlu_builtin__ float __short2float(short a) {
  return __mlvm_scalar_cvtf32_s16_tz(a);
}

// -----------------------------------------------------------------------------
// Bang C/C++ math function: scalar convert unsigned short to float operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ float __ushort2float_tz(unsigned short a) {
  return __mlvm_scalar_cvtf32_u16_tz(a);
}
static __mlu_func__ __mlu_builtin__ float __ushort2float_oz(unsigned short a) {
  return __mlvm_scalar_cvtf32_u16_oz(a);
}
static __mlu_func__ __mlu_builtin__ float __ushort2float_up(unsigned short a) {
  return __mlvm_scalar_cvtf32_u16_up(a);
}
static __mlu_func__ __mlu_builtin__ float __ushort2float_dn(unsigned short a) {
  return __mlvm_scalar_cvtf32_u16_dn(a);
}
static __mlu_func__ __mlu_builtin__ float __ushort2float_rd(unsigned short a) {
  return __mlvm_scalar_cvtf32_u16_rd(a);
}
#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ float __ushort2float_rm(unsigned short a) {
  return __mlvm_scalar_cvtf32_u16_rm(a);
}
static __mlu_func__ __mlu_builtin__ float __ushort2float_rn(unsigned short a) {
  return __mlvm_scalar_cvtf32_u16_rn(a);
}
#endif
static __mlu_func__ __mlu_builtin__ float __ushort2float(unsigned short a) {
  return __mlvm_scalar_cvtf32_u16_tz(a);
}

// -----------------------------------------------------------------------------
// Bang C/C++ math function: scalar convert float to half operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ half __float2half_tz(float a) {
  return __mlvm_scalar_cvtf16_f32_tz(a);
}

#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ half __float2half_oz(float a) {
  __POSITIVE_INF_HALF(a);
  __NEGATIVE_INF_HALF(a);
  return __mlvm_scalar_cvtf16_f32_oz(a);
}
static __mlu_func__ __mlu_builtin__ half __float2half_up(float a) {
  __POSITIVE_INF_HALF(a);
  return __mlvm_scalar_cvtf16_f32_up(a);
}
static __mlu_func__ __mlu_builtin__ half __float2half_dn(float a) {
  __NEGATIVE_INF_HALF(a);
  return __mlvm_scalar_cvtf16_f32_dn(a);
}
static __mlu_func__ __mlu_builtin__ half __float2half_rd(float a) {
  __POSITIVE_INF_HALF(a);
  __NEGATIVE_INF_HALF(a);
  return __mlvm_scalar_cvtf16_f32_rd(a);
}
#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ half __float2half_rm(float a) {
  __POSITIVE_INF_HALF(a);
  __NEGATIVE_INF_HALF(a);
  return __mlvm_scalar_cvtf16_f32_rm(a);
}

static __mlu_func__ __mlu_builtin__ half __float2half_rn(float a) {
  __POSITIVE_INF_HALF(a);
  __NEGATIVE_INF_HALF(a);
  return __mlvm_scalar_cvtf16_f32_rn(a);
}
#endif  // __BANG_ARCH__ >= 300
#endif  // __BANG_ARCH__ >= 200

static __mlu_func__ __mlu_builtin__ half __float2half(float a) {
  return __float2half_tz(a);
}
// -----------------------------------------------------------------------------
// Bang C/C++ math function: scalar convert half to float operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ float __half2float(half a) {
  __INF_HALF_TO_FLOAT(a);
  return __mlvm_scalar_cvtf32_f16(a);
}

#if __BANG_ARCH__ >= 200
static __mlu_func__ __mlu_builtin__ float __half2float_tz(half a) {
  __INF_HALF_TO_FLOAT(a);
  return __mlvm_scalar_cvtf32_f16_tz(a);
}

static __mlu_func__ __mlu_builtin__ float __half2float_oz(half a) {
  __INF_HALF_TO_FLOAT(a);
  return __mlvm_scalar_cvtf32_f16_oz(a);
}

static __mlu_func__ __mlu_builtin__ float __half2float_up(half a) {
  __INF_HALF_TO_FLOAT(a);
  return __mlvm_scalar_cvtf32_f16_up(a);
}

static __mlu_func__ __mlu_builtin__ float __half2float_dn(half a) {
  __INF_HALF_TO_FLOAT(a);
  return __mlvm_scalar_cvtf32_f16_dn(a);
}

static __mlu_func__ __mlu_builtin__ float __half2float_rd(half a) {
  __INF_HALF_TO_FLOAT(a);
  return __mlvm_scalar_cvtf32_f16_rd(a);
}
#endif  // __BANG_ARCH__ >= 200
#if __BANG_ARCH__ >= 300
static __mlu_func__ __mlu_builtin__ float __half2float_rm(half a) {
  return __mlvm_scalar_cvtf32_f16_rm(a);
}

static __mlu_func__ __mlu_builtin__ float __half2float_rn(half a) {
  return __mlvm_scalar_cvtf32_f16_rn(a);
}
#endif  // __BANG_ARCH__ >= 300

#define STREAM_CVT_FIX8(_1, _2, _3, _4, _5, _6, _7, NAME, ...) NAME

#define __bang_fix82half(...)                                   \
  STREAM_CVT_FIX8(__VA_ARGS__,                                  \
                  __mlvm_stream_cvtf16_fix8_stride,             \
                  __mlvm_stream_cvtf16_fix8_stride,             \
                  __mlvm_stream_cvtf16_fix8_stride,             \
                  __mlvm_stream_cvtf16_fix8, ...)(__VA_ARGS__)
#ifndef __bang_fix82half
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert fix8 to half operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_fix82half(half* dst,
                                                          fix8* src,
                                                          int src_count,
                                                          int fix_position) {
  __mlvm_stream_cvtf16_fix8(dst, src, src_count, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_fix82half(half* dst,
                                                          fix8* src,
                                                          int src_count,
                                                          int fix_position,
                                                          int dst_stride,
                                                          int src_stride,
                                                          int segnum) {
  __mlvm_stream_cvtf16_fix8_stride(dst, src, src_count, fix_position,
                                   dst_stride, src_stride, segnum);
}
#endif

#define __bang_int82half(...)                                   \
  STREAM_CVT_FIX8(__VA_ARGS__,                                  \
                  __mlvm_stream_cvtf16_fix8_stride,             \
                  __mlvm_stream_cvtf16_fix8_stride,             \
                  __mlvm_stream_cvtf16_fix8_stride,             \
                  __mlvm_stream_cvtf16_fix8, ...)(__VA_ARGS__)
#ifndef __bang_int82half
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert int8 to half operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_int82half(half* dst,
                                                          int8* src,
                                                          int src_count,
                                                          int fix_position) {
  __mlvm_stream_cvtf16_fix8(dst, src, src_count, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_int82half(half* dst,
                                                          int8* src,
                                                          int src_count,
                                                          int fix_position,
                                                          int dst_stride,
                                                          int src_stride,
                                                          int segnum) {
  __mlvm_stream_cvtf16_fix8_stride(dst, src, src_count, fix_position,
                                   dst_stride, src_stride, segnum);
}
#endif
#define __bang_fix82half __bang_int82half

#define __bang_uchar2half(...)                                  \
  STREAM_CVT_OTHERS(__VA_ARGS__,                                \
                    __mlvm_stream_cvtf16_u8_stride,             \
                    __mlvm_stream_cvtf16_u8_stride,             \
                    __mlvm_stream_cvtf16_u8_stride,             \
                    __mlvm_stream_cvtf16_u8, ...)(__VA_ARGS__)
#ifndef __bang_uchar2half
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert uchar to half operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_uchar2half(half* dst,
                                                           unsigned char* src,
                                                           int src_count) {
  __mlvm_stream_cvtf16_u8(dst, src, src_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_uchar2half(half* dst,
                                                           unsigned char* src,
                                                           int src_count,
                                                           int dst_stride,
                                                           int src_stride,
                                                           int segnum) {
  __mlvm_stream_cvtf16_u8_stride(dst, src, src_count,
                                 dst_stride, src_stride, segnum);
}
#endif

#define __bang_short2half(...)                                  \
  STREAM_CVT_OTHERS(__VA_ARGS__,                                \
                    __mlvm_stream_cvtf16_i16_stride,            \
                    __mlvm_stream_cvtf16_i16_stride,            \
                    __mlvm_stream_cvtf16_i16_stride,            \
                    __mlvm_stream_cvtf16_i16, ...)(__VA_ARGS__)
#ifndef __bang_short2half
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert short to half operation
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_short2half(half* dst,
                                                           short* src,
                                                           int src_count) {
  __mlvm_stream_cvtf16_i16(dst, src, src_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_short2half(half* dst,
                                                           short*src,
                                                           int src_count,
                                                           int dst_stride,
                                                           int src_stride,
                                                           int segnum) {
  __mlvm_stream_cvtf16_i16_stride(dst, src, src_count,
                                  dst_stride, src_stride, segnum);
}
#endif

#define __bang_float2half_tz(...)                                   \
  STREAM_CVT_OTHERS(__VA_ARGS__,                                    \
                    __mlvm_stream_cvtf16_f32_stride_tz,             \
                    __mlvm_stream_cvtf16_f32_stride_tz,             \
                    __mlvm_stream_cvtf16_f32_stride_tz,             \
                    __mlvm_stream_cvtf16_f32_tz, ...)(__VA_ARGS__)
#ifndef __bang_float2half_tz
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert float to half (round to zero)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_float2half_tz(half* dst,
                                                              float* src,
                                                              int src_count) {
  __mlvm_stream_cvtf16_f32_tz(dst, src, src_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_float2half_tz(half* dst,
                                                              float* src,
                                                              int src_count,
                                                              int dst_stride,
                                                              int src_stride,
                                                              int segnum) {
  __mlvm_stream_cvtf16_f32_stride_tz(dst, src, src_count,
                                     dst_stride, src_stride, segnum);
}
#endif


#define __bang_float2half_dn(...)                                   \
  STREAM_CVT_OTHERS(__VA_ARGS__,                                    \
                    __mlvm_stream_cvtf16_f32_stride_dn,             \
                    __mlvm_stream_cvtf16_f32_stride_dn,             \
                    __mlvm_stream_cvtf16_f32_stride_dn,             \
                    __mlvm_stream_cvtf16_f32_dn, ...)(__VA_ARGS__)
#ifndef __bang_float2half_dn
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert float to half (round down)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_float2half_dn(half* dst,
                                                              float* src,
                                                              int src_count) {
  __mlvm_stream_cvtf16_f32_dn(dst, src, src_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_float2half_dn(half* dst,
                                                              float* src,
                                                              int src_count,
                                                              int dst_stride,
                                                              int src_stride,
                                                              int segnum) {
  __mlvm_stream_cvtf16_f32_stride_dn(dst, src, src_count,
                                     dst_stride, src_stride, segnum);
}
#endif

#define __bang_float2half_oz(...)                                   \
  STREAM_CVT_OTHERS(__VA_ARGS__,                                    \
                    __mlvm_stream_cvtf16_f32_stride_oz,             \
                    __mlvm_stream_cvtf16_f32_stride_oz,             \
                    __mlvm_stream_cvtf16_f32_stride_oz,             \
                    __mlvm_stream_cvtf16_f32_oz, ...)(__VA_ARGS__)
#ifndef __bang_float2half_oz
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert float to half (round off zero)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_float2half_oz(half* dst,
                                                              float* src,
                                                              int src_count) {
  __mlvm_stream_cvtf16_f32_oz(dst, src, src_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_float2half_oz(half* dst,
                                                              float* src,
                                                              int src_count,
                                                              int dst_stride,
                                                              int src_stride,
                                                              int segnum) {
  __mlvm_stream_cvtf16_f32_stride_oz(dst, src, src_count,
                                     dst_stride, src_stride, segnum);
}
#endif

//TODO(libaoliang): delete MLU100 related interface
#define __bang_float2half_up(...)                                   \
  STREAM_CVT_OTHERS(__VA_ARGS__,                                    \
                    __mlvm_stream_cvtf16_f32_stride_up,             \
                    __mlvm_stream_cvtf16_f32_stride_up,             \
                    __mlvm_stream_cvtf16_f32_stride_up,             \
                    __mlvm_stream_cvtf16_f32_up, ...)(__VA_ARGS__)
#ifndef __bang_float2half_up
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert float to half (round up)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_float2half_up(half* dst,
                                                              float* src,
                                                              int src_count) {
  __mlvm_stream_cvtf16_f32_up(dst, src, src_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_float2half_up(half* dst,
                                                              float* src,
                                                              int src_count,
                                                              int dst_stride,
                                                              int src_stride,
                                                              int segnum) {
  __mlvm_stream_cvtf16_f32_stride_up(dst, src, src_count,
                                     dst_stride, src_stride, segnum);
}
#endif

#define __bang_float2half_rd(...)                                   \
  STREAM_CVT_OTHERS(__VA_ARGS__,                                    \
                    __mlvm_stream_cvtf16_f32_stride_rd,             \
                    __mlvm_stream_cvtf16_f32_stride_rd,             \
                    __mlvm_stream_cvtf16_f32_stride_rd,             \
                    __mlvm_stream_cvtf16_f32_rd, ...)(__VA_ARGS__)
#ifndef __bang_float2half_rd
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert float to half (middle round)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_float2half_rd(half* dst,
                                                              float* src,
                                                              int src_count) {
  __mlvm_stream_cvtf16_f32_rd(dst, src, src_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_float2half_rd(half* dst,
                                                              float* src,
                                                              int src_count,
                                                              int dst_stride,
                                                              int src_stride,
                                                              int segnum) {
  __mlvm_stream_cvtf16_f32_stride_rd(dst, src, src_count,
                                     dst_stride, src_stride, segnum);
}
#endif

#if __BANG_ARCH__ >= 300
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert float to half (round to math)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_float2half_rm(half* dst,
                                                              float* src,
                                                              int src_count) {
  __mlvm_stream_cvtf16_f32_rm(dst, src, src_count);
}

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert float to half (even)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_float2half_rn(half* dst,
                                                              float* src,
                                                              int src_count) {
  __mlvm_stream_cvtf16_f32_rn(dst, src, src_count);
}

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert float to half (stochastic rounding)
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >=300 && __BANG_ARCH__ != 322 && __BANG_ARCH__ != 372 && \
    __BANG_ARCH__ != 303 && __BANG_ARCH__ != 306
static __mlu_func__ __mlu_builtin__ void __bang_float2half_sr(half* dst,
                                                              float* src,
                                                              int* srv,
                                                              int count) {
  __mlvm_stream_cvtf16_f32_sr(dst, src, srv, count);
}


static __mlu_func__ __mlu_builtin__ void __bang_float2tf32_sr(float* dst,
                                                              float* src,
                                                              int* srv,
                                                              int count) {
  __mlvm_stream_cvttf32_f32_sr(dst, src, srv, count);
}
#endif // __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 322 && \
          __BANG_ARCH__ != 372 && __BANG_ARCH__ != 303 && \
          __BANG_ARCH__ != 306

static __mlu_func__ __mlu_builtin__ void __bang_float2bfloat16_rm(bfloat16_t* dst,
                                                                  float* src,
                                                                  int src_count) {
  __mlvm_stream_cvtbf16_f32_rm(dst, src, src_count);
}

static __mlu_func__ __mlu_builtin__ void __bang_float2bfloat16_rn(bfloat16_t* dst,
                                                                  float* src,
                                                                  int src_count) {
  __mlvm_stream_cvtbf16_f32_rn(dst, src, src_count);
}

static __mlu_func__ __mlu_builtin__ void __bang_float2bfloat16_rd(bfloat16_t* dst,
                                                                  float* src,
                                                                  int src_count) {
  __mlvm_stream_cvtbf16_f32_rd(dst, src, src_count);
}

static __mlu_func__ __mlu_builtin__ void __bang_float2bfloat16_up(bfloat16_t* dst,
                                                                  float* src,
                                                                  int src_count) {
  __mlvm_stream_cvtbf16_f32_up(dst, src, src_count);
}

static __mlu_func__ __mlu_builtin__ void __bang_float2bfloat16_oz(bfloat16_t* dst,
                                                                  float* src,
                                                                  int src_count) {
  __mlvm_stream_cvtbf16_f32_oz(dst, src, src_count);
}

static __mlu_func__ __mlu_builtin__ void __bang_float2bfloat16_dn(bfloat16_t* dst,
                                                                  float* src,
                                                                  int src_count) {
  __mlvm_stream_cvtbf16_f32_dn(dst, src, src_count);
}

static __mlu_func__ __mlu_builtin__ void __bang_float2bfloat16_tz(bfloat16_t* dst,
                                                                  float* src,
                                                                  int src_count) {
  __mlvm_stream_cvtbf16_f32_tz(dst, src, src_count);
}

static __mlu_func__ __mlu_builtin__ void __bang_bfloat162float_rm(float* dst,
                                                                  bfloat16_t* src,
                                                                  int src_count) {
  __mlvm_stream_cvtf32_bf16_rm(dst, src, src_count);
}

static __mlu_func__ __mlu_builtin__ void __bang_bfloat162float_rn(float* dst,
                                                                  bfloat16_t* src,
                                                                  int src_count) {
  __mlvm_stream_cvtf32_bf16_rn(dst, src, src_count);
}

static __mlu_func__ __mlu_builtin__ void __bang_bfloat162float_rd(float* dst,
                                                                  bfloat16_t* src,
                                                                  int src_count) {
  __mlvm_stream_cvtf32_bf16_rd(dst, src, src_count);
}

static __mlu_func__ __mlu_builtin__ void __bang_bfloat162float_up(float* dst,
                                                                  bfloat16_t* src,
                                                                  int src_count) {
  __mlvm_stream_cvtf32_bf16_up(dst, src, src_count);
}

static __mlu_func__ __mlu_builtin__ void __bang_bfloat162float_oz(float* dst,
                                                                  bfloat16_t* src,
                                                                  int src_count) {
  __mlvm_stream_cvtf32_bf16_oz(dst, src, src_count);
}

static __mlu_func__ __mlu_builtin__ void __bang_bfloat162float_dn(float* dst,
                                                                  bfloat16_t* src,
                                                                  int src_count) {
  __mlvm_stream_cvtf32_bf16_dn(dst, src, src_count);
}

static __mlu_func__ __mlu_builtin__ void __bang_bfloat162float_tz(float* dst,
                                                                  bfloat16_t* src,
                                                                  int src_count) {
  __mlvm_stream_cvtf32_bf16_tz(dst, src, src_count);
}

#endif  // __BANG_ARCH__ >= 300

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert half to int16 (round down)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_half2int16_dn(int16* dst,
                                                              half* src,
                                                              int src_count,
                                                              int fix_position) {
  __mlvm_stream_cvtfix16_f16_dn(dst, src, src_count, fix_position);
}
#define __bang_half2fix16_dn __bang_half2int16_dn

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert half to int16 (round to zero)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_half2int16_tz(int16* dst,
                                                              half* src,
                                                              int src_count,
                                                              int fix_position) {
  __mlvm_stream_cvtfix16_f16_tz(dst, src, src_count, fix_position);
}
#define __bang_half2fix16_tz __bang_half2int16_tz

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert half to int16 (round off zero)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_half2int16_oz(int16* dst,
                                                              half* src,
                                                              int src_count,
                                                              int fix_position) {
  __mlvm_stream_cvtfix16_f16_oz(dst, src, src_count, fix_position);
}
#define __bang_half2fix16_oz __bang_half2int16_oz

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert half to int16 (round up)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_half2int16_up(int16* dst,
                                                              half* src,
                                                              int src_count,
                                                              int fix_position) {
  __mlvm_stream_cvtfix16_f16_up(dst, src, src_count, fix_position);
}
#define __bang_half2fix16_up __bang_half2int16_up

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert half to int16 (middle round)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_half2int16_rd(int16* dst,
                                                              half* src,
                                                              int src_count,
                                                              int fix_position) {
  __mlvm_stream_cvtfix16_f16_rd(dst, src, src_count, fix_position);
}
#define __bang_half2fix16_rd __bang_half2int16_rd

#if __BANG_ARCH__ >= 300
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert half to int16 (round to math)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_half2int16_rm(int16* dst,
                                                              half* src,
                                                              int src_count,
                                                              int fix_position) {
  __mlvm_stream_cvtfix16_f16_rm(dst, src, src_count, fix_position);
}
#define __bang_half2fix16_rm __bang_half2int16_rm

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert half to int16 (even)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_half2int16_rn(int16* dst,
                                                              half* src,
                                                              int src_count,
                                                              int fix_position) {
  __mlvm_stream_cvtfix16_f16_rn(dst, src, src_count, fix_position);
}
#define __bang_half2fix16_rn __bang_half2int16_rn
#endif  // __BANG_ARCH__ >= 300

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert int16 to half
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_int162half(half* dst,
                                                           int16* src,
                                                           int src_count,
                                                           int fix_position) {
  __mlvm_stream_cvtf16_fix16(dst, src, src_count, fix_position);
}
#define __bang_fix162half __bang_int162half

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert float to int16 (round down)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_float2int16_dn(int16* dst,
                                                               float* src,
                                                               int src_count,
                                                               int fix_position) {
  __mlvm_stream_cvtfix16_f32_dn(dst, src, src_count, fix_position);
}
#define __bang_float2fix16_dn __bang_float2int16_dn

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert float to int16 (round to zero)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_float2int16_tz(int16* dst,
                                                               float* src,
                                                               int src_count,
                                                               int fix_position) {
  __mlvm_stream_cvtfix16_f32_tz(dst, src, src_count, fix_position);
}
#define __bang_float2fix16_tz __bang_float2int16_tz

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert float to int16 (round off zero)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_float2int16_oz(int16* dst,
                                                               float* src,
                                                               int src_count,
                                                               int fix_position) {
  __mlvm_stream_cvtfix16_f32_oz(dst, src, src_count, fix_position);
}
#define __bang_float2fix16_oz __bang_float2int16_oz

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert float to int16 (round up)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_float2int16_up(int16* dst,
                                                               float* src,
                                                               int src_count,
                                                               int fix_position) {
  __mlvm_stream_cvtfix16_f32_up(dst, src, src_count, fix_position);
}
#define __bang_float2fix16_up __bang_float2int16_up

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert float to int16 (middle round)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_float2int16_rd(int16* dst,
                                                               float* src,
                                                               int src_count,
                                                               int fix_position) {
  __mlvm_stream_cvtfix16_f32_rd(dst, src, src_count, fix_position);
}
#define __bang_float2fix16_rd __bang_float2int16_rd

#if __BANG_ARCH__ >= 300
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert float to int16 (round to math)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_float2int16_rm(int16* dst,
                                                               float* src,
                                                               int src_count,
                                                               int fix_position) {
  __mlvm_stream_cvtfix16_f32_rm(dst, src, src_count, fix_position);
}
#define __bang_float2fix16_rm __bang_float2int16_rm

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert float to int16 (even)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_float2int16_rn(int16* dst,
                                                               float* src,
                                                               int src_count,
                                                               int fix_position) {
  __mlvm_stream_cvtfix16_f32_rn(dst, src, src_count, fix_position);
}
#define __bang_float2fix16_rn __bang_float2int16_rn
#endif  // __BANG_ARCH__ >= 300

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert int16 to float
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_int162float(float* dst,
                                                            int16* src,
                                                            int src_count,
                                                            int fix_position) {
  __mlvm_stream_cvtf32_fix16(dst, src, src_count, fix_position);
}
#define __bang_fix162float __bang_int162float

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert int to float with minus
// -----------------------------------------------------------------------------
#if (__BANG_ARCH__ >= 200) && (__BANG_ARCH__ != 303) && (__BANG_ARCH__ != 306)
static __mlu_func__ __mlu_builtin__ void __bang_int2float(float* dst,
                                                          float* dst_addition,
                                                          int* src,
                                                          float* src_addition,
                                                          int src_count) {
  // get sign bit
  __mlvm_memset_nram_u32((unsigned *)src_addition, 32, 0x80000000);
  __mlvm_stream_cycle_band_b8((char *)dst_addition, (char *)src,
                              (char *)src_addition, src_count * 4, 128);
  // get 1 or 0 from sign bit
  __mlvm_memset_nram_u32((unsigned *)src_addition, 32, 0x00000001);
  __mlvm_stream_cycle_bor_b8((char *)dst_addition, (char *)dst_addition,
                             (char *)src_addition, src_count * 4, 128);
  __mlvm_memset_nram_u32((unsigned *)src_addition, 32, 0x80000001);
  __mlvm_stream_cycle_eq_f32(dst_addition, dst_addition, src_addition,
                             src_count, 32);
  // minus xor, positive num invariant
  __mlvm_memset_nram_u32((unsigned *)src_addition, 32, 0xffffffff);
  __mlvm_stream_cycle_mul_f32(dst, dst_addition, src_addition, src_count, 32);
  __mlvm_stream_bxor_b8((char *)dst, (char *)src, (char *)dst, src_count * 4);
  // convert int32 to float32
  __mlvm_memset_nram_u32((unsigned *)src_addition, 32, 0x7fffff);
  __mlvm_stream_cycle_band_b8((char *)dst, (char *)dst, (char *)src_addition,
                              src_count * 4, 128);
  __mlvm_memset_nram_u32((unsigned *)src_addition, 32, 0x4b000000);
  __mlvm_stream_cycle_bor_b8((char *)dst, (char *)dst, (char *)src_addition,
                             src_count * 4, 128);
  __mlvm_stream_sub_const_f32(dst, dst, 8388608.0, src_count);
  // add one
  __mlvm_stream_add_f32(dst, dst, dst_addition, src_count);
  // set sign for float32
  __mlvm_memset_nram_u32((unsigned *)src_addition, 32, 0xffffffff);
  __mlvm_stream_cycle_mul_f32(dst_addition, dst_addition, src_addition,
                              src_count, 32);
  __mlvm_memset_nram_u32((unsigned *)src_addition, 32, 0x80000000);
  __mlvm_stream_cycle_band_b8((char *)dst_addition, (char *)dst_addition,
                              (char *)src_addition, src_count * 4, 128);
  __mlvm_stream_bor_b8((char *)dst, (char *)dst, (char *)dst_addition,
                       src_count * 4);
}

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert float to int with minus
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_float2int(int* dst,
                                                          float* dst_addition,
                                                          float* src,
                                                          float* src_addition,
                                                          int src_count) {
  // get 1 or 0 from sign bit
  __mlvm_memset_nram_u32((unsigned *)src_addition, 32, 0x80000000);
  __mlvm_stream_cycle_band_b8((char *)dst_addition, (char *)src,
                              (char *)src_addition, src_count * 4, 128);
  // for distinguish the postive and negtive, need bor smoe bit
  __mlvm_memset_nram_u32((unsigned *)src_addition, 32, 0x00000001);
  __mlvm_stream_cycle_bor_b8((char *)dst_addition, (char *)dst_addition,
                             (char *)src_addition, src_count * 4, 128);
  __mlvm_memset_nram_u32((unsigned *)src_addition, 32, 0x80000001);
  __mlvm_stream_cycle_eq_f32(dst_addition, dst_addition, src_addition,
                             src_count, 32);
  // get high bit 1 or 0
  __mlvm_memset_nram_u32((unsigned *)src_addition, 32, 0xff000000);
  __mlvm_stream_cycle_mul_f32((float *)dst, (float *)dst_addition,
                              src_addition, src_count, 32);
  __mlvm_memset_nram_u32((unsigned *)src_addition, 32, 0x00c00000);
  __mlvm_stream_cycle_mul_f32((float *)dst_addition, (float *)dst_addition,
                              src_addition, src_count, 32);
  __mlvm_stream_bor_b8((char *)dst, (char *)dst, (char *)dst_addition,
                       src_count * 4);
  // convert
  __mlvm_memset_nram_f32(src_addition, 32, 12582912.0);
  __mlvm_stream_cycle_add_f32((float *)dst_addition, src, src_addition,
                              src_count, 32);
  // get low 22bit
  __mlvm_memset_nram_u32((unsigned *)src_addition, 32, 0x3fffff);
  __mlvm_stream_cycle_band_b8((char *)dst_addition, (char *)dst_addition,
                              (char *)src_addition, src_count * 4, 128);
  // set high bit
  __mlvm_stream_bor_b8((char *)dst, (char *)dst, (char *)dst_addition,
                       src_count * 4);
}
#endif //  __BANG__ARCH__ >= 200 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 306


#if __BANG_ARCH__ >= 300
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert int32 to float
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_int2float(float* dst,
                                                          int* src,
                                                          int src_count,
                                                          int fix_position) {
  __mlvm_stream_cvtf32_fix32(dst, src, src_count, fix_position);
}

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert float to int32 (round down)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_float2int_dn(int* dst,
                                                             float* src,
                                                             int src_count,
                                                             int fix_position) {
  __mlvm_stream_cvtfix32_f32_dn(dst, src, src_count, fix_position);
}

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert float to int32 (round to zero)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_float2int_tz(int* dst,
                                                             float* src,
                                                             int src_count,
                                                             int fix_position) {
  __mlvm_stream_cvtfix32_f32_tz(dst, src, src_count, fix_position);
}

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert float to int32 (round off zero)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_float2int_oz(int* dst,
                                                             float* src,
                                                             int src_count,
                                                             int fix_position) {
  __mlvm_stream_cvtfix32_f32_oz(dst, src, src_count, fix_position);
}

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert float to int32 (round up)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_float2int_up(int* dst,
                                                             float* src,
                                                             int src_count,
                                                             int fix_position) {
  __mlvm_stream_cvtfix32_f32_up(dst, src, src_count, fix_position);
}

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert float to int32 (middle round)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_float2int_rd(int* dst,
                                                             float* src,
                                                             int src_count,
                                                             int fix_position) {
  __mlvm_stream_cvtfix32_f32_rd(dst, src, src_count, fix_position);
}

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert float to int32 (round to math)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_float2int_rm(int* dst,
                                                             float* src,
                                                             int src_count,
                                                             int fix_position) {
  __mlvm_stream_cvtfix32_f32_rm(dst, src, src_count, fix_position);
}

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert float to int32 (even)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_float2int_rn(int* dst,
                                                             float* src,
                                                             int src_count,
                                                             int fix_position) {
  __mlvm_stream_cvtfix32_f32_rn(dst, src, src_count, fix_position);
}
#endif  // __BANG_ARCH__ >= 300

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert float to int8 (round down)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_float2int8_dn(int8* dst,
                                                              float* src,
                                                              int src_count,
                                                              int fix_position) {
  __mlvm_stream_cvtfix8_f32_dn(dst, src, src_count, fix_position);
}
#define __bang_float2fix8_dn __bang_float2int8_dn

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert float to int8 (round to zero)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_float2int8_tz(int8* dst,
                                                              float* src,
                                                              int src_count,
                                                              int fix_position) {
  __mlvm_stream_cvtfix8_f32_tz(dst, src, src_count, fix_position);
}
#define __bang_float2fix8_tz __bang_float2int8_tz

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert float to int8 (round off zero)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_float2int8_oz(int8* dst,
                                                              float* src,
                                                              int src_count,
                                                              int fix_position) {
  __mlvm_stream_cvtfix8_f32_oz(dst, src, src_count, fix_position);
}
#define __bang_float2fix8_oz __bang_float2int8_oz

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert float to int8 (round up)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_float2int8_up(int8* dst,
                                                              float* src,
                                                              int src_count,
                                                              int fix_position) {
  __mlvm_stream_cvtfix8_f32_up(dst, src, src_count, fix_position);
}
#define __bang_float2fix8_up __bang_float2int8_up

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert float to int8 (middle round)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_float2int8_rd(int8* dst,
                                                              float* src,
                                                              int src_count,
                                                              int fix_position) {
  __mlvm_stream_cvtfix8_f32_rd(dst, src, src_count, fix_position);
}
#define __bang_float2fix8_rd __bang_float2int8_rd

#if __BANG_ARCH__ >= 300
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert float to int8 (round to math)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_float2int8_rm(int8* dst,
                                                              float* src,
                                                              int src_count,
                                                              int fix_position) {
  __mlvm_stream_cvtfix8_f32_rm(dst, src, src_count, fix_position);
}
#define __bang_float2fix8_rm __bang_float2int8_rm

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert float to int8 (even)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_float2int8_rn(int8* dst,
                                                              float* src,
                                                              int src_count,
                                                              int fix_position) {
  __mlvm_stream_cvtfix8_f32_rn(dst, src, src_count, fix_position);
}
#define __bang_float2fix8_rn __bang_float2int8_rn
#endif  // __BANG_ARCH__ >= 300

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert int8 to float
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_int82float(float* dst,
                                                           int8* src,
                                                           int src_count,
                                                           int fix_position) {
  __mlvm_stream_cvtf32_fix8(dst, src, src_count, fix_position);
}
#define __bang_fix82float __bang_int82float


// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert half to int8 (round down)
// -----------------------------------------------------------------------------
#define __bang_half2int8_dn(...)                                  \
  STREAM_CVT_FIX8(__VA_ARGS__,                                    \
                  __mlvm_stream_cvtfix8_f16_stride_dn,            \
                  __mlvm_stream_cvtfix8_f16_stride_dn,            \
                  __mlvm_stream_cvtfix8_f16_stride_dn,            \
                  __mlvm_stream_cvtfix8_f16_dn, ...)(__VA_ARGS__)
#ifndef __bang_half2int8_dn
static __mlu_func__ __mlu_builtin__ void __bang_half2int8_dn(int8* dst,
                                                             half* src,
                                                             int src_count,
                                                             int fix_position) {
  __mlvm_stream_cvtfix8_f16_dn(dst, src, src_count, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_half2int8_dn(int8* dst,
                                                             half* src,
                                                             int src_count,
                                                             int fix_position,
                                                             int dst_stride,
                                                             int src_stride,
                                                             int count) {
  __mlvm_stream_cvtfix8_f16_stride_dn(dst, src, src_count, fix_position,
                                      dst_stride, src_stride, count);

}
#endif
#define __bang_half2fix8_dn __bang_half2int8_dn

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert half to int8 (round to zero)
// -----------------------------------------------------------------------------
#define __bang_half2int8_tz(...)                                  \
  STREAM_CVT_FIX8(__VA_ARGS__,                                    \
                  __mlvm_stream_cvtfix8_f16_stride_tz,            \
                  __mlvm_stream_cvtfix8_f16_stride_tz,            \
                  __mlvm_stream_cvtfix8_f16_stride_tz,            \
                  __mlvm_stream_cvtfix8_f16_tz, ...)(__VA_ARGS__)
#ifndef __bang_half2int8_tz
static __mlu_func__ __mlu_builtin__ void __bang_half2int8_tz(int8* dst,
                                                             half* src,
                                                             int src_count,
                                                             int fix_position) {
  __mlvm_stream_cvtfix8_f16_tz(dst, src, src_count, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_half2int8_tz(int8* dst,
                                                             half* src,
                                                             int src_count,
                                                             int fix_position,
                                                             int dst_stride,
                                                             int src_stride,
                                                             int segnum) {
  __mlvm_stream_cvtfix8_f16_stride_tz(dst, src, src_count, fix_position,
                                      dst_stride, src_stride, segnum);
}
#endif
#define __bang_half2fix8_tz __bang_half2int8_tz

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert half to int8 (round off zero)
// -----------------------------------------------------------------------------
#define __bang_half2int8_oz(...)                                  \
  STREAM_CVT_FIX8(__VA_ARGS__,                                    \
                  __mlvm_stream_cvtfix8_f16_stride_oz,            \
                  __mlvm_stream_cvtfix8_f16_stride_oz,            \
                  __mlvm_stream_cvtfix8_f16_stride_oz,            \
                  __mlvm_stream_cvtfix8_f16_oz, ...)(__VA_ARGS__)
#ifndef __bang_half2int8_oz
static __mlu_func__ __mlu_builtin__ void __bang_half2int8_oz(int8* dst,
                                                             half* src,
                                                             int src_count,
                                                             int fix_position) {
  __mlvm_stream_cvtfix8_f16_oz(dst, src, src_count, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_half2int8_oz(int8* dst,
                                                             half* src,
                                                             int src_count,
                                                             int fix_position,
                                                             int dst_stride,
                                                             int src_stride,
                                                             int segnum) {
  __mlvm_stream_cvtfix8_f16_stride_oz(dst, src, src_count, fix_position,
                                      dst_stride, src_stride, segnum);
}
#endif
#define __bang_half2fix8_oz __bang_half2int8_oz

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert half to int8 (round up)
// -----------------------------------------------------------------------------
#define __bang_half2int8_up(...)                                  \
  STREAM_CVT_FIX8(__VA_ARGS__,                                    \
                  __mlvm_stream_cvtfix8_f16_stride_up,            \
                  __mlvm_stream_cvtfix8_f16_stride_up,            \
                  __mlvm_stream_cvtfix8_f16_stride_up,            \
                  __mlvm_stream_cvtfix8_f16_up, ...)(__VA_ARGS__)
#ifndef __bang_half2int8_up
static __mlu_func__ __mlu_builtin__ void __bang_half2int8_up(int8* dst,
                                                             half* src,
                                                             int src_count,
                                                             int fix_position) {
  __mlvm_stream_cvtfix8_f16_up(dst, src, src_count, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_half2int8_up(int8* dst,
                                                             half* src,
                                                             int src_count,
                                                             int fix_position,
                                                             int dst_stride,
                                                             int src_stride,
                                                             int segnum) {
  __mlvm_stream_cvtfix8_f16_stride_up(dst, src, src_count, fix_position,
                                      dst_stride, src_stride, segnum);
}
#endif
#define __bang_half2fix8_up __bang_half2int8_up

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert half to int8 (middle round)
// -----------------------------------------------------------------------------
#define __bang_half2int8_rd(...)                                  \
  STREAM_CVT_FIX8(__VA_ARGS__,                                    \
                  __mlvm_stream_cvtfix8_f16_stride_rd,            \
                  __mlvm_stream_cvtfix8_f16_stride_rd,            \
                  __mlvm_stream_cvtfix8_f16_stride_rd,            \
                  __mlvm_stream_cvtfix8_f16_rd, ...)(__VA_ARGS__)
#ifndef __bang_half2int8_rd
static __mlu_func__ __mlu_builtin__ void __bang_half2int8_rd(int8* dst,
                                                             half* src,
                                                             int src_count,
                                                             int fix_position) {
  __mlvm_stream_cvtfix8_f16_rd(dst, src, src_count, fix_position);
}
static __mlu_func__ __mlu_builtin__ void __bang_half2int8_rd(int8* dst,
                                                             half* src,
                                                             int src_count,
                                                             int fix_position,
                                                             int dst_stride,
                                                             int src_stride,
                                                             int segnum) {
  __mlvm_stream_cvtfix8_f16_stride_rd(dst, src, src_count, fix_position,
                                      dst_stride, src_stride, segnum);
}
#endif
#define __bang_half2fix8_rd __bang_half2int8_rd

#if __BANG_ARCH__ >= 300
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert half to int8 (round to math)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_half2int8_rm(int8* dst,
                                                             half* src,
                                                             int src_count,
                                                             int fix_position) {
  __mlvm_stream_cvtfix8_f16_rm(dst, src, src_count, fix_position);
}
#define __bang_half2fix8_rm __bang_half2int8_rm

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert half to int8 (even)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_half2int8_rn(int8* dst,
                                                             half* src,
                                                             int src_count,
                                                             int fix_position) {
  __mlvm_stream_cvtfix8_f16_rn(dst, src, src_count, fix_position);
}
#define __bang_half2fix8_rn __bang_half2int8_rn
#endif  // __BANG_ARCH__ >= 300

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert half to uchar (round down)
// -----------------------------------------------------------------------------
#if (__BANG_ARCH__ != 303) && (__BANG_ARCH__ != 306)
static __mlu_func__ __mlu_builtin__ void __bang_half2uchar_dn(unsigned char* dst,
                                                              half* src,
                                                              half* src_addition,
                                                              int src_count) {
  __mlvm_stream_ge_const_f16(src_addition, src, 128, src_count);
  __mlvm_stream_mul_const_f16(src_addition, src_addition, 256, src_count);
  __mlvm_stream_sub_f16(src_addition, src, src_addition, src_count);
  __mlvm_stream_cvtfix8_f16_dn((int8 *)dst, src_addition, src_count, 0);
}
#endif // (__BANG_ARCH__ != 303) && (__BANG_ARCH__ != 306)

static __mlu_func__ __mlu_builtin__ void __bang_half2uchar_dn(unsigned char* dst,
                                                              half* src,
                                                              int src_count) {
  __mlvm_stream_cvtfix8_f16_dn((int8 *)dst, src, src_count, 0);
}

static __mlu_func__ __mlu_builtin__ void __bang_half2uchar_dn(signed char* dst,
                                                              half* src,
                                                              int src_count) {
  __mlvm_stream_cvtfix8_f16_dn(dst, src, src_count, 0);
}

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert half to char (round down)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_half2char_dn(signed char* dst,
                                                             half* src,
                                                             int src_count) {
  __mlvm_stream_cvtfix8_f16_dn(dst, src, src_count, 0);
}

#define __bang_half2short_dn(...)                                   \
  STREAM_CVT_OTHERS(__VA_ARGS__,                                    \
                    __mlvm_stream_cvti16_f16_stride_dn,             \
                    __mlvm_stream_cvti16_f16_stride_dn,             \
                    __mlvm_stream_cvti16_f16_stride_dn,             \
                    __mlvm_stream_cvti16_f16_dn, ...)(__VA_ARGS__)
#ifndef __bang_half2short_dn
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert half to short (round down)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_half2short_dn(short* dst,
                                                              half* src,
                                                              int src_count) {
  __mlvm_stream_cvti16_f16_dn(dst, src, src_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_half2short_dn(short* dst,
                                                              half* src,
                                                              int src_count,
                                                              int dst_stride,
                                                              int src_stride,
                                                              int segnum) {
  __mlvm_stream_cvti16_f16_stride_dn(dst, src, src_count,
                                     dst_stride, src_stride, segnum);
}
#endif


#define __bang_half2short_tz(...)                                   \
  STREAM_CVT_OTHERS(__VA_ARGS__,                                    \
                    __mlvm_stream_cvti16_f16_stride_tz,             \
                    __mlvm_stream_cvti16_f16_stride_tz,             \
                    __mlvm_stream_cvti16_f16_stride_tz,             \
                    __mlvm_stream_cvti16_f16_tz, ...)(__VA_ARGS__)
#ifndef __bang_half2short_tz
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert half to short (round to zero)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_half2short_tz(short* dst,
                                                              half* src,
                                                              int src_count) {
  __mlvm_stream_cvti16_f16_tz(dst, src, src_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_half2short_tz(short* dst,
                                                              half* src,
                                                              int src_count,
                                                              int dst_stride,
                                                              int src_stride,
                                                              int segnum) {
  __mlvm_stream_cvti16_f16_stride_tz(dst, src, src_count,
                                     dst_stride, src_stride, segnum);
}
#endif

#define __bang_half2short_oz(...)                                   \
  STREAM_CVT_OTHERS(__VA_ARGS__,                                    \
                    __mlvm_stream_cvti16_f16_stride_oz,             \
                    __mlvm_stream_cvti16_f16_stride_oz,             \
                    __mlvm_stream_cvti16_f16_stride_oz,             \
                    __mlvm_stream_cvti16_f16_oz, ...)(__VA_ARGS__)
#ifndef __bang_half2short_oz
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert half to short (round off zero)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_half2short_oz(short* dst,
                                                              half* src,
                                                              int src_count) {
  __mlvm_stream_cvti16_f16_oz(dst, src, src_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_half2short_oz(short* dst,
                                                              half* src,
                                                              int src_count,
                                                              int dst_stride,
                                                              int src_stride,
                                                              int segnum) {
  __mlvm_stream_cvti16_f16_stride_oz(dst, src, src_count,
                                     dst_stride, src_stride, segnum);
}
#endif

#define __bang_half2short_up(...)                                   \
  STREAM_CVT_OTHERS(__VA_ARGS__,                                    \
                    __mlvm_stream_cvti16_f16_stride_up,             \
                    __mlvm_stream_cvti16_f16_stride_up,             \
                    __mlvm_stream_cvti16_f16_stride_up,             \
                    __mlvm_stream_cvti16_f16_up, ...)(__VA_ARGS__)
#ifndef __bang_half2short_up
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert half to short (round up)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_half2short_up(short* dst,
                                                              half* src,
                                                              int src_count) {
  __mlvm_stream_cvti16_f16_up(dst, src, src_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_half2short_up(short* dst,
                                                              half* src,
                                                              int src_count,
                                                              int dst_stride,
                                                              int src_stride,
                                                              int segnum) {
  __mlvm_stream_cvti16_f16_stride_up(dst, src, src_count,
                                     dst_stride, src_stride, segnum);
}
#endif

#define __bang_half2short_rd(...)                                   \
  STREAM_CVT_OTHERS(__VA_ARGS__,                                    \
                    __mlvm_stream_cvti16_f16_stride_rd,             \
                    __mlvm_stream_cvti16_f16_stride_rd,             \
                    __mlvm_stream_cvti16_f16_stride_rd,             \
                    __mlvm_stream_cvti16_f16_rd, ...)(__VA_ARGS__)
#ifndef __bang_half2short_rd
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert half to short (middle round)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_half2short_rd(short* dst,
                                                              half* src,
                                                              int src_count) {
  __mlvm_stream_cvti16_f16_rd(dst, src, src_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_half2short_rd(short* dst,
                                                              half* src,
                                                              int src_count,
                                                              int dst_stride,
                                                              int src_stride,
                                                              int segnum) {
  __mlvm_stream_cvti16_f16_stride_rd(dst, src, src_count,
                                     dst_stride, src_stride, segnum);
}
#endif

#if __BANG_ARCH__ >= 300
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert half to short (round to math)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_half2short_rm(short* dst,
                                                              half* src,
                                                              int src_count) {
  __mlvm_stream_cvti16_f16_rm(dst, src, src_count);
}
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert half to short (even)
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_half2short_rn(short* dst,
                                                              half* src,
                                                              int src_count) {
  __mlvm_stream_cvti16_f16_rn(dst, src, src_count);
}
#endif  // __BANG_ARCH__ >= 300

#define __bang_half2float(...)                                  \
  STREAM_CVT_OTHERS(__VA_ARGS__,                                \
                    __mlvm_stream_cvtf32_f16_stride,            \
                    __mlvm_stream_cvtf32_f16_stride,            \
                    __mlvm_stream_cvtf32_f16_stride,            \
                    __mlvm_stream_cvtf32_f16, ...)(__VA_ARGS__)
#ifndef __bang_half2float
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert half to float
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_half2float(float* dst,
                                                           half* src,
                                                           int src_count) {
  __mlvm_stream_cvtf32_f16(dst, src, src_count);
}
static __mlu_func__ __mlu_builtin__ void __bang_half2float(float* dst,
                                                           half* src,
                                                           int src_count,
                                                           int dst_stride,
                                                           int src_stride,
                                                           int segnum) {
  __mlvm_stream_cvtf32_f16_stride(dst, src, src_count,
                                  dst_stride, src_stride, segnum);
}
#endif
#if __BANG_ARCH__ >= 300
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert short to char
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_short2char(signed char* dst,
                                                           short* src,
                                                           int src_count,
                                                           int dst_position,
                                                           int src_position) {
  __mlvm_stream_cvtint8_int16(dst, src, src_count, dst_position, src_position);
}
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert int to char
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_int2char(signed char* dst,
                                                         int* src,
                                                         int src_count,
                                                         int dst_position,
                                                         int src_position) {
  __mlvm_stream_cvtint8_int32(dst, src, src_count, dst_position, src_position);
}
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert char to short
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_char2short(short* dst,
                                                           signed char* src,
                                                           int src_count,
                                                           int dst_position,
                                                           int src_position) {
  __mlvm_stream_cvtint16_int8(dst, src, src_count, dst_position, src_position);
}
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert int to short
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_int2short(short* dst,
                                                          int* src,
                                                          int src_count,
                                                          int dst_position,
                                                          int src_position) {
  __mlvm_stream_cvtint16_int32(dst, src, src_count, dst_position, src_position);
}
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert char to int
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_char2int(int* dst,
                                                         signed char* src,
                                                         int src_count,
                                                         int dst_position,
                                                         int src_position) {
  __mlvm_stream_cvtint32_int8(dst, src, src_count, dst_position, src_position);
}
// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream convert short to int
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __bang_short2int(int* dst,
                                                          short* src,
                                                          int src_count,
                                                          int dst_position,
                                                          int src_position) {
  __mlvm_stream_cvtint32_int16(dst, src, src_count, dst_position, src_position);
}

#if __BANG_ARCH__ != 303
static __mlu_func__ __mlu_builtin__ void __bang_float2int4_tz(int4x2_t* dst,
                                                              float* src,
                                                              int size,
                                                              int dst_position) {
  __mlvm_stream_cvtint4_float_tz(dst, src, size, dst_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_float2int4_oz(int4x2_t* dst,
                                                              float* src,
                                                              int size,
                                                              int dst_position) {
  __mlvm_stream_cvtint4_float_oz(dst, src, size, dst_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_float2int4_up(int4x2_t* dst,
                                                              float* src,
                                                              int size,
                                                              int dst_position) {
  __mlvm_stream_cvtint4_float_up(dst, src, size, dst_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_float2int4_dn(int4x2_t* dst,
                                                              float* src,
                                                              int size,
                                                              int dst_position) {
  __mlvm_stream_cvtint4_float_dn(dst, src, size, dst_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_float2int4_rd(int4x2_t* dst,
                                                              float* src,
                                                              int size,
                                                              int dst_position) {
  __mlvm_stream_cvtint4_float_rd(dst, src, size, dst_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_float2int4_rn(int4x2_t* dst,
                                                              float* src,
                                                              int size,
                                                              int dst_position) {
  __mlvm_stream_cvtint4_float_rn(dst, src, size, dst_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_float2int4_rm(int4x2_t* dst,
                                                              float* src,
                                                              int size,
                                                              int dst_position) {
  __mlvm_stream_cvtint4_float_rm(dst, src, size, dst_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_half2int4_tz(int4x2_t* dst,
                                                             half* src,
                                                             int size,
                                                             int dst_position) {
  __mlvm_stream_cvtint4_half_tz(dst, src, size, dst_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_half2int4_oz(int4x2_t* dst,
                                                             half* src,
                                                             int size,
                                                             int dst_position) {
  __mlvm_stream_cvtint4_half_oz(dst, src, size, dst_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_half2int4_up(int4x2_t* dst,
                                                             half* src,
                                                             int size,
                                                             int dst_position) {
  __mlvm_stream_cvtint4_half_up(dst, src, size, dst_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_half2int4_dn(int4x2_t* dst,
                                                             half* src,
                                                             int size,
                                                             int dst_position) {
  __mlvm_stream_cvtint4_half_dn(dst, src, size, dst_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_half2int4_rd(int4x2_t* dst,
                                                             half* src,
                                                             int size,
                                                             int dst_position) {
  __mlvm_stream_cvtint4_half_rd(dst, src, size, dst_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_half2int4_rn(int4x2_t* dst,
                                                             half* src,
                                                             int size,
                                                             int dst_position) {
  __mlvm_stream_cvtint4_half_rn(dst, src, size, dst_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_half2int4_rm(int4x2_t* dst,
                                                             half* src,
                                                             int size,
                                                             int dst_position) {
  __mlvm_stream_cvtint4_half_rm(dst, src, size, dst_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_bfloat162int4_tz(int4x2_t* dst,
                                                                 bfloat16_t* src,
                                                                 int size,
                                                                 int dst_position) {
   __mlvm_stream_cvtint4_bf16_tz(dst, src, size, dst_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_bfloat162int4_oz(int4x2_t* dst,
                                                                 bfloat16_t* src,
                                                                 int size,
                                                                 int dst_position) {
   __mlvm_stream_cvtint4_bf16_oz(dst, src, size, dst_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_bfloat162int4_up(int4x2_t* dst,
                                                                 bfloat16_t* src,
                                                                 int size,
                                                                 int dst_position) {
   __mlvm_stream_cvtint4_bf16_up(dst, src, size, dst_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_bfloat162int4_dn(int4x2_t* dst,
                                                                 bfloat16_t* src,
                                                                 int size,
                                                                 int dst_position) {
   __mlvm_stream_cvtint4_bf16_dn(dst, src, size, dst_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_bfloat162int4_rd(int4x2_t* dst,
                                                                 bfloat16_t* src,
                                                                 int size,
                                                                 int dst_position) {
   __mlvm_stream_cvtint4_bf16_rd(dst, src, size, dst_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_bfloat162int4_rm(int4x2_t* dst,
                                                                 bfloat16_t* src,
                                                                 int size,
                                                                 int dst_position) {
   __mlvm_stream_cvtint4_bf16_rm(dst, src, size, dst_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_bfloat162int4_rn(int4x2_t* dst,
                                                                 bfloat16_t* src,
                                                                 int size,
                                                                 int dst_position) {
   __mlvm_stream_cvtint4_bf16_rn(dst, src, size, dst_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int82int4_tz(int4x2_t* dst,
                                                             char* src,
                                                             int size,
                                                             int dst_position,
                                                             int src_position) {
  __mlvm_stream_cvtint4_int8_tz(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int82int4_oz(int4x2_t* dst,
                                                             char* src,
                                                             int size,
                                                             int dst_position,
                                                             int src_position) {
  __mlvm_stream_cvtint4_int8_oz(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int82int4_up(int4x2_t* dst,
                                                             char* src,
                                                             int size,
                                                             int dst_position,
                                                             int src_position) {
  __mlvm_stream_cvtint4_int8_up(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int82int4_dn(int4x2_t* dst,
                                                             char* src,
                                                             int size,
                                                             int dst_position,
                                                             int src_position) {
  __mlvm_stream_cvtint4_int8_dn(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int82int4_rd(int4x2_t* dst,
                                                             char* src,
                                                             int size,
                                                             int dst_position,
                                                             int src_position) {
  __mlvm_stream_cvtint4_int8_rd(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int82int4_rm(int4x2_t* dst,
                                                             char* src,
                                                             int size,
                                                             int dst_position,
                                                             int src_position) {
  __mlvm_stream_cvtint4_int8_rm(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int82int4_rn(int4x2_t* dst,
                                                             char* src,
                                                             int size,
                                                             int dst_position,
                                                             int src_position) {
  __mlvm_stream_cvtint4_int8_rn(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int162int4_tz(int4x2_t* dst,
                                                              short* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position) {
  __mlvm_stream_cvtint4_int16_tz(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int162int4_oz(int4x2_t* dst,
                                                              short* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position) {
  __mlvm_stream_cvtint4_int16_oz(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int162int4_up(int4x2_t* dst,
                                                              short* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position) {
  __mlvm_stream_cvtint4_int16_up(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int162int4_dn(int4x2_t* dst,
                                                              short* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position) {
  __mlvm_stream_cvtint4_int16_dn(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int162int4_rd(int4x2_t* dst,
                                                              short* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position) {
  __mlvm_stream_cvtint4_int16_rd(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int162int4_rm(int4x2_t* dst,
                                                              short* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position) {
  __mlvm_stream_cvtint4_int16_rm(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int162int4_rn(int4x2_t* dst,
                                                              short* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position) {
  __mlvm_stream_cvtint4_int16_rn(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int322int4_tz(int4x2_t* dst,
                                                              int* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position) {
  __mlvm_stream_cvtint4_int32_tz(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int322int4_oz(int4x2_t* dst,
                                                              int* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position) {
  __mlvm_stream_cvtint4_int32_oz(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int322int4_up(int4x2_t* dst,
                                                              int* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position) {
  __mlvm_stream_cvtint4_int32_up(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int322int4_dn(int4x2_t* dst,
                                                              int* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position) {
  __mlvm_stream_cvtint4_int32_dn(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int322int4_rd(int4x2_t* dst,
                                                              int* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position) {
  __mlvm_stream_cvtint4_int32_rd(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int322int4_rm(int4x2_t* dst,
                                                              int* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position) {
  __mlvm_stream_cvtint4_int32_rm(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int322int4_rn(int4x2_t* dst,
                                                              int* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position) {
  __mlvm_stream_cvtint4_int32_rn(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42float_tz(float* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int src_position) {
  __mlvm_stream_cvtfloat_int4_tz(dst, src, size, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42float_oz(float* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int src_position) {
  __mlvm_stream_cvtfloat_int4_oz(dst, src, size, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42float_up(float* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int src_position) {
  __mlvm_stream_cvtfloat_int4_up(dst, src, size, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42float_dn(float* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int src_position) {
  __mlvm_stream_cvtfloat_int4_dn(dst, src, size, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42float_rd(float* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int src_position) {
  __mlvm_stream_cvtfloat_int4_rd(dst, src, size, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42float_rm(float* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int src_position) {
  __mlvm_stream_cvtfloat_int4_rm(dst, src, size, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42float_rn(float* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int src_position) {
  __mlvm_stream_cvtfloat_int4_rn(dst, src, size, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42half_tz(half* dst,
                                                             int4x2_t* src,
                                                             int size,
                                                             int src_position) {
  __mlvm_stream_cvthalf_int4_tz(dst, src, size, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42half_oz(half* dst,
                                                             int4x2_t* src,
                                                             int size,
                                                             int src_position) {
  __mlvm_stream_cvthalf_int4_oz(dst, src, size, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42half_up(half* dst,
                                                             int4x2_t* src,
                                                             int size,
                                                             int src_position) {
  __mlvm_stream_cvthalf_int4_up(dst, src, size, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42half_dn(half* dst,
                                                             int4x2_t* src,
                                                             int size,
                                                             int src_position) {
  __mlvm_stream_cvthalf_int4_dn(dst, src, size, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42half_rd(half* dst,
                                                             int4x2_t* src,
                                                             int size,
                                                             int src_position) {
  __mlvm_stream_cvthalf_int4_rd(dst, src, size, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42half_rm(half* dst,
                                                             int4x2_t* src,
                                                             int size,
                                                             int src_position) {
  __mlvm_stream_cvthalf_int4_rm(dst, src, size, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42half_rn(half* dst,
                                                             int4x2_t* src,
                                                             int size,
                                                             int src_position) {
  __mlvm_stream_cvthalf_int4_rn(dst, src, size, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42bfloat16_tz(bfloat16_t* dst,
                                                                 int4x2_t* src,
                                                                 int size,
                                                                 int src_position) {
  __mlvm_stream_cvtbf16_int4_tz(dst, src, size, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42bfloat16_dn(bfloat16_t* dst,
                                                                 int4x2_t* src,
                                                                 int size,
                                                                 int src_position) {
  __mlvm_stream_cvtbf16_int4_dn(dst, src, size, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42bfloat16_oz(bfloat16_t* dst,
                                                                 int4x2_t* src,
                                                                 int size,
                                                                 int src_position) {
  __mlvm_stream_cvtbf16_int4_oz(dst, src, size, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42bfloat16_up(bfloat16_t* dst,
                                                                 int4x2_t* src,
                                                                 int size,
                                                                 int src_position) {
  __mlvm_stream_cvtbf16_int4_up(dst, src, size, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42bfloat16_rd(bfloat16_t* dst,
                                                                 int4x2_t* src,
                                                                 int size,
                                                                 int src_position) {
  __mlvm_stream_cvtbf16_int4_rd(dst, src, size, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42bfloat16_rm(bfloat16_t* dst,
                                                                 int4x2_t* src,
                                                                 int size,
                                                                 int src_position) {
  __mlvm_stream_cvtbf16_int4_rm(dst, src, size, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42bfloat16_rn(bfloat16_t* dst,
                                                                 int4x2_t* src,
                                                                 int size,
                                                                 int src_position) {
  __mlvm_stream_cvtbf16_int4_rn(dst, src, size, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42int8_tz(char* dst,
                                                             int4x2_t* src,
                                                             int size,
                                                             int dst_position,
                                                             int src_position) {
  __mlvm_stream_cvtint8_int4_tz(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42int8_oz(char* dst,
                                                             int4x2_t* src,
                                                             int size,
                                                             int dst_position,
                                                             int src_position) {
  __mlvm_stream_cvtint8_int4_oz(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42int8_up(char* dst,
                                                             int4x2_t* src,
                                                             int size,
                                                             int dst_position,
                                                             int src_position) {
  __mlvm_stream_cvtint8_int4_up(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42int8_dn(char* dst,
                                                             int4x2_t* src,
                                                             int size,
                                                             int dst_position,
                                                             int src_position) {
  __mlvm_stream_cvtint8_int4_dn(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42int8_rd(char* dst,
                                                             int4x2_t* src,
                                                             int size,
                                                             int dst_position,
                                                             int src_position) {
  __mlvm_stream_cvtint8_int4_rd(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42int8_rm(char* dst,
                                                             int4x2_t* src,
                                                             int size,
                                                             int dst_position,
                                                             int src_position) {
  __mlvm_stream_cvtint8_int4_rm(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42int8_rn(char* dst,
                                                             int4x2_t* src,
                                                             int size,
                                                             int dst_position,
                                                             int src_position) {
  __mlvm_stream_cvtint8_int4_rn(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42int16_tz(short* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position) {
  __mlvm_stream_cvtint16_int4_tz(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42int16_oz(short* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position) {
  __mlvm_stream_cvtint16_int4_oz(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42int16_up(short* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position) {
  __mlvm_stream_cvtint16_int4_up(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42int16_dn(short* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position) {
  __mlvm_stream_cvtint16_int4_dn(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42int16_rd(short* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position) {
  __mlvm_stream_cvtint16_int4_rd(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42int16_rm(short* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position) {
  __mlvm_stream_cvtint16_int4_rm(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42int16_rn(short* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position) {
  __mlvm_stream_cvtint16_int4_rn(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42int32_tz(int* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position) {
  __mlvm_stream_cvtint32_int4_tz(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42int32_oz(int* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position) {
  __mlvm_stream_cvtint32_int4_oz(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42int32_up(int* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position) {
  __mlvm_stream_cvtint32_int4_up(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42int32_dn(int* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position) {
  __mlvm_stream_cvtint32_int4_dn(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42int32_rd(int* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position) {
  __mlvm_stream_cvtint32_int4_rd(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42int32_rm(int* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position) {
  __mlvm_stream_cvtint32_int4_rm(dst, src, size, dst_position, src_position);
}

static __mlu_func__ __mlu_builtin__ void __bang_int42int32_rn(int* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position) {
  __mlvm_stream_cvtint32_int4_rn(dst, src, size, dst_position, src_position);
}
#endif  // __BANG_ARCH__ != 303
#endif  // __BANG_ARCH__ >= 300

// -----------------------------------------------------------------------------
// Bang C/C++ math function: scalar atomic add operation
// -----------------------------------------------------------------------------
// TODO(libaoliang): figure out how to block 322 without breaking libdevice
#if __BANG_ARCH__ >= 200 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
static __mlu_func__ __mlu_builtin__ void __bang_atomic_add(unsigned short* dst,
                                                           unsigned short* src1,
                                                           unsigned short src2,
                                                           int size = 1) {
  __mlvm_scalar_atom_add_u16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_add(short* dst,
                                                           short* src1,
                                                           short src2,
                                                           int size = 1) {
  __mlvm_scalar_atom_add_s16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_add(unsigned int* dst,
                                                           unsigned int* src1,
                                                           unsigned int src2,
                                                           int size = 1) {
  __mlvm_scalar_atom_add_u32(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_add(int* dst,
                                                           int* src1,
                                                           int src2,
                                                           int size = 1) {
  __mlvm_scalar_atom_add_s32(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_add(half* dst,
                                                           half* src1,
                                                           half src2,
                                                           int size = 1) {
  __mlvm_scalar_atom_add_f16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_add(float* dst,
                                                           float* src1,
                                                           float src2,
                                                           int size = 1) {
  __mlvm_scalar_atom_add_f32(dst, src1, src2, size);
}
#endif  // __BANG_ARCH__ >= 200 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 306
static __mlu_func__ __mlu_builtin__ void __bang_atomic_add(bfloat16_t* dst,
                                                           bfloat16_t* src1,
                                                           bfloat16_t src2,
                                                           int size = 1) {
  __asm__ ("atom.add.scalar.bf16 \t[%[dst]], [%[src1]], %[src2], %[size];\n\t"
           ::[dst] "r"(dst), [src1] "r"(src1), [src2] "r"(src2), [size] "r"(size));
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 306

// -----------------------------------------------------------------------------
// Bang C/C++ math function: scalar atomic reduce add operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_add(short* dst,
                                                                  short src1,
                                                                  int size = 1) {
  __mlvm_scalar_atom_reduce_add_s16(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_add(int* dst,
                                                                  int src1,
                                                                  int size = 1) {
  __mlvm_scalar_atom_reduce_add_s32(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_add(half* dst,
                                                                  half src1,
                                                                  int size = 1) {
  __mlvm_scalar_atom_reduce_add_f16(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_add(float* dst,
                                                                  float src1,
                                                                  int size = 1) {
  __mlvm_scalar_atom_reduce_add_f32(dst, src1, size);
}
#endif  // __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 306
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_add(bfloat16_t* dst,
                                                                  bfloat16_t src1,
                                                                  int size = 1) {
  __asm__ ("atom.add.scalar.reduce.bf16 \t[%[dst]], %[src1], %[size];\n\t"
           ::[dst] "r"(dst), [src1] "r"(src1), [size] "r"(size));
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 306

// -----------------------------------------------------------------------------
// Bang C/C++ math function: scalar atomic increase operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
static __mlu_func__ __mlu_builtin__ void __bang_atomic_inc(unsigned short* dst,
                                                           unsigned short* src1,
                                                           unsigned short src2,
                                                           int size = 1) {
  __mlvm_scalar_atom_inc_u16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_inc(short* dst,
                                                           short* src1,
                                                           short src2,
                                                           int size = 1) {
  __mlvm_scalar_atom_inc_s16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_inc(unsigned int* dst,
                                                           unsigned int* src1,
                                                           unsigned int src2,
                                                           int size = 1) {
  __mlvm_scalar_atom_inc_u32(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_inc(int* dst,
                                                           int* src1,
                                                           int src2,
                                                           int size = 1) {
  __mlvm_scalar_atom_inc_s32(dst, src1, src2, size);
}
#endif  // __BANG_ARCH__ >= 200 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: scalar atomic reduce increment operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_inc(unsigned short* dst,
                                                                  unsigned short src1,
                                                                  int size = 1) {
  __mlvm_scalar_atom_reduce_inc_u16(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_inc(short* dst,
                                                                  short src1,
                                                                  int size = 1) {
  __mlvm_scalar_atom_reduce_inc_s16(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_inc(unsigned int* dst,
                                                                  unsigned int src1,
                                                                  int size = 1) {
  __mlvm_scalar_atom_reduce_inc_u32(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_inc(int* dst,
                                                                  int src1,
                                                                  int size = 1) {
  __mlvm_scalar_atom_reduce_inc_s32(dst, src1, size);
}
#endif  // __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: scalar atomic decrease operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
static __mlu_func__ __mlu_builtin__ void __bang_atomic_dec(unsigned short* dst,
                                                           unsigned short* src1,
                                                           unsigned short src2,
                                                           int size = 1) {
  __mlvm_scalar_atom_dec_u16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_dec(short* dst,
                                                           short* src1,
                                                           short src2,
                                                           int size = 1) {
  __mlvm_scalar_atom_dec_s16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_dec(unsigned int* dst,
                                                           unsigned int* src1,
                                                           unsigned int src2,
                                                           int size = 1) {
  __mlvm_scalar_atom_dec_u32(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_dec(int* dst,
                                                           int* src1,
                                                           int src2,
                                                           int size = 1) {
  __mlvm_scalar_atom_dec_s32(dst, src1, src2, size);
}
#endif  // __BANG_ARCH__ >= 200 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: scalar atomic reduce decrement operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_dec(unsigned short* dst,
                                                                  unsigned short src1,
                                                                  int size = 1) {
  __mlvm_scalar_atom_reduce_dec_u16(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_dec(short* dst,
                                                                  short src1,
                                                                  int size = 1) {
  __mlvm_scalar_atom_reduce_dec_s16(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_dec(unsigned int* dst,
                                                                  unsigned int src1,
                                                                  int size = 1) {
  __mlvm_scalar_atom_reduce_dec_u32(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_dec(int* dst,
                                                                  int src1,
                                                                  int size = 1) {
  __mlvm_scalar_atom_reduce_dec_s32(dst, src1, size);
}
#endif  // __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: scalar atomic max operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
static __mlu_func__ __mlu_builtin__ void __bang_atomic_max(unsigned short* dst,
                                                           unsigned short* src1,
                                                           unsigned short src2,
                                                           int size = 1) {
  __mlvm_scalar_atom_max_u16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_max(short* dst,
                                                           short* src1,
                                                           short src2,
                                                           int size = 1) {
  __mlvm_scalar_atom_max_s16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_max(unsigned int* dst,
                                                           unsigned int* src1,
                                                           unsigned int src2,
                                                           int size = 1) {
  __mlvm_scalar_atom_max_u32(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_max(int* dst,
                                                           int* src1,
                                                           int src2,
                                                           int size = 1) {
  __mlvm_scalar_atom_max_s32(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_max(half* dst,
                                                           half* src1,
                                                           half src2,
                                                           int size = 1) {
  __mlvm_scalar_atom_max_f16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_max(float* dst,
                                                           float* src1,
                                                           float src2,
                                                           int size = 1) {
  __mlvm_scalar_atom_max_f32(dst, src1, src2, size);
}
#endif  // __BANG_ARCH__ >= 200 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 306
static __mlu_func__ __mlu_builtin__ void __bang_atomic_max(bfloat16_t* dst,
                                                           bfloat16_t* src1,
                                                           bfloat16_t src2,
                                                           int size = 1) {
  __asm__ ("atom.max.scalar.bf16 \t[%[dst]], [%[src1]], %[src2], %[size];\n\t"
           ::[dst] "r"(dst), [src1] "r"(src1), [src2] "r"(src2), [size] "r"(size));
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 306

// -----------------------------------------------------------------------------
// Bang C/C++ math function: scalar atomic reduce maximum operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_max(unsigned short* dst,
                                                                  unsigned short src1,
                                                                  int size = 1) {
  __mlvm_scalar_atom_reduce_max_u16(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_max(short* dst,
                                                                  short src1,
                                                                  int size = 1) {
  __mlvm_scalar_atom_reduce_max_s16(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_max(unsigned int* dst,
                                                                  unsigned int src1,
                                                                  int size = 1) {
  __mlvm_scalar_atom_reduce_max_u32(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_max(int* dst,
                                                                  int src1,
                                                                  int size = 1) {
  __mlvm_scalar_atom_reduce_max_s32(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_max(half* dst,
                                                                  half src1,
                                                                  int size = 1) {
  __mlvm_scalar_atom_reduce_max_f16(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_max(float* dst,
                                                                  float src1,
                                                                  int size = 1) {
  __mlvm_scalar_atom_reduce_max_f32(dst, src1, size);
}
#endif  // __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 306
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_max(bfloat16_t* dst,
                                                                  bfloat16_t src1,
                                                                  int size = 1) {
  __asm__ ("atom.max.scalar.reduce.bf16 \t[%[dst]], %[src1], %[size];\n\t"
           ::[dst] "r"(dst), [src1] "r"(src1), [size] "r"(size));
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 306

// -----------------------------------------------------------------------------
// Bang C/C++ math function: scalar atomic min operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
static __mlu_func__ __mlu_builtin__ void __bang_atomic_min(unsigned short* dst,
                                                           unsigned short* src1,
                                                           unsigned short src2,
                                                           int size = 1) {
  __mlvm_scalar_atom_min_u16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_min(short* dst,
                                                           short* src1,
                                                           short src2,
                                                           int size = 1) {
  __mlvm_scalar_atom_min_s16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_min(unsigned int* dst,
                                                           unsigned int* src1,
                                                           unsigned int src2,
                                                           int size = 1) {
  __mlvm_scalar_atom_min_u32(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_min(int* dst,
                                                           int* src1,
                                                           int src2,
                                                           int size = 1) {
  __mlvm_scalar_atom_min_s32(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_min(half* dst,
                                                           half* src1,
                                                           half src2,
                                                           int size = 1) {
  __mlvm_scalar_atom_min_f16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_min(float* dst,
                                                           float* src1,
                                                           float src2,
                                                           int size = 1) {
  __mlvm_scalar_atom_min_f32(dst, src1, src2, size);
}
#endif  // __BANG_ARCH__ >= 200 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 306
static __mlu_func__ __mlu_builtin__ void __bang_atomic_min(bfloat16_t* dst,
                                                           bfloat16_t* src1,
                                                           bfloat16_t src2,
                                                           int size = 1) {
  __asm__ ("atom.min.scalar.bf16 \t[%[dst]], [%[src1]], %[src2], %[size];\n\t"
           ::[dst] "r"(dst), [src1] "r"(src1), [src2] "r"(src2), [size] "r"(size));
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 306

// -----------------------------------------------------------------------------
// Bang C/C++ math function: scalar atomic reduce minimum operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_min(unsigned short* dst,
                                                                  unsigned short src1,
                                                                  int size = 1) {
  __mlvm_scalar_atom_reduce_min_u16(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_min(short* dst,
                                                                  short src1,
                                                                  int size = 1) {
  __mlvm_scalar_atom_reduce_min_s16(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_min(unsigned int* dst,
                                                                  unsigned int src1,
                                                                  int size = 1) {
  __mlvm_scalar_atom_reduce_min_u32(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_min(int* dst,
                                                                  int src1,
                                                                  int size = 1) {
  __mlvm_scalar_atom_reduce_min_s32(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_min(half* dst,
                                                                  half src1,
                                                                  int size = 1) {
  __mlvm_scalar_atom_reduce_min_f16(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_min(float* dst,
                                                                  float src1,
                                                                  int size = 1) {
  __mlvm_scalar_atom_reduce_min_f32(dst, src1, size);
}
#endif  // __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 306
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_min(bfloat16_t* dst,
                                                                  bfloat16_t src1,
                                                                  int size = 1) {
  __asm__ ("atom.min.scalar.reduce.bf16 \t[%[dst]], %[src1], %[size];\n\t"
           ::[dst] "r"(dst), [src1] "r"(src1), [size] "r"(size));
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 306

// -----------------------------------------------------------------------------
// Bang C/C++ math function: scalar atomic and operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
static __mlu_func__ __mlu_builtin__ void __bang_atomic_and(unsigned short* dst,
                                                           unsigned short* src1,
                                                           unsigned short src2,
                                                           int size = 1) {
  __mlvm_scalar_atom_and_u16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_and(short* dst,
                                                           short* src1,
                                                           short src2,
                                                           int size = 1) {
  __mlvm_scalar_atom_and_s16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_and(unsigned int* dst,
                                                           unsigned int* src1,
                                                           unsigned int src2,
                                                           int size = 1) {
  __mlvm_scalar_atom_and_u32(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_and(int* dst,
                                                           int* src1,
                                                           int src2,
                                                           int size = 1) {
  __mlvm_scalar_atom_and_s32(dst, src1, src2, size);
}
#endif  // __BANG_ARCH__ >= 200 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: scalar atomic reduce and operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_and(short* dst,
                                                                  short src1,
                                                                  int size = 1) {
  __mlvm_scalar_atom_reduce_and_s16(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_and(int* dst,
                                                                  int src1,
                                                                  int size = 1) {
  __mlvm_scalar_atom_reduce_and_s32(dst, src1, size);
}
#endif  // __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: scalar atomic or operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
static __mlu_func__ __mlu_builtin__ void __bang_atomic_or(unsigned short* dst,
                                                          unsigned short* src1,
                                                          unsigned short src2,
                                                          int size = 1) {
  __mlvm_scalar_atom_or_u16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_or(short* dst,
                                                          short* src1,
                                                          short src2,
                                                          int size = 1) {
  __mlvm_scalar_atom_or_s16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_or(unsigned int* dst,
                                                          unsigned int* src1,
                                                          unsigned int src2,
                                                          int size = 1) {
  __mlvm_scalar_atom_or_u32(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_or(int* dst,
                                                          int* src1,
                                                          int src2,
                                                          int size = 1) {
  __mlvm_scalar_atom_or_s32(dst, src1, src2, size);
}
#endif  // __BANG_ARCH__ >= 200 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: scalar atomic reduce or operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_or(short* dst,
                                                                 short src1,
                                                                 int size = 1) {
  __mlvm_scalar_atom_reduce_or_s16(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_or(int* dst,
                                                                 int src1,
                                                                 int size = 1) {
  __mlvm_scalar_atom_reduce_or_s32(dst, src1, size);
}
#endif  // __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: scalar atomic xor operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
static __mlu_func__ __mlu_builtin__ void __bang_atomic_xor(unsigned short* dst,
                                                           unsigned short* src1,
                                                           unsigned short src2,
                                                           int size = 1) {
  __mlvm_scalar_atom_xor_u16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_xor(short* dst,
                                                           short* src1,
                                                           short src2,
                                                           int size = 1) {
  __mlvm_scalar_atom_xor_s16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_xor(unsigned int* dst,
                                                           unsigned int* src1,
                                                           unsigned int src2,
                                                           int size = 1) {
  __mlvm_scalar_atom_xor_u32(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_xor(int* dst,
                                                           int* src1,
                                                           int src2,
                                                           int size = 1) {
  __mlvm_scalar_atom_xor_s32(dst, src1, src2, size);
}
#endif  // __BANG_ARCH__ >= 200 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: scalar atomic reduce xor operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_xor(short* dst,
                                                                  short src1,
                                                                  int size = 1) {
  __mlvm_scalar_atom_reduce_xor_s16(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_xor(int* dst,
                                                                  int src1,
                                                                  int size = 1) {
  __mlvm_scalar_atom_reduce_xor_s32(dst, src1, size);
}
#endif  // __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: scalar atomic compare-and-swap operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
static __mlu_func__ __mlu_builtin__ void __bang_atomic_cas(unsigned short* dst,
                                                           unsigned short* src1,
                                                           unsigned short src2,
                                                           unsigned short src3) {
  __mlvm_scalar_atom_cas_u16(dst, src1, src2, src3);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_cas(short* dst,
                                                           short* src1,
                                                           short src2,
                                                           short src3) {
  __mlvm_scalar_atom_cas_s16(dst, src1, src2, src3);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_cas(unsigned int* dst,
                                                           unsigned int* src1,
                                                           unsigned int src2,
                                                           unsigned int src3) {
  __mlvm_scalar_atom_cas_u32(dst, src1, src2, src3);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_cas(int* dst,
                                                           int* src1,
                                                           int src2,
                                                           int src3) {
  __mlvm_scalar_atom_cas_s32(dst, src1, src2, src3);
}
#endif  // __BANG_ARCH__ >= 200 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 306
static __mlu_func__ __mlu_builtin__ void __bang_atomic_cas(half* dst,
                                                           half* src1,
                                                           half src2,
                                                           half src3) {
  __mlvm_scalar_atom_cas_f16(dst, src1, src2, src3);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_cas(float* dst,
                                                           float* src1,
                                                           float src2,
                                                           float src3) {
  __mlvm_scalar_atom_cas_f32(dst, src1, src2, src3);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_cas(bfloat16_t* dst,
                                                           bfloat16_t* src1,
                                                           bfloat16_t src2,
                                                           bfloat16_t src3) {
  __asm__ ("atom.cas.scalar.bf16 \t[%[dst]], [%[src1]], %[src2], %[src3];\n\t"
           ::[dst] "r"(dst), [src1] "r"(src1), [src2] "r"(src2), [src3] "r"(src3));
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 306

// -----------------------------------------------------------------------------
// Bang C/C++ math function: scalar atomic reduce compare-and-swap operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_cas(short* dst,
                                                                  short src1,
                                                                  short src2) {
  __mlvm_scalar_atom_reduce_cas_s16(dst, src1, src2);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_cas(int* dst,
                                                                  int src1,
                                                                  int src2) {
  __mlvm_scalar_atom_reduce_cas_s32(dst, src1, src2);
}
#endif  // __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 306
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_cas(half* dst,
                                                                  half src1,
                                                                  half src2) {
  __mlvm_scalar_atom_reduce_cas_f16(dst, src1, src2);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_cas(float* dst,
                                                                  float src1,
                                                                  float src2) {
  __mlvm_scalar_atom_reduce_cas_f32(dst, src1, src2);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_cas(bfloat16_t* dst,
                                                                  bfloat16_t src1,
                                                                  bfloat16_t src2) {
  __asm__ ("atom.cas.scalar.reduce.bf16 \t[%[dst]], %[src1], %[src2];\n\t"
           ::[dst] "r"(dst), [src1] "r"(src1), [src2] "r"(src2));
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 306

// -----------------------------------------------------------------------------
// Bang C/C++ math function: scalar atomic exchange operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
static __mlu_func__ __mlu_builtin__ void __bang_atomic_exch(unsigned short* dst,
                                                            unsigned short* src1,
                                                            unsigned short src2,
                                                            int size = 1) {
  __mlvm_scalar_atom_exch_u16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_exch(short* dst,
                                                            short* src1,
                                                            short src2,
                                                            int size = 1) {
  __mlvm_scalar_atom_exch_s16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_exch(unsigned int* dst,
                                                            unsigned int* src1,
                                                            unsigned int src2,
                                                            int size = 1) {
  __mlvm_scalar_atom_exch_u32(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_exch(int* dst,
                                                            int* src1,
                                                            int src2,
                                                            int size = 1) {
  __mlvm_scalar_atom_exch_s32(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_exch(half* dst,
                                                            half* src1,
                                                            half src2,
                                                            int size = 1) {
  __mlvm_scalar_atom_exch_f16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_exch(float* dst,
                                                            float* src1,
                                                            float src2,
                                                            int size = 1) {
  __mlvm_scalar_atom_exch_f32(dst, src1, src2, size);
}
#endif  // __BANG_ARCH__ >= 200 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 306
static __mlu_func__ __mlu_builtin__ void __bang_atomic_exch(bfloat16_t* dst,
                                                            bfloat16_t* src1,
                                                            bfloat16_t src2,
                                                            int size = 1) {
  __asm__ ("atom.exch.scalar.bf16 \t[%[dst]], [%[src1]], %[src2], %[size];\n\t"
           ::[dst] "r"(dst), [src1] "r"(src1), [src2] "r"(src2), [size] "r"(size));
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 306

// -----------------------------------------------------------------------------
// Bang C/C++ math function: scalar atomic reduce exchange operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_exch(short* dst,
                                                                   short src1,
                                                                   int size = 1) {
  __mlvm_scalar_atom_reduce_exch_s16(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_exch(int* dst,
                                                                   int src1,
                                                                   int size = 1) {
  __mlvm_scalar_atom_reduce_exch_s32(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_exch(half* dst,
                                                                   half src1,
                                                                   int size = 1) {
  __mlvm_scalar_atom_reduce_exch_f16(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_exch(float* dst,
                                                                   float src1,
                                                                   int size = 1) {
  __mlvm_scalar_atom_reduce_exch_f32(dst, src1, size);
}
#endif  // __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 306
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_exch(bfloat16_t* dst,
                                                                   bfloat16_t src1,
                                                                   int size = 1) {
  __asm__ ("atom.exch.scalar.reduce.bf16 \t[%[dst]], %[src1], %[size];\n\t"
           ::[dst] "r"(dst), [src1] "r"(src1), [size] "r"(size));
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 306

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream atomic add operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
static __mlu_func__ __mlu_builtin__ void __bang_atomic_add(unsigned short* dst,
                                                           unsigned short* src1,
                                                           unsigned short* src2,
                                                           int size) {
  __mlvm_stream_atom_add_u16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_add(short* dst,
                                                           short* src1,
                                                           short* src2,
                                                           int size) {
  __mlvm_stream_atom_add_s16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_add(unsigned int* dst,
                                                           unsigned int* src1,
                                                           unsigned int* src2,
                                                           int size) {
  __mlvm_stream_atom_add_u32(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_add(int* dst,
                                                           int* src1,
                                                           int* src2,
                                                           int size) {
  __mlvm_stream_atom_add_s32(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_add(half* dst,
                                                           half* src1,
                                                           half* src2,
                                                           int size) {
  __mlvm_stream_atom_add_f16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_add(float* dst,
                                                           float* src1,
                                                           float* src2,
                                                           int size) {
  __mlvm_stream_atom_add_f32(dst, src1, src2, size);
}
#endif  // __BANG_ARCH__ >= 200 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 306
static __mlu_func__ __mlu_builtin__ void __bang_atomic_add(bfloat16_t* dst,
                                                           bfloat16_t* src1,
                                                           bfloat16_t* src2,
                                                           int size) {
  __mlvm_stream_atom_add_bf16(dst, src1, src2, size);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 306

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream atomic reduce add operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_add(short* dst,
                                                                  short* src1,
                                                                  int size) {
  __mlvm_stream_atom_reduce_add_s16(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_add(int* dst,
                                                                  int* src1,
                                                                  int size) {
  __mlvm_stream_atom_reduce_add_s32(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_add(half* dst,
                                                                  half* src1,
                                                                  int size) {
  __mlvm_stream_atom_reduce_add_f16(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_add(float* dst,
                                                                  float* src1,
                                                                  int size) {
  __mlvm_stream_atom_reduce_add_f32(dst, src1, size);
}
#endif  // __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 306
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_add(bfloat16_t* dst,
                                                                  bfloat16_t* src1,
                                                                  int size) {
  __mlvm_stream_atom_reduce_add_bf16(dst, src1, size);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 306

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream atomic increase operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
static __mlu_func__ __mlu_builtin__ void __bang_atomic_inc(unsigned short* dst,
                                                           unsigned short* src1,
                                                           unsigned short* src2,
                                                           int size) {
  __mlvm_stream_atom_inc_u16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_inc(short* dst,
                                                           short* src1,
                                                           short* src2,
                                                           int size) {
  __mlvm_stream_atom_inc_s16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_inc(unsigned int* dst,
                                                           unsigned int* src1,
                                                           unsigned int* src2,
                                                           int size) {
  __mlvm_stream_atom_inc_u32(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_inc(int* dst,
                                                           int* src1,
                                                           int* src2,
                                                           int size) {
  __mlvm_stream_atom_inc_s32(dst, src1, src2, size);
}
#endif  // __BANG_ARCH__ >= 200 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream atomic reduce increment operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_inc(unsigned short* dst,
                                                                  unsigned short* src1,
                                                                  int size) {
  __mlvm_stream_atom_reduce_inc_u16(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_inc(short* dst,
                                                                  short* src1,
                                                                  int size) {
  __mlvm_stream_atom_reduce_inc_s16(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_inc(unsigned int* dst,
                                                                  unsigned int* src1,
                                                                  int size) {
  __mlvm_stream_atom_reduce_inc_u32(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_inc(int* dst,
                                                                  int* src1,
                                                                  int size) {
  __mlvm_stream_atom_reduce_inc_s32(dst, src1, size);
}
#endif  // __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream atomic decrease operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
static __mlu_func__ __mlu_builtin__ void __bang_atomic_dec(unsigned short* dst,
                                                           unsigned short* src1,
                                                           unsigned short* src2,
                                                           int size) {
  __mlvm_stream_atom_dec_u16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_dec(short* dst,
                                                           short* src1,
                                                           short* src2,
                                                           int size) {
  __mlvm_stream_atom_dec_s16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_dec(unsigned int* dst,
                                                           unsigned int* src1,
                                                           unsigned int* src2,
                                                           int size) {
  __mlvm_stream_atom_dec_u32(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_dec(int* dst,
                                                           int* src1,
                                                           int* src2,
                                                           int size) {
  __mlvm_stream_atom_dec_s32(dst, src1, src2, size);
}
#endif  // __BANG_ARCH__ >= 200 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream atomic reduce decrement operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_dec(unsigned short* dst,
                                                                  unsigned short* src1,
                                                                  int size) {
  __mlvm_stream_atom_reduce_dec_u16(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_dec(short* dst,
                                                                  short* src1,
                                                                  int size) {
  __mlvm_stream_atom_reduce_dec_s16(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_dec(unsigned int* dst,
                                                                  unsigned int* src1,
                                                                  int size) {
  __mlvm_stream_atom_reduce_dec_u32(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_dec(int* dst,
                                                                  int* src1,
                                                                  int size) {
  __mlvm_stream_atom_reduce_dec_s32(dst, src1, size);
}
#endif  // __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream atomic max operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
static __mlu_func__ __mlu_builtin__ void __bang_atomic_max(unsigned short* dst,
                                                           unsigned short* src1,
                                                           unsigned short* src2,
                                                           int size) {
  __mlvm_stream_atom_max_u16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_max(short* dst,
                                                           short* src1,
                                                           short* src2,
                                                           int size) {
  __mlvm_stream_atom_max_s16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_max(unsigned int* dst,
                                                           unsigned int* src1,
                                                           unsigned int* src2,
                                                           int size) {
  __mlvm_stream_atom_max_u32(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_max(int* dst,
                                                           int* src1,
                                                           int* src2,
                                                           int size) {
  __mlvm_stream_atom_max_s32(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_max(half* dst,
                                                           half* src1,
                                                           half* src2,
                                                           int size) {
  __mlvm_stream_atom_max_f16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_max(float* dst,
                                                           float* src1,
                                                           float* src2,
                                                           int size) {
  __mlvm_stream_atom_max_f32(dst, src1, src2, size);
}
#endif  // __BANG_ARCH__ >= 200 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 306
static __mlu_func__ __mlu_builtin__ void __bang_atomic_max(bfloat16_t* dst,
                                                           bfloat16_t* src1,
                                                           bfloat16_t* src2,
                                                           int size) {
  __mlvm_stream_atom_max_bf16(dst, src1, src2, size);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 306

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream atomic reduce maximum operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_max(unsigned short* dst,
                                                                  unsigned short* src1,
                                                                  int size) {
  __mlvm_stream_atom_reduce_max_u16(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_max(short* dst,
                                                                  short* src1,
                                                                  int size) {
  __mlvm_stream_atom_reduce_max_s16(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_max(unsigned int* dst,
                                                                  unsigned int* src1,
                                                                  int size) {
  __mlvm_stream_atom_reduce_max_u32(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_max(int* dst,
                                                                  int* src1,
                                                                  int size) {
  __mlvm_stream_atom_reduce_max_s32(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_max(half* dst,
                                                                  half* src1,
                                                                  int size) {
  __mlvm_stream_atom_reduce_max_f16(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_max(float* dst,
                                                                  float* src1,
                                                                  int size) {
  __mlvm_stream_atom_reduce_max_f32(dst, src1, size);
}
#endif  // __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 306
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_max(bfloat16_t* dst,
                                                                  bfloat16_t* src1,
                                                                  int size) {
  __mlvm_stream_atom_reduce_max_bf16(dst, src1, size);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 306

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream atomic min operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
static __mlu_func__ __mlu_builtin__ void __bang_atomic_min(unsigned short* dst,
                                                           unsigned short* src1,
                                                           unsigned short* src2,
                                                           int size) {
  __mlvm_stream_atom_min_u16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_min(short* dst,
                                                           short* src1,
                                                           short* src2,
                                                           int size) {
  __mlvm_stream_atom_min_s16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_min(unsigned int* dst,
                                                           unsigned int* src1,
                                                           unsigned int* src2,
                                                           int size) {
  __mlvm_stream_atom_min_u32(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_min(int* dst,
                                                           int* src1,
                                                           int* src2,
                                                           int size) {
  __mlvm_stream_atom_min_s32(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_min(half* dst,
                                                           half* src1,
                                                           half* src2,
                                                           int size) {
  __mlvm_stream_atom_min_f16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_min(float* dst,
                                                           float* src1,
                                                           float* src2,
                                                           int size) {
  __mlvm_stream_atom_min_f32(dst, src1, src2, size);
}
#endif  // __BANG_ARCH__ >= 200 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 306
static __mlu_func__ __mlu_builtin__ void __bang_atomic_min(bfloat16_t* dst,
                                                           bfloat16_t* src1,
                                                           bfloat16_t* src2,
                                                           int size) {
  __mlvm_stream_atom_max_bf16(dst, src1, src2, size);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 306

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream atomic reduce minimum operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_min(unsigned short* dst,
                                                                  unsigned short* src1,
                                                                  int size) {
  __mlvm_stream_atom_reduce_min_u16(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_min(short* dst,
                                                                  short* src1,
                                                                  int size) {
  __mlvm_stream_atom_reduce_min_s16(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_min(unsigned int* dst,
                                                                  unsigned int* src1,
                                                                  int size) {
  __mlvm_stream_atom_reduce_min_u32(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_min(int* dst,
                                                                  int* src1,
                                                                  int size) {
  __mlvm_stream_atom_reduce_min_s32(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_min(half* dst,
                                                                  half* src1,
                                                                  int size) {
  __mlvm_stream_atom_reduce_min_f16(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_min(float* dst,
                                                                  float* src1,
                                                                  int size) {
  __mlvm_stream_atom_reduce_min_f32(dst, src1, size);
}
#endif  // __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 306
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_min(bfloat16_t* dst,
                                                                  bfloat16_t* src1,
                                                                  int size) {
  __mlvm_stream_atom_reduce_min_bf16(dst, src1, size);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 306

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream atomic and operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
static __mlu_func__ __mlu_builtin__ void __bang_atomic_and(unsigned short* dst,
                                                           unsigned short* src1,
                                                           unsigned short* src2,
                                                           int size) {
  __mlvm_stream_atom_and_u16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_and(short* dst,
                                                           short* src1,
                                                           short* src2,
                                                           int size) {
  __mlvm_stream_atom_and_s16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_and(unsigned int* dst,
                                                           unsigned int* src1,
                                                           unsigned int* src2,
                                                           int size) {
  __mlvm_stream_atom_and_u32(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_and(int* dst,
                                                           int* src1,
                                                           int* src2,
                                                           int size) {
  __mlvm_stream_atom_and_s32(dst, src1, src2, size);
}
#endif  // __BANG_ARCH__ >= 200 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream atomic reduce and operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_and(short* dst,
                                                                  short* src1,
                                                                  int size) {
  __mlvm_stream_atom_reduce_and_s16(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_and(int* dst,
                                                                  int* src1,
                                                                  int size) {
  __mlvm_stream_atom_reduce_and_s32(dst, src1, size);
}
#endif  // __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream atomic or operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
static __mlu_func__ __mlu_builtin__ void __bang_atomic_or(unsigned short* dst,
                                                          unsigned short* src1,
                                                          unsigned short* src2,
                                                          int size) {
  __mlvm_stream_atom_or_u16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_or(short* dst,
                                                          short* src1,
                                                          short* src2,
                                                          int size) {
  __mlvm_stream_atom_or_s16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_or(unsigned int* dst,
                                                          unsigned int* src1,
                                                          unsigned int* src2,
                                                          int size) {
  __mlvm_stream_atom_or_u32(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_or(int* dst,
                                                          int* src1,
                                                          int* src2,
                                                          int size) {
  __mlvm_stream_atom_or_s32(dst, src1, src2, size);
}
#endif  // __BANG_ARCH__ >= 200 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream atomic reduce or operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_or(short* dst,
                                                                 short* src1,
                                                                 int size) {
  __mlvm_stream_atom_reduce_or_s16(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_or(int* dst,
                                                                 int* src1,
                                                                 int size) {
  __mlvm_stream_atom_reduce_or_s32(dst, src1, size);
}
#endif  // __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream atomic xor operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
static __mlu_func__ __mlu_builtin__ void __bang_atomic_xor(unsigned short* dst,
                                                           unsigned short* src1,
                                                           unsigned short* src2,
                                                           int size) {
  __mlvm_stream_atom_xor_u16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_xor(short* dst,
                                                           short* src1,
                                                           short* src2,
                                                           int size) {
  __mlvm_stream_atom_xor_s16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_xor(unsigned int* dst,
                                                           unsigned int* src1,
                                                           unsigned int* src2,
                                                           int size) {
  __mlvm_stream_atom_xor_u32(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_xor(int* dst,
                                                           int* src1,
                                                           int* src2,
                                                           int size) {
  __mlvm_stream_atom_xor_s32(dst, src1, src2, size);
}
#endif  // __BANG_ARCH__ >= 200 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream atomic reduce xor operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_xor(short* dst,
                                                                  short* src1,
                                                                  int size) {
  __mlvm_stream_atom_reduce_xor_s16(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_xor(int* dst,
                                                                  int* src1,
                                                                  int size) {
  __mlvm_stream_atom_reduce_xor_s32(dst, src1, size);
}
#endif  // __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream atomic exchange operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 200 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
static __mlu_func__ __mlu_builtin__ void __bang_atomic_exch(unsigned short* dst,
                                                            unsigned short* src1,
                                                            unsigned short* src2,
                                                            int size) {
  __mlvm_stream_atom_exch_u16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_exch(short* dst,
                                                            short* src1,
                                                            short* src2,
                                                            int size) {
  __mlvm_stream_atom_exch_s16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_exch(unsigned int* dst,
                                                            unsigned int* src1,
                                                            unsigned int* src2,
                                                            int size) {
  __mlvm_stream_atom_exch_u32(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_exch(int* dst,
                                                            int* src1,
                                                            int* src2,
                                                            int size) {
  __mlvm_stream_atom_exch_s32(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_exch(half* dst,
                                                            half* src1,
                                                            half* src2,
                                                            int size) {
  __mlvm_stream_atom_exch_f16(dst, src1, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_exch(float* dst,
                                                            float* src1,
                                                            float* src2,
                                                            int size) {
  __mlvm_stream_atom_exch_f32(dst, src1, src2, size);
}
#endif  // __BANG_ARCH__ >= 200 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 306
static __mlu_func__ __mlu_builtin__ void __bang_atomic_exch(bfloat16_t* dst,
                                                            bfloat16_t* src1,
                                                            bfloat16_t* src2,
                                                            int size) {
  __mlvm_stream_atom_exch_bf16(dst, src1, src2, size);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 306

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream atomic reduce exchange operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_exch(short* dst,
                                                                   short* src1,
                                                                   int size) {
  __mlvm_stream_atom_reduce_exch_s16(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_exch(int* dst,
                                                                   int* src1,
                                                                   int size) {
  __mlvm_stream_atom_reduce_exch_s32(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_exch(half* dst,
                                                                   half* src1,
                                                                   int size) {
  __mlvm_stream_atom_reduce_exch_f16(dst, src1, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_exch(float* dst,
                                                                   float* src1,
                                                                   int size) {
  __mlvm_stream_atom_reduce_exch_f32(dst, src1, size);
}
#endif  // __BANG_ARCH__ >= 300 && __BANG_ARCH__ != 303 && __BANG_ARCH__ != 320 && __BANG_ARCH__ != 321
#if __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 306
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_exch(bfloat16_t* dst,
                                                                   bfloat16_t* src1,
                                                                   int size) {
  __mlvm_stream_atom_reduce_exch_bf16(dst, src1, size);
}
#endif  // __BANG_ARCH__ >= 392 || __BANG_ARCH__ == 306

// -----------------------------------------------------------------------------
// Bang C/C++ math function: discrete atomic add operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 392
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(short* dst,
                                                                    short* src1_base,
                                                                    char* src1_offset,
                                                                    short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_add_s16_s8(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(short* dst,
                                                                    short* src1_base,
                                                                    short* src1_offset,
                                                                    short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_add_s16_s16(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(short* dst,
                                                                    short* src1_base,
                                                                    int* src1_offset,
                                                                    short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_add_s16_s32(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(short* dst,
                                                                    short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_add_s16_s64(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(int* dst,
                                                                    int* src1_base,
                                                                    char* src1_offset,
                                                                    int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_add_s32_s8(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(int* dst,
                                                                    int* src1_base,
                                                                    short* src1_offset,
                                                                    int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_add_s32_s16(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(int* dst,
                                                                    int* src1_base,
                                                                    int* src1_offset,
                                                                    int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_add_s32_s32(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(int* dst,
                                                                    int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_add_s32_s64(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(half* dst,
                                                                    half* src1_base,
                                                                    char* src1_offset,
                                                                    half* src2,
                                                                    int size) {
  __mlvm_discrete_atom_add_f16_s8(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(half* dst,
                                                                    half* src1_base,
                                                                    short* src1_offset,
                                                                    half* src2,
                                                                    int size) {
  __mlvm_discrete_atom_add_f16_s16(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(half* dst,
                                                                    half* src1_base,
                                                                    int* src1_offset,
                                                                    half* src2,
                                                                    int size) {
  __mlvm_discrete_atom_add_f16_s32(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(half* dst,
                                                                    half* src1_base,
                                                                    int64_t* src1_offset,
                                                                    half* src2,
                                                                    int size) {
  __mlvm_discrete_atom_add_f16_s64(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(float* dst,
                                                                    float* src1_base,
                                                                    char* src1_offset,
                                                                    float* src2,
                                                                    int size) {
  __mlvm_discrete_atom_add_f32_s8(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(float* dst,
                                                                    float* src1_base,
                                                                    short* src1_offset,
                                                                    float* src2,
                                                                    int size) {
  __mlvm_discrete_atom_add_f32_s16(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(float* dst,
                                                                    float* src1_base,
                                                                    int* src1_offset,
                                                                    float* src2,
                                                                    int size) {
  __mlvm_discrete_atom_add_f32_s32(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(float* dst,
                                                                    float* src1_base,
                                                                    int64_t* src1_offset,
                                                                    float* src2,
                                                                    int size) {
  __mlvm_discrete_atom_add_f32_s64(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    char* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    int size) {
  __mlvm_discrete_atom_add_bf16_s8(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    short* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    int size) {
  __mlvm_discrete_atom_add_bf16_s16(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    int* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    int size) {
  __mlvm_discrete_atom_add_bf16_s32(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    int64_t* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    int size) {
  __mlvm_discrete_atom_add_bf16_s64(dst, src1_base, src1_offset, src2, size);
}
#endif  // __BANG_ARCH__ >= 392

// -----------------------------------------------------------------------------
// Bang C/C++ math function: discrete atomic inc operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 392
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(short* dst,
                                                                    short* src1_base,
                                                                    char* src1_offset,
                                                                    short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_inc_s16_s8(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(short* dst,
                                                                    short* src1_base,
                                                                    short* src1_offset,
                                                                    short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_inc_s16_s16(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(short* dst,
                                                                    short* src1_base,
                                                                    int* src1_offset,
                                                                    short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_inc_s16_s32(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(short* dst,
                                                                    short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_inc_s16_s64(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    char* src1_offset,
                                                                    unsigned short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_inc_u16_s8(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    short* src1_offset,
                                                                    unsigned short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_inc_u16_s16(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    int* src1_offset,
                                                                    unsigned short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_inc_u16_s32(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    unsigned short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_inc_u16_s64(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(int* dst,
                                                                    int* src1_base,
                                                                    char* src1_offset,
                                                                    int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_inc_s32_s8(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(int* dst,
                                                                    int* src1_base,
                                                                    short* src1_offset,
                                                                    int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_inc_s32_s16(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(int* dst,
                                                                    int* src1_base,
                                                                    int* src1_offset,
                                                                    int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_inc_s32_s32(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(int* dst,
                                                                    int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_inc_s32_s64(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    char* src1_offset,
                                                                    unsigned int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_inc_u32_s8(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    short* src1_offset,
                                                                    unsigned int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_inc_u32_s16(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    int* src1_offset,
                                                                    unsigned int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_inc_u32_s32(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    unsigned int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_inc_u32_s64(dst, src1_base, src1_offset, src2, size);
}
#endif  // __BANG_ARCH__ >= 392

// -----------------------------------------------------------------------------
// Bang C/C++ math function: discrete atomic dec operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 392
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(short* dst,
                                                                    short* src1_base,
                                                                    char* src1_offset,
                                                                    short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_dec_s16_s8(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(short* dst,
                                                                    short* src1_base,
                                                                    short* src1_offset,
                                                                    short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_dec_s16_s16(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(short* dst,
                                                                    short* src1_base,
                                                                    int* src1_offset,
                                                                    short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_dec_s16_s32(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(short* dst,
                                                                    short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_dec_s16_s64(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    char* src1_offset,
                                                                    unsigned short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_dec_u16_s8(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    short* src1_offset,
                                                                    unsigned short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_dec_u16_s16(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    int* src1_offset,
                                                                    unsigned short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_dec_u16_s32(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    unsigned short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_dec_u16_s64(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(int* dst,
                                                                    int* src1_base,
                                                                    char* src1_offset,
                                                                    int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_dec_s32_s8(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(int* dst,
                                                                    int* src1_base,
                                                                    short* src1_offset,
                                                                    int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_dec_s32_s16(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(int* dst,
                                                                    int* src1_base,
                                                                    int* src1_offset,
                                                                    int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_dec_s32_s32(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(int* dst,
                                                                    int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_dec_s32_s64(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    char* src1_offset,
                                                                    unsigned int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_dec_u32_s8(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    short* src1_offset,
                                                                    unsigned int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_dec_u32_s16(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    int* src1_offset,
                                                                    unsigned int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_dec_u32_s32(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    unsigned int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_dec_u32_s64(dst, src1_base, src1_offset, src2, size);
}
#endif  // __BANG_ARCH__ >= 392

// -----------------------------------------------------------------------------
// Bang C/C++ math function: discrete atomic max operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 392
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(short* dst,
                                                                    short* src1_base,
                                                                    char* src1_offset,
                                                                    short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_max_s16_s8(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(short* dst,
                                                                    short* src1_base,
                                                                    short* src1_offset,
                                                                    short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_max_s16_s16(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(short* dst,
                                                                    short* src1_base,
                                                                    int* src1_offset,
                                                                    short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_max_s16_s32(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(short* dst,
                                                                    short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_max_s16_s64(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    char* src1_offset,
                                                                    unsigned short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_max_u16_s8(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    short* src1_offset,
                                                                    unsigned short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_max_u16_s16(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    int* src1_offset,
                                                                    unsigned short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_max_u16_s32(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    unsigned short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_max_u16_s64(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(int* dst,
                                                                    int* src1_base,
                                                                    char* src1_offset,
                                                                    int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_max_s32_s8(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(int* dst,
                                                                    int* src1_base,
                                                                    short* src1_offset,
                                                                    int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_max_s32_s16(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(int* dst,
                                                                    int* src1_base,
                                                                    int* src1_offset,
                                                                    int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_max_s32_s32(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(int* dst,
                                                                    int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_max_s32_s64(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    char* src1_offset,
                                                                    unsigned int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_max_u32_s8(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    short* src1_offset,
                                                                    unsigned int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_max_u32_s16(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    int* src1_offset,
                                                                    unsigned int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_max_u32_s32(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    unsigned int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_max_u32_s64(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(half* dst,
                                                                    half* src1_base,
                                                                    char* src1_offset,
                                                                    half* src2,
                                                                    int size) {
  __mlvm_discrete_atom_max_f16_s8(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(half* dst,
                                                                    half* src1_base,
                                                                    short* src1_offset,
                                                                    half* src2,
                                                                    int size) {
  __mlvm_discrete_atom_max_f16_s16(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(half* dst,
                                                                    half* src1_base,
                                                                    int* src1_offset,
                                                                    half* src2,
                                                                    int size) {
  __mlvm_discrete_atom_max_f16_s32(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(half* dst,
                                                                    half* src1_base,
                                                                    int64_t* src1_offset,
                                                                    half* src2,
                                                                    int size) {
  __mlvm_discrete_atom_max_f16_s64(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(float* dst,
                                                                    float* src1_base,
                                                                    char* src1_offset,
                                                                    float* src2,
                                                                    int size) {
  __mlvm_discrete_atom_max_f32_s8(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(float* dst,
                                                                    float* src1_base,
                                                                    short* src1_offset,
                                                                    float* src2,
                                                                    int size) {
  __mlvm_discrete_atom_max_f32_s16(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(float* dst,
                                                                    float* src1_base,
                                                                    int* src1_offset,
                                                                    float* src2,
                                                                    int size) {
  __mlvm_discrete_atom_max_f32_s32(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(float* dst,
                                                                    float* src1_base,
                                                                    int64_t* src1_offset,
                                                                    float* src2,
                                                                    int size) {
  __mlvm_discrete_atom_max_f32_s64(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    char* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    int size) {
  __mlvm_discrete_atom_max_bf16_s8(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    short* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    int size) {
  __mlvm_discrete_atom_max_bf16_s16(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    int* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    int size) {
  __mlvm_discrete_atom_max_bf16_s32(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    int64_t* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    int size) {
  __mlvm_discrete_atom_max_bf16_s64(dst, src1_base, src1_offset, src2, size);
}
#endif  // __BANG_ARCH__ >= 392

// -----------------------------------------------------------------------------
// Bang C/C++ math function: discrete atomic min operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 392
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(short* dst,
                                                                    short* src1_base,
                                                                    char* src1_offset,
                                                                    short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_min_s16_s8(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(short* dst,
                                                                    short* src1_base,
                                                                    short* src1_offset,
                                                                    short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_min_s16_s16(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(short* dst,
                                                                    short* src1_base,
                                                                    int* src1_offset,
                                                                    short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_min_s16_s32(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(short* dst,
                                                                    short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_min_s16_s64(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    char* src1_offset,
                                                                    unsigned short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_min_u16_s8(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    short* src1_offset,
                                                                    unsigned short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_min_u16_s16(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    int* src1_offset,
                                                                    unsigned short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_min_u16_s32(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    unsigned short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_min_u16_s64(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(int* dst,
                                                                    int* src1_base,
                                                                    char* src1_offset,
                                                                    int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_min_s32_s8(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(int* dst,
                                                                    int* src1_base,
                                                                    short* src1_offset,
                                                                    int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_min_s32_s16(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(int* dst,
                                                                    int* src1_base,
                                                                    int* src1_offset,
                                                                    int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_min_s32_s32(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(int* dst,
                                                                    int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_min_s32_s64(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    char* src1_offset,
                                                                    unsigned int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_min_u32_s8(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    short* src1_offset,
                                                                    unsigned int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_min_u32_s16(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    int* src1_offset,
                                                                    unsigned int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_min_u32_s32(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    unsigned int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_min_u32_s64(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(half* dst,
                                                                    half* src1_base,
                                                                    char* src1_offset,
                                                                    half* src2,
                                                                    int size) {
  __mlvm_discrete_atom_min_f16_s8(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(half* dst,
                                                                    half* src1_base,
                                                                    short* src1_offset,
                                                                    half* src2,
                                                                    int size) {
  __mlvm_discrete_atom_min_f16_s16(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(half* dst,
                                                                    half* src1_base,
                                                                    int* src1_offset,
                                                                    half* src2,
                                                                    int size) {
  __mlvm_discrete_atom_min_f16_s32(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(half* dst,
                                                                    half* src1_base,
                                                                    int64_t* src1_offset,
                                                                    half* src2,
                                                                    int size) {
  __mlvm_discrete_atom_min_f16_s64(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(float* dst,
                                                                    float* src1_base,
                                                                    char* src1_offset,
                                                                    float* src2,
                                                                    int size) {
  __mlvm_discrete_atom_min_f32_s8(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(float* dst,
                                                                    float* src1_base,
                                                                    short* src1_offset,
                                                                    float* src2,
                                                                    int size) {
  __mlvm_discrete_atom_min_f32_s16(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(float* dst,
                                                                    float* src1_base,
                                                                    int* src1_offset,
                                                                    float* src2,
                                                                    int size) {
  __mlvm_discrete_atom_min_f32_s32(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(float* dst,
                                                                    float* src1_base,
                                                                    int64_t* src1_offset,
                                                                    float* src2,
                                                                    int size) {
  __mlvm_discrete_atom_min_f32_s64(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    char* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    int size) {
  __mlvm_discrete_atom_min_bf16_s8(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    short* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    int size) {
  __mlvm_discrete_atom_min_bf16_s16(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    int* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    int size) {
  __mlvm_discrete_atom_min_bf16_s32(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    int64_t* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    int size) {
  __mlvm_discrete_atom_min_bf16_s64(dst, src1_base, src1_offset, src2, size);
}
#endif  // __BANG_ARCH__ >= 392

// -----------------------------------------------------------------------------
// Bang C/C++ math function: discrete atomic and operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 392
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_and(short* dst,
                                                                    short* src1_base,
                                                                    char* src1_offset,
                                                                    short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_and_s16_s8(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_and(short* dst,
                                                                    short* src1_base,
                                                                    short* src1_offset,
                                                                    short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_and_s16_s16(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_and(short* dst,
                                                                    short* src1_base,
                                                                    int* src1_offset,
                                                                    short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_and_s16_s32(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_and(short* dst,
                                                                    short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_and_s16_s64(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_and(int* dst,
                                                                    int* src1_base,
                                                                    char* src1_offset,
                                                                    int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_and_s32_s8(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_and(int* dst,
                                                                    int* src1_base,
                                                                    short* src1_offset,
                                                                    int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_and_s32_s16(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_and(int* dst,
                                                                    int* src1_base,
                                                                    int* src1_offset,
                                                                    int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_and_s32_s32(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_and(int* dst,
                                                                    int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_and_s32_s64(dst, src1_base, src1_offset, src2, size);
}
#endif  // __BANG_ARCH__ >= 392

// -----------------------------------------------------------------------------
// Bang C/C++ math function: discrete atomic or operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 392
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_or(short* dst,
                                                                   short* src1_base,
                                                                   char* src1_offset,
                                                                   short* src2,
                                                                   int size) {
  __mlvm_discrete_atom_or_s16_s8(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_or(short* dst,
                                                                   short* src1_base,
                                                                   short* src1_offset,
                                                                   short* src2,
                                                                   int size) {
  __mlvm_discrete_atom_or_s16_s16(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_or(short* dst,
                                                                   short* src1_base,
                                                                   int* src1_offset,
                                                                   short* src2,
                                                                   int size) {
  __mlvm_discrete_atom_or_s16_s32(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_or(short* dst,
                                                                   short* src1_base,
                                                                   int64_t* src1_offset,
                                                                   short* src2,
                                                                   int size) {
  __mlvm_discrete_atom_or_s16_s64(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_or(int* dst,
                                                                   int* src1_base,
                                                                   char* src1_offset,
                                                                   int* src2,
                                                                   int size) {
  __mlvm_discrete_atom_or_s32_s8(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_or(int* dst,
                                                                   int* src1_base,
                                                                   short* src1_offset,
                                                                   int* src2,
                                                                   int size) {
  __mlvm_discrete_atom_or_s32_s16(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_or(int* dst,
                                                                   int* src1_base,
                                                                   int* src1_offset,
                                                                   int* src2,
                                                                   int size) {
  __mlvm_discrete_atom_or_s32_s32(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_or(int* dst,
                                                                   int* src1_base,
                                                                   int64_t* src1_offset,
                                                                   int* src2,
                                                                   int size) {
  __mlvm_discrete_atom_or_s32_s64(dst, src1_base, src1_offset, src2, size);
}
#endif  // __BANG_ARCH__ >= 392

// -----------------------------------------------------------------------------
// Bang C/C++ math function: discrete atomic or operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 392
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_xor(short* dst,
                                                                    short* src1_base,
                                                                    char* src1_offset,
                                                                    short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_xor_s16_s8(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_xor(short* dst,
                                                                    short* src1_base,
                                                                    short* src1_offset,
                                                                    short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_xor_s16_s16(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_xor(short* dst,
                                                                    short* src1_base,
                                                                    int* src1_offset,
                                                                    short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_xor_s16_s32(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_xor(short* dst,
                                                                    short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    short* src2,
                                                                    int size) {
  __mlvm_discrete_atom_xor_s16_s64(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_xor(int* dst,
                                                                    int* src1_base,
                                                                    char* src1_offset,
                                                                    int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_xor_s32_s8(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_xor(int* dst,
                                                                    int* src1_base,
                                                                    short* src1_offset,
                                                                    int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_xor_s32_s16(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_xor(int* dst,
                                                                    int* src1_base,
                                                                    int* src1_offset,
                                                                    int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_xor_s32_s32(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_xor(int* dst,
                                                                    int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    int* src2,
                                                                    int size) {
  __mlvm_discrete_atom_xor_s32_s64(dst, src1_base, src1_offset, src2, size);
}
#endif  // __BANG_ARCH__ >= 392

// -----------------------------------------------------------------------------
// Bang C/C++ math function: discrete atomic exch operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 392
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(short* dst,
                                                                     short* src1_base,
                                                                     char* src1_offset,
                                                                     short* src2,
                                                                     int size) {
  __mlvm_discrete_atom_exch_s16_s8(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(short* dst,
                                                                     short* src1_base,
                                                                     short* src1_offset,
                                                                     short* src2,
                                                                     int size) {
  __mlvm_discrete_atom_exch_s16_s16(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(short* dst,
                                                                     short* src1_base,
                                                                     int* src1_offset,
                                                                     short* src2,
                                                                     int size) {
  __mlvm_discrete_atom_exch_s16_s32(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(short* dst,
                                                                     short* src1_base,
                                                                     int64_t* src1_offset,
                                                                     short* src2,
                                                                     int size) {
  __mlvm_discrete_atom_exch_s16_s64(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(int* dst,
                                                                     int* src1_base,
                                                                     char* src1_offset,
                                                                     int* src2,
                                                                     int size) {
  __mlvm_discrete_atom_exch_s32_s8(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(int* dst,
                                                                     int* src1_base,
                                                                     short* src1_offset,
                                                                     int* src2,
                                                                     int size) {
  __mlvm_discrete_atom_exch_s32_s16(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(int* dst,
                                                                     int* src1_base,
                                                                     int* src1_offset,
                                                                     int* src2,
                                                                     int size) {
  __mlvm_discrete_atom_exch_s32_s32(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(int* dst,
                                                                     int* src1_base,
                                                                     int64_t* src1_offset,
                                                                     int* src2,
                                                                     int size) {
  __mlvm_discrete_atom_exch_s32_s64(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(half* dst,
                                                                     half* src1_base,
                                                                     char* src1_offset,
                                                                     half* src2,
                                                                     int size) {
  __mlvm_discrete_atom_exch_f16_s8(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(half* dst,
                                                                     half* src1_base,
                                                                     short* src1_offset,
                                                                     half* src2,
                                                                     int size) {
  __mlvm_discrete_atom_exch_f16_s16(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(half* dst,
                                                                     half* src1_base,
                                                                     int* src1_offset,
                                                                     half* src2,
                                                                     int size) {
  __mlvm_discrete_atom_exch_f16_s32(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(half* dst,
                                                                     half* src1_base,
                                                                     int64_t* src1_offset,
                                                                     half* src2,
                                                                     int size) {
  __mlvm_discrete_atom_exch_f16_s64(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(float* dst,
                                                                     float* src1_base,
                                                                     char* src1_offset,
                                                                     float* src2,
                                                                     int size) {
  __mlvm_discrete_atom_exch_f32_s8(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(float* dst,
                                                                     float* src1_base,
                                                                     short* src1_offset,
                                                                     float* src2,
                                                                     int size) {
  __mlvm_discrete_atom_exch_f32_s16(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(float* dst,
                                                                     float* src1_base,
                                                                     int* src1_offset,
                                                                     float* src2,
                                                                     int size) {
  __mlvm_discrete_atom_exch_f32_s32(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(float* dst,
                                                                     float* src1_base,
                                                                     int64_t* src1_offset,
                                                                     float* src2,
                                                                     int size) {
  __mlvm_discrete_atom_exch_f32_s64(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(bfloat16_t* dst,
                                                                     bfloat16_t* src1_base,
                                                                     char* src1_offset,
                                                                     bfloat16_t* src2,
                                                                     int size) {
  __mlvm_discrete_atom_exch_bf16_s8(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(bfloat16_t* dst,
                                                                     bfloat16_t* src1_base,
                                                                     short* src1_offset,
                                                                     bfloat16_t* src2,
                                                                     int size) {
  __mlvm_discrete_atom_exch_bf16_s16(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(bfloat16_t* dst,
                                                                     bfloat16_t* src1_base,
                                                                     int* src1_offset,
                                                                     bfloat16_t* src2,
                                                                     int size) {
  __mlvm_discrete_atom_exch_bf16_s32(dst, src1_base, src1_offset, src2, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(bfloat16_t* dst,
                                                                     bfloat16_t* src1_base,
                                                                     int64_t* src1_offset,
                                                                     bfloat16_t* src2,
                                                                     int size) {
  __mlvm_discrete_atom_exch_bf16_s64(dst, src1_base, src1_offset, src2, size);
}
#endif  // __BANG_ARCH__ >= 392

// -----------------------------------------------------------------------------
// Bang C/C++ math function: discrete atomic cas operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 392
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(short* dst,
                                                                    short* src1_base,
                                                                    char* src1_offset,
                                                                    short* src2,
                                                                    short src3,
                                                                    int size) {
  __mlvm_discrete_atom_cas_s16_s8(dst, src1_base, src1_offset, src2, src3, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(short* dst,
                                                                    short* src1_base,
                                                                    short* src1_offset,
                                                                    short* src2,
                                                                    short src3,
                                                                    int size) {
  __mlvm_discrete_atom_cas_s16_s16(dst, src1_base, src1_offset, src2, src3, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(short* dst,
                                                                    short* src1_base,
                                                                    int* src1_offset,
                                                                    short* src2,
                                                                    short src3,
                                                                    int size) {
  __mlvm_discrete_atom_cas_s16_s32(dst, src1_base, src1_offset, src2, src3, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(short* dst,
                                                                    short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    short* src2,
                                                                    short src3,
                                                                    int size) {
  __mlvm_discrete_atom_cas_s16_s64(dst, src1_base, src1_offset, src2, src3, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(int* dst,
                                                                    int* src1_base,
                                                                    char* src1_offset,
                                                                    int* src2,
                                                                    int src3,
                                                                    int size) {
  __mlvm_discrete_atom_cas_s32_s8(dst, src1_base, src1_offset, src2, src3, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(int* dst,
                                                                    int* src1_base,
                                                                    short* src1_offset,
                                                                    int* src2,
                                                                    int src3,
                                                                    int size) {
  __mlvm_discrete_atom_cas_s32_s16(dst, src1_base, src1_offset, src2, src3, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(int* dst,
                                                                    int* src1_base,
                                                                    int* src1_offset,
                                                                    int* src2,
                                                                    int src3,
                                                                    int size) {
  __mlvm_discrete_atom_cas_s32_s32(dst, src1_base, src1_offset, src2, src3, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(int* dst,
                                                                    int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    int* src2,
                                                                    int src3,
                                                                    int size) {
  __mlvm_discrete_atom_cas_s32_s64(dst, src1_base, src1_offset, src2, src3, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(half* dst,
                                                                    half* src1_base,
                                                                    char* src1_offset,
                                                                    half* src2,
                                                                    half src3,
                                                                    int size) {
  __mlvm_discrete_atom_cas_f16_s8(dst, src1_base, src1_offset, src2, src3, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(half* dst,
                                                                    half* src1_base,
                                                                    short* src1_offset,
                                                                    half* src2,
                                                                    half src3,
                                                                    int size) {
  __mlvm_discrete_atom_cas_f16_s16(dst, src1_base, src1_offset, src2, src3, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(half* dst,
                                                                    half* src1_base,
                                                                    int* src1_offset,
                                                                    half* src2,
                                                                    half src3,
                                                                    int size) {
  __mlvm_discrete_atom_cas_f16_s32(dst, src1_base, src1_offset, src2, src3, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(half* dst,
                                                                    half* src1_base,
                                                                    int64_t* src1_offset,
                                                                    half* src2,
                                                                    half src3,
                                                                    int size) {
  __mlvm_discrete_atom_cas_f16_s64(dst, src1_base, src1_offset, src2, src3, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(float* dst,
                                                                    float* src1_base,
                                                                    char* src1_offset,
                                                                    float* src2,
                                                                    float src3,
                                                                    int size) {
  __mlvm_discrete_atom_cas_f32_s8(dst, src1_base, src1_offset, src2, src3, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(float* dst,
                                                                    float* src1_base,
                                                                    short* src1_offset,
                                                                    float* src2,
                                                                    float src3,
                                                                    int size) {
  __mlvm_discrete_atom_cas_f32_s16(dst, src1_base, src1_offset, src2, src3, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(float* dst,
                                                                    float* src1_base,
                                                                    int* src1_offset,
                                                                    float* src2,
                                                                    float src3,
                                                                    int size) {
  __mlvm_discrete_atom_cas_f32_s32(dst, src1_base, src1_offset, src2, src3, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(float* dst,
                                                                    float* src1_base,
                                                                    int64_t* src1_offset,
                                                                    float* src2,
                                                                    float src3,
                                                                    int size) {
  __mlvm_discrete_atom_cas_f32_s64(dst, src1_base, src1_offset, src2, src3, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    char* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    bfloat16_t src3,
                                                                    int size) {
  __asm__ ("atom.cas.discrete.nram.gdram.nram.nram.bf16.s8 \t"
           "[%[dst]], [%[src1_base]], [%[src1_offset]], [%[src2]], %[src3], %[size];\n\t"
           ::[dst] "r"(dst), [src1_base] "r"(src1_base), [src1_offset] "r"(src1_offset),
             [src2] "r"(src2), [src3] "r"(src3), [size] "r"(size));
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    short* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    bfloat16_t src3,
                                                                    int size) {
  __asm__ ("atom.cas.discrete.nram.gdram.nram.nram.bf16.s16 \t"
           "[%[dst]], [%[src1_base]], [%[src1_offset]], [%[src2]], %[src3], %[size];\n\t"
           ::[dst] "r"(dst), [src1_base] "r"(src1_base), [src1_offset] "r"(src1_offset),
             [src2] "r"(src2), [src3] "r"(src3), [size] "r"(size));
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    int* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    bfloat16_t src3,
                                                                    int size) {
  __asm__ ("atom.cas.discrete.nram.gdram.nram.nram.bf16.s32 \t"
           "[%[dst]], [%[src1_base]], [%[src1_offset]], [%[src2]], %[src3], %[size];\n\t"
           ::[dst] "r"(dst), [src1_base] "r"(src1_base), [src1_offset] "r"(src1_offset),
             [src2] "r"(src2), [src3] "r"(src3), [size] "r"(size));
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    int64_t* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    bfloat16_t src3,
                                                                    int size) {
  __asm__ ("atom.cas.discrete.nram.gdram.nram.nram.bf16.s64 \t"
           "[%[dst]], [%[src1_base]], [%[src1_offset]], [%[src2]], %[src3], %[size];\n\t"
           ::[dst] "r"(dst), [src1_base] "r"(src1_base), [src1_offset] "r"(src1_offset),
             [src2] "r"(src2), [src3] "r"(src3), [size] "r"(size));
}
#endif  // __BANG_ARCH__ >= 392

// -----------------------------------------------------------------------------
// Bang C/C++ math function: discrete atomic mask add operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 392
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(short* dst,
                                                                    short* src1_base,
                                                                    char* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_add_s16_s8(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(short* dst,
                                                                    short* src1_base,
                                                                    short* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_add_s16_s16(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(short* dst,
                                                                    short* src1_base,
                                                                    int* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_add_s16_s32(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(short* dst,
                                                                    short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_add_s16_s64(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(int* dst,
                                                                    int* src1_base,
                                                                    char* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_add_s32_s8(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(int* dst,
                                                                    int* src1_base,
                                                                    short* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_add_s32_s16(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(int* dst,
                                                                    int* src1_base,
                                                                    int* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_add_s32_s32(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(int* dst,
                                                                    int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_add_s32_s64(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(half* dst,
                                                                    half* src1_base,
                                                                    char* src1_offset,
                                                                    half* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_add_f16_s8(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(half* dst,
                                                                    half* src1_base,
                                                                    short* src1_offset,
                                                                    half* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_add_f16_s16(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(half* dst,
                                                                    half* src1_base,
                                                                    int* src1_offset,
                                                                    half* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_add_f16_s32(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(half* dst,
                                                                    half* src1_base,
                                                                    int64_t* src1_offset,
                                                                    half* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_add_f16_s64(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(float* dst,
                                                                    float* src1_base,
                                                                    char* src1_offset,
                                                                    float* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_add_f32_s8(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(float* dst,
                                                                    float* src1_base,
                                                                    short* src1_offset,
                                                                    float* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_add_f32_s16(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(float* dst,
                                                                    float* src1_base,
                                                                    int* src1_offset,
                                                                    float* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_add_f32_s32(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(float* dst,
                                                                    float* src1_base,
                                                                    int64_t* src1_offset,
                                                                    float* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_add_f32_s64(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    char* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_add_bf16_s8(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    short* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_add_bf16_s16(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    int* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_add_bf16_s32(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    int64_t* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_add_bf16_s64(dst, src1_base, src1_offset, src2, mask, size);
}
#endif  // __BANG_ARCH__ >= 392

// -----------------------------------------------------------------------------
// Bang C/C++ math function: discrete atomic mask inc operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 392
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(short* dst,
                                                                    short* src1_base,
                                                                    char* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_inc_s16_s8(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(short* dst,
                                                                    short* src1_base,
                                                                    short* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_inc_s16_s16(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(short* dst,
                                                                    short* src1_base,
                                                                    int* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_inc_s16_s32(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(short* dst,
                                                                    short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_inc_s16_s64(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    char* src1_offset,
                                                                    unsigned short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_inc_u16_s8(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    short* src1_offset,
                                                                    unsigned short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_inc_u16_s16(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    int* src1_offset,
                                                                    unsigned short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_inc_u16_s32(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    unsigned short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_inc_u16_s64(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(int* dst,
                                                                    int* src1_base,
                                                                    char* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_inc_s32_s8(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(int* dst,
                                                                    int* src1_base,
                                                                    short* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_inc_s32_s16(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(int* dst,
                                                                    int* src1_base,
                                                                    int* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_inc_s32_s32(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(int* dst,
                                                                    int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_inc_s32_s64(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    char* src1_offset,
                                                                    unsigned int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_inc_u32_s8(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    short* src1_offset,
                                                                    unsigned int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_inc_u32_s16(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    int* src1_offset,
                                                                    unsigned int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_inc_u32_s32(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    unsigned int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_inc_u32_s64(dst, src1_base, src1_offset, src2, mask, size);
}
#endif  // __BANG_ARCH__ >= 392

// -----------------------------------------------------------------------------
// Bang C/C++ math function: discrete atomic mask dec operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 392
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(short* dst,
                                                                    short* src1_base,
                                                                    char* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_dec_s16_s8(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(short* dst,
                                                                    short* src1_base,
                                                                    short* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_dec_s16_s16(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(short* dst,
                                                                    short* src1_base,
                                                                    int* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_dec_s16_s32(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(short* dst,
                                                                    short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_dec_s16_s64(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    char* src1_offset,
                                                                    unsigned short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_dec_u16_s8(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    short* src1_offset,
                                                                    unsigned short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_dec_u16_s16(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    int* src1_offset,
                                                                    unsigned short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_dec_u16_s32(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    unsigned short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_dec_u16_s64(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(int* dst,
                                                                    int* src1_base,
                                                                    char* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_dec_s32_s8(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(int* dst,
                                                                    int* src1_base,
                                                                    short* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_dec_s32_s16(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(int* dst,
                                                                    int* src1_base,
                                                                    int* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_dec_s32_s32(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(int* dst,
                                                                    int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_dec_s32_s64(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    char* src1_offset,
                                                                    unsigned int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_dec_u32_s8(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    short* src1_offset,
                                                                    unsigned int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_dec_u32_s16(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    int* src1_offset,
                                                                    unsigned int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_dec_u32_s32(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    unsigned int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_dec_u32_s64(dst, src1_base, src1_offset, src2, mask, size);
}
#endif  // __BANG_ARCH__ >= 392

// -----------------------------------------------------------------------------
// Bang C/C++ math function: discrete atomic mask max operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 392
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(short* dst,
                                                                    short* src1_base,
                                                                    char* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_max_s16_s8(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(short* dst,
                                                                    short* src1_base,
                                                                    short* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_max_s16_s16(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(short* dst,
                                                                    short* src1_base,
                                                                    int* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_max_s16_s32(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(short* dst,
                                                                    short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_max_s16_s64(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    char* src1_offset,
                                                                    unsigned short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_max_u16_s8(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    short* src1_offset,
                                                                    unsigned short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_max_u16_s16(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    int* src1_offset,
                                                                    unsigned short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_max_u16_s32(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    unsigned short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_max_u16_s64(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(int* dst,
                                                                    int* src1_base,
                                                                    char* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_max_s32_s8(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(int* dst,
                                                                    int* src1_base,
                                                                    short* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_max_s32_s16(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(int* dst,
                                                                    int* src1_base,
                                                                    int* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_max_s32_s32(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(int* dst,
                                                                    int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_max_s32_s64(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    char* src1_offset,
                                                                    unsigned int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_max_u32_s8(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    short* src1_offset,
                                                                    unsigned int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_max_u32_s16(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    int* src1_offset,
                                                                    unsigned int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_max_u32_s32(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    unsigned int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_max_u32_s64(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(half* dst,
                                                                    half* src1_base,
                                                                    char* src1_offset,
                                                                    half* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_max_f16_s8(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(half* dst,
                                                                    half* src1_base,
                                                                    short* src1_offset,
                                                                    half* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_max_f16_s16(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(half* dst,
                                                                    half* src1_base,
                                                                    int* src1_offset,
                                                                    half* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_max_f16_s32(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(half* dst,
                                                                    half* src1_base,
                                                                    int64_t* src1_offset,
                                                                    half* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_max_f16_s64(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(float* dst,
                                                                    float* src1_base,
                                                                    char* src1_offset,
                                                                    float* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_max_f32_s8(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(float* dst,
                                                                    float* src1_base,
                                                                    short* src1_offset,
                                                                    float* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_max_f32_s16(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(float* dst,
                                                                    float* src1_base,
                                                                    int* src1_offset,
                                                                    float* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_max_f32_s32(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(float* dst,
                                                                    float* src1_base,
                                                                    int64_t* src1_offset,
                                                                    float* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_max_f32_s64(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    char* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_max_bf16_s8(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    short* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_max_bf16_s16(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    int* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_max_bf16_s32(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    int64_t* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_max_bf16_s64(dst, src1_base, src1_offset, src2, mask, size);
}
#endif  // __BANG_ARCH__ >= 392

// -----------------------------------------------------------------------------
// Bang C/C++ math function: discrete atomic mask min operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 392
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(short* dst,
                                                                    short* src1_base,
                                                                    char* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_min_s16_s8(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(short* dst,
                                                                    short* src1_base,
                                                                    short* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_min_s16_s16(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(short* dst,
                                                                    short* src1_base,
                                                                    int* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_min_s16_s32(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(short* dst,
                                                                    short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_min_s16_s64(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    char* src1_offset,
                                                                    unsigned short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_min_u16_s8(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    short* src1_offset,
                                                                    unsigned short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_min_u16_s16(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    int* src1_offset,
                                                                    unsigned short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_min_u16_s32(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    unsigned short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_min_u16_s64(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(int* dst,
                                                                    int* src1_base,
                                                                    char* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_min_s32_s8(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(int* dst,
                                                                    int* src1_base,
                                                                    short* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_min_s32_s16(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(int* dst,
                                                                    int* src1_base,
                                                                    int* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_min_s32_s32(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(int* dst,
                                                                    int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_min_s32_s64(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    char* src1_offset,
                                                                    unsigned int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_min_u32_s8(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    short* src1_offset,
                                                                    unsigned int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_min_u32_s16(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    int* src1_offset,
                                                                    unsigned int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_min_u32_s32(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    unsigned int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_min_u32_s64(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(half* dst,
                                                                    half* src1_base,
                                                                    char* src1_offset,
                                                                    half* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_min_f16_s8(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(half* dst,
                                                                    half* src1_base,
                                                                    short* src1_offset,
                                                                    half* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_min_f16_s16(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(half* dst,
                                                                    half* src1_base,
                                                                    int* src1_offset,
                                                                    half* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_min_f16_s32(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(half* dst,
                                                                    half* src1_base,
                                                                    int64_t* src1_offset,
                                                                    half* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_min_f16_s64(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(float* dst,
                                                                    float* src1_base,
                                                                    char* src1_offset,
                                                                    float* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_min_f32_s8(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(float* dst,
                                                                    float* src1_base,
                                                                    short* src1_offset,
                                                                    float* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_min_f32_s16(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(float* dst,
                                                                    float* src1_base,
                                                                    int* src1_offset,
                                                                    float* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_min_f32_s32(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(float* dst,
                                                                    float* src1_base,
                                                                    int64_t* src1_offset,
                                                                    float* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_min_f32_s64(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    char* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_min_bf16_s8(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    short* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_min_bf16_s16(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    int* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_min_bf16_s32(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    int64_t* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_min_bf16_s64(dst, src1_base, src1_offset, src2, mask, size);
}
#endif  // __BANG_ARCH__ >= 392

// -----------------------------------------------------------------------------
// Bang C/C++ math function: discrete atomic mask and operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 392
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_and(short* dst,
                                                                    short* src1_base,
                                                                    char* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_and_s16_s8(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_and(short* dst,
                                                                    short* src1_base,
                                                                    short* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_and_s16_s16(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_and(short* dst,
                                                                    short* src1_base,
                                                                    int* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_and_s16_s32(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_and(short* dst,
                                                                    short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_and_s16_s64(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_and(int* dst,
                                                                    int* src1_base,
                                                                    char* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_and_s32_s8(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_and(int* dst,
                                                                    int* src1_base,
                                                                    short* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_and_s32_s16(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_and(int* dst,
                                                                    int* src1_base,
                                                                    int* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_and_s32_s32(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_and(int* dst,
                                                                    int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_and_s32_s64(dst, src1_base, src1_offset, src2, mask, size);
}
#endif  // __BANG_ARCH__ >= 392

// -----------------------------------------------------------------------------
// Bang C/C++ math function: discrete atomic mask or operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 392
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_or(short* dst,
                                                                   short* src1_base,
                                                                   char* src1_offset,
                                                                   short* src2,
                                                                   void* mask,
                                                                   int size) {
  __mlvm_discrete_atom_mask_or_s16_s8(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_or(short* dst,
                                                                   short* src1_base,
                                                                   short* src1_offset,
                                                                   short* src2,
                                                                   void* mask,
                                                                   int size) {
  __mlvm_discrete_atom_mask_or_s16_s16(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_or(short* dst,
                                                                   short* src1_base,
                                                                   int* src1_offset,
                                                                   short* src2,
                                                                   void* mask,
                                                                   int size) {
  __mlvm_discrete_atom_mask_or_s16_s32(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_or(short* dst,
                                                                   short* src1_base,
                                                                   int64_t* src1_offset,
                                                                   short* src2,
                                                                   void* mask,
                                                                   int size) {
  __mlvm_discrete_atom_mask_or_s16_s64(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_or(int* dst,
                                                                   int* src1_base,
                                                                   char* src1_offset,
                                                                   int* src2,
                                                                   void* mask,
                                                                   int size) {
  __mlvm_discrete_atom_mask_or_s32_s8(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_or(int* dst,
                                                                   int* src1_base,
                                                                   short* src1_offset,
                                                                   int* src2,
                                                                   void* mask,
                                                                   int size) {
  __mlvm_discrete_atom_mask_or_s32_s16(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_or(int* dst,
                                                                   int* src1_base,
                                                                   int* src1_offset,
                                                                   int* src2,
                                                                   void* mask,
                                                                   int size) {
  __mlvm_discrete_atom_mask_or_s32_s32(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_or(int* dst,
                                                                   int* src1_base,
                                                                   int64_t* src1_offset,
                                                                   int* src2,
                                                                   void* mask,
                                                                   int size) {
  __mlvm_discrete_atom_mask_or_s32_s64(dst, src1_base, src1_offset, src2, mask, size);
}
#endif  // __BANG_ARCH__ >= 392

// -----------------------------------------------------------------------------
// Bang C/C++ math function: discrete atomic mask xor operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 392
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_xor(short* dst,
                                                                    short* src1_base,
                                                                    char* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_xor_s16_s8(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_xor(short* dst,
                                                                    short* src1_base,
                                                                    short* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_xor_s16_s16(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_xor(short* dst,
                                                                    short* src1_base,
                                                                    int* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_xor_s16_s32(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_xor(short* dst,
                                                                    short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_xor_s16_s64(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_xor(int* dst,
                                                                    int* src1_base,
                                                                    char* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_xor_s32_s8(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_xor(int* dst,
                                                                    int* src1_base,
                                                                    short* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_xor_s32_s16(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_xor(int* dst,
                                                                    int* src1_base,
                                                                    int* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_xor_s32_s32(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_xor(int* dst,
                                                                    int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size) {
  __mlvm_discrete_atom_mask_xor_s32_s64(dst, src1_base, src1_offset, src2, mask, size);
}
#endif  // __BANG_ARCH__ >= 392

// -----------------------------------------------------------------------------
// Bang C/C++ math function: discrete atomic mask exch operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 392
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(short* dst,
                                                                     short* src1_base,
                                                                     char* src1_offset,
                                                                     short* src2,
                                                                     void* mask,
                                                                     int size) {
  __mlvm_discrete_atom_mask_exch_s16_s8(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(short* dst,
                                                                     short* src1_base,
                                                                     short* src1_offset,
                                                                     short* src2,
                                                                     void* mask,
                                                                     int size) {
  __mlvm_discrete_atom_mask_exch_s16_s16(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(short* dst,
                                                                     short* src1_base,
                                                                     int* src1_offset,
                                                                     short* src2,
                                                                     void* mask,
                                                                     int size) {
  __mlvm_discrete_atom_mask_exch_s16_s32(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(short* dst,
                                                                     short* src1_base,
                                                                     int64_t* src1_offset,
                                                                     short* src2,
                                                                     void* mask,
                                                                     int size) {
  __mlvm_discrete_atom_mask_exch_s16_s64(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(int* dst,
                                                                     int* src1_base,
                                                                     char* src1_offset,
                                                                     int* src2,
                                                                     void* mask,
                                                                     int size) {
  __mlvm_discrete_atom_mask_exch_s32_s8(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(int* dst,
                                                                     int* src1_base,
                                                                     short* src1_offset,
                                                                     int* src2,
                                                                     void* mask,
                                                                     int size) {
  __mlvm_discrete_atom_mask_exch_s32_s16(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(int* dst,
                                                                     int* src1_base,
                                                                     int* src1_offset,
                                                                     int* src2,
                                                                     void* mask,
                                                                     int size) {
  __mlvm_discrete_atom_mask_exch_s32_s32(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(int* dst,
                                                                     int* src1_base,
                                                                     int64_t* src1_offset,
                                                                     int* src2,
                                                                     void* mask,
                                                                     int size) {
  __mlvm_discrete_atom_mask_exch_s32_s64(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(half* dst,
                                                                     half* src1_base,
                                                                     char* src1_offset,
                                                                     half* src2,
                                                                     void* mask,
                                                                     int size) {
  __mlvm_discrete_atom_mask_exch_f16_s8(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(half* dst,
                                                                     half* src1_base,
                                                                     short* src1_offset,
                                                                     half* src2,
                                                                     void* mask,
                                                                     int size) {
  __mlvm_discrete_atom_mask_exch_f16_s16(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(half* dst,
                                                                     half* src1_base,
                                                                     int* src1_offset,
                                                                     half* src2,
                                                                     void* mask,
                                                                     int size) {
  __mlvm_discrete_atom_mask_exch_f16_s32(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(half* dst,
                                                                     half* src1_base,
                                                                     int64_t* src1_offset,
                                                                     half* src2,
                                                                     void* mask,
                                                                     int size) {
  __mlvm_discrete_atom_mask_exch_f16_s64(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(float* dst,
                                                                     float* src1_base,
                                                                     char* src1_offset,
                                                                     float* src2,
                                                                     void* mask,
                                                                     int size) {
  __mlvm_discrete_atom_mask_exch_f32_s8(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(float* dst,
                                                                     float* src1_base,
                                                                     short* src1_offset,
                                                                     float* src2,
                                                                     void* mask,
                                                                     int size) {
  __mlvm_discrete_atom_mask_exch_f32_s16(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(float* dst,
                                                                     float* src1_base,
                                                                     int* src1_offset,
                                                                     float* src2,
                                                                     void* mask,
                                                                     int size) {
  __mlvm_discrete_atom_mask_exch_f32_s32(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(float* dst,
                                                                     float* src1_base,
                                                                     int64_t* src1_offset,
                                                                     float* src2,
                                                                     void* mask,
                                                                     int size) {
  __mlvm_discrete_atom_mask_exch_f32_s64(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(bfloat16_t* dst,
                                                                     bfloat16_t* src1_base,
                                                                     char* src1_offset,
                                                                     bfloat16_t* src2,
                                                                     void* mask,
                                                                     int size) {
  __mlvm_discrete_atom_mask_exch_bf16_s8(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(bfloat16_t* dst,
                                                                     bfloat16_t* src1_base,
                                                                     short* src1_offset,
                                                                     bfloat16_t* src2,
                                                                     void* mask,
                                                                     int size) {
  __mlvm_discrete_atom_mask_exch_bf16_s16(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(bfloat16_t* dst,
                                                                     bfloat16_t* src1_base,
                                                                     int* src1_offset,
                                                                     bfloat16_t* src2,
                                                                     void* mask,
                                                                     int size) {
  __mlvm_discrete_atom_mask_exch_bf16_s32(dst, src1_base, src1_offset, src2, mask, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(bfloat16_t* dst,
                                                                     bfloat16_t* src1_base,
                                                                     int64_t* src1_offset,
                                                                     bfloat16_t* src2,
                                                                     void* mask,
                                                                     int size) {
  __mlvm_discrete_atom_mask_exch_bf16_s64(dst, src1_base, src1_offset, src2, mask, size);
}
#endif  // __BANG_ARCH__ >= 392

// -----------------------------------------------------------------------------
// Bang C/C++ math function: discrete atomic mask cas operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 392
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(short* dst,
                                                                    short* src1_base,
                                                                    char* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    short src3,
                                                                    int size) {
  __mlvm_discrete_atom_mask_cas_s16_s8(dst, src1_base, src1_offset, src2, mask, src3, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(short* dst,
                                                                    short* src1_base,
                                                                    short* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    short src3,
                                                                    int size) {
  __mlvm_discrete_atom_mask_cas_s16_s16(dst, src1_base, src1_offset, src2, mask, src3, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(short* dst,
                                                                    short* src1_base,
                                                                    int* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    short src3,
                                                                    int size) {
  __mlvm_discrete_atom_mask_cas_s16_s32(dst, src1_base, src1_offset, src2, mask, src3, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(short* dst,
                                                                    short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    short src3,
                                                                    int size) {
  __mlvm_discrete_atom_mask_cas_s16_s64(dst, src1_base, src1_offset, src2, mask, src3, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(int* dst,
                                                                    int* src1_base,
                                                                    char* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int src3,
                                                                    int size) {
  __mlvm_discrete_atom_mask_cas_s32_s8(dst, src1_base, src1_offset, src2, mask, src3, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(int* dst,
                                                                    int* src1_base,
                                                                    short* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int src3,
                                                                    int size) {
  __mlvm_discrete_atom_mask_cas_s32_s16(dst, src1_base, src1_offset, src2, mask, src3, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(int* dst,
                                                                    int* src1_base,
                                                                    int* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int src3,
                                                                    int size) {
  __mlvm_discrete_atom_mask_cas_s32_s32(dst, src1_base, src1_offset, src2, mask, src3, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(int* dst,
                                                                    int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int src3,
                                                                    int size) {
  __mlvm_discrete_atom_mask_cas_s32_s64(dst, src1_base, src1_offset, src2, mask, src3, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(half* dst,
                                                                    half* src1_base,
                                                                    char* src1_offset,
                                                                    half* src2,
                                                                    void* mask,
                                                                    half src3,
                                                                    int size) {
  __mlvm_discrete_atom_mask_cas_f16_s8(dst, src1_base, src1_offset, src2, mask, src3, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(half* dst,
                                                                    half* src1_base,
                                                                    short* src1_offset,
                                                                    half* src2,
                                                                    void* mask,
                                                                    half src3,
                                                                    int size) {
  __mlvm_discrete_atom_mask_cas_f16_s16(dst, src1_base, src1_offset, src2, mask, src3, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(half* dst,
                                                                    half* src1_base,
                                                                    int* src1_offset,
                                                                    half* src2,
                                                                    void* mask,
                                                                    half src3,
                                                                    int size) {
  __mlvm_discrete_atom_mask_cas_f16_s32(dst, src1_base, src1_offset, src2, mask, src3, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(half* dst,
                                                                    half* src1_base,
                                                                    int64_t* src1_offset,
                                                                    half* src2,
                                                                    void* mask,
                                                                    half src3,
                                                                    int size) {
  __mlvm_discrete_atom_mask_cas_f16_s64(dst, src1_base, src1_offset, src2, mask, src3, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(float* dst,
                                                                    float* src1_base,
                                                                    char* src1_offset,
                                                                    float* src2,
                                                                    void* mask,
                                                                    float src3,
                                                                    int size) {
  __mlvm_discrete_atom_mask_cas_f32_s8(dst, src1_base, src1_offset, src2, mask, src3, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(float* dst,
                                                                    float* src1_base,
                                                                    short* src1_offset,
                                                                    float* src2,
                                                                    void* mask,
                                                                    float src3,
                                                                    int size) {
  __mlvm_discrete_atom_mask_cas_f32_s16(dst, src1_base, src1_offset, src2, mask, src3, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(float* dst,
                                                                    float* src1_base,
                                                                    int* src1_offset,
                                                                    float* src2,
                                                                    void* mask,
                                                                    float src3,
                                                                    int size) {
  __mlvm_discrete_atom_mask_cas_f32_s32(dst, src1_base, src1_offset, src2, mask, src3, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(float* dst,
                                                                    float* src1_base,
                                                                    int64_t* src1_offset,
                                                                    float* src2,
                                                                    void* mask,
                                                                    float src3,
                                                                    int size) {
  __mlvm_discrete_atom_mask_cas_f32_s64(dst, src1_base, src1_offset, src2, mask, src3, size);
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    char* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    void* mask,
                                                                    bfloat16_t src3,
                                                                    int size) {
  __asm__ ("atom.cas.discrete.mask.nram.gdram.nram.nram.nram.bf16.s8 \t"
           "[%[dst]], [%[src1_base]], [%[src1_offset]], [%[src2]], [%[mask]], %[src3], %[size];\n\t"
           ::[dst] "r"(dst), [src1_base] "r"(src1_base), [src1_offset] "r"(src1_offset),
             [src2] "r"(src2), [mask] "r"(mask), [src3] "r"(src3), [size] "r"(size));
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    short* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    void* mask,
                                                                    bfloat16_t src3,
                                                                    int size) {
  __asm__ ("atom.cas.discrete.mask.nram.gdram.nram.nram.nram.bf16.s16 \t"
           "[%[dst]], [%[src1_base]], [%[src1_offset]], [%[src2]], [%[mask]], %[src3], %[size];\n\t"
           ::[dst] "r"(dst), [src1_base] "r"(src1_base), [src1_offset] "r"(src1_offset),
             [src2] "r"(src2), [mask] "r"(mask), [src3] "r"(src3), [size] "r"(size));
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    int* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    void* mask,
                                                                    bfloat16_t src3,
                                                                    int size) {
  __asm__ ("atom.cas.discrete.mask.nram.gdram.nram.nram.nram.bf16.s32 \t"
           "[%[dst]], [%[src1_base]], [%[src1_offset]], [%[src2]], [%[mask]], %[src3], %[size];\n\t"
           ::[dst] "r"(dst), [src1_base] "r"(src1_base), [src1_offset] "r"(src1_offset),
             [src2] "r"(src2), [mask] "r"(mask), [src3] "r"(src3), [size] "r"(size));
}
static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    int64_t* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    void* mask,
                                                                    bfloat16_t src3,
                                                                    int size) {
  __asm__ ("atom.cas.discrete.mask.nram.gdram.nram.nram.nram.bf16.s64 \t"
           "[%[dst]], [%[src1_base]], [%[src1_offset]], [%[src2]], [%[mask]], %[src3], %[size];\n\t"
           ::[dst] "r"(dst), [src1_base] "r"(src1_base), [src1_offset] "r"(src1_offset),
             [src2] "r"(src2), [mask] "r"(mask), [src3] "r"(src3), [size] "r"(size));
}
#endif  // __BANG_ARCH__ >= 392

// -----------------------------------------------------------------------------
// Bang C/C++ math function: stream binary and fixed-point conversion operation
// -----------------------------------------------------------------------------
#if __BANG_ARCH__ >= 392
static __mlu_func__ __mlu_builtin__ void __bang_breduce(unsigned char* dst,
                                                        char* src,
                                                        int src_dim_n,
                                                        int src_dim_h,
                                                        int src_dim_w,
                                                        int byte_of_src_dim_c) {
  __mlvm_stream_breduce_fix8(dst, src, src_dim_n, src_dim_h, src_dim_w, byte_of_src_dim_c);
}
static __mlu_func__ __mlu_builtin__ void __bang_breduce(unsigned char* dst,
                                                        short* src,
                                                        int src_dim_n,
                                                        int src_dim_h,
                                                        int src_dim_w,
                                                        int byte_of_src_dim_c) {
  __mlvm_stream_breduce_fix16(dst, src, src_dim_n, src_dim_h, src_dim_w, byte_of_src_dim_c);
}
static __mlu_func__ __mlu_builtin__ void __bang_breduce(unsigned char* dst,
                                                        int* src,
                                                        int src_dim_n,
                                                        int src_dim_h,
                                                        int src_dim_w,
                                                        int byte_of_src_dim_c) {
  __mlvm_stream_breduce_fix32(dst, src, src_dim_n, src_dim_h, src_dim_w, byte_of_src_dim_c);
}
static __mlu_func__ __mlu_builtin__ void __bang_bexpand(char* dst,
                                                        unsigned char* src,
                                                        int dst_dim_n,
                                                        int dst_dim_h,
                                                        int dst_dim_w,
                                                        int byte_of_dst_dim_c) {
  __mlvm_stream_bexpand_fix8(dst, src, dst_dim_n, dst_dim_h, dst_dim_w, byte_of_dst_dim_c);
}
static __mlu_func__ __mlu_builtin__ void __bang_bexpand(short* dst,
                                                        unsigned char* src,
                                                        int dst_dim_n,
                                                        int dst_dim_h,
                                                        int dst_dim_w,
                                                        int byte_of_dst_dim_c) {
  __mlvm_stream_bexpand_fix16(dst, src, dst_dim_n, dst_dim_h, dst_dim_w, byte_of_dst_dim_c);
}
static __mlu_func__ __mlu_builtin__ void __bang_bexpand(int* dst,
                                                        unsigned char* src,
                                                        int dst_dim_n,
                                                        int dst_dim_h,
                                                        int dst_dim_w,
                                                        int byte_of_dst_dim_c) {
  __mlvm_stream_bexpand_fix32(dst, src, dst_dim_n, dst_dim_h, dst_dim_w, byte_of_dst_dim_c);
}
#endif  // __BANG_ARCH__ >= 392

// -----------------------------------------------------------------------------
// Bang C/C++ math function: count the number of bits that set to 1
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ unsigned char __popcnt(unsigned char uc) {
  uc = (uc & 0x55) + ((uc >> 1) & 0x55);
  uc = (uc & 0x33) + ((uc >> 2) & 0x33);
  uc = (uc & 0x0f) + ((uc >> 4) & 0x0f);
  return uc;
}
static __mlu_func__ __mlu_builtin__ unsigned short __popcnt(unsigned short us) {
  us = (us & 0x5555) + ((us >> 1) & 0x5555);
  us = (us & 0x3333) + ((us >> 2) & 0x3333);
  us = (us & 0x0f0f) + ((us >> 4) & 0x0f0f);
  us = (us & 0x00ff) + ((us >> 8) & 0x00ff);
  return us;
}
static __mlu_func__ __mlu_builtin__ unsigned int __popcnt(unsigned int ui) {
  ui = (ui & 0x55555555) + ((ui >> 1) & 0x55555555);
  ui = (ui & 0x33333333) + ((ui >> 2) & 0x33333333);
  ui = (ui & 0x0f0f0f0f) + ((ui >> 4) & 0x0f0f0f0f);
  ui = (ui & 0x00ff00ff) + ((ui >> 8) & 0x00ff00ff);
  ui = (ui & 0x0000ffff) + ((ui >> 16) & 0x0000ffff);
  return ui;
}
static __mlu_func__ __mlu_builtin__ int __bang_popcnt(unsigned int *ui, int elem_count) {
  int count = 0;
  for (int i = 0; i < elem_count; ++i) {
    count += __popcnt(ui[i]);
  }
  return count;
}
static __mlu_func__ __mlu_builtin__ int __bang_popcnt(unsigned short *us, int elem_count) {
  int count = 0;
  for (int i = 0; i < elem_count; ++i) {
    count += __popcnt(us[i]);
  }
  return count;
}
static __mlu_func__ __mlu_builtin__ int __bang_popcnt(unsigned char *uc, int elem_count) {
  int count = 0;
  for (int i = 0; i < elem_count; ++i) {
    count += __popcnt(uc[i]);
  }
  return count;
}

#undef __POSITIVE_INF_HALF(a)
#undef __NEGATIVE_INF_HALF(a)
#undef __INF_HALF_TO_FLOAT(a)
#undef __NAN_FLOAT_TO_INT(a)
#undef __NAN_HALF_TO_INT(a)
#endif  // __BANG_DEVICE_FUNCTIONS_MATH_H__
