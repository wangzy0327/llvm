/*===-----------------------------------------------------------------------===
 *
 * Copyright (C) [2022] by Cambricon, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */
#ifndef  __BANG_DEVICE_FUNCTIONS_DECLS_H__
#define  __BANG_DEVICE_FUNCTIONS_DECLS_H__

#ifndef __BANG__
#error "This file is for BANG compilation only."
#endif  // __BANG__

#include <mlu.h>

#ifndef __BANG_ARCH__  // This file only for host-side compilation

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from float to half in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_2xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   __mlu_entry__ void kernel(float a) {
 *     half result;
 *     result = __float2half_tz(a);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ half __float2half_tz(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-off-zero mode.
 *
 * @details The function converts type of ``a`` from float to half in round-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_2xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __float2half_oz(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-up mode.
 *
 * @details The function converts type of ``a`` from float to half in round-up mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_2xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __float2half_up(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-down mode.
 *
 * @details The function converts type of ``a`` from float to half in round-down mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_2xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __float2half_dn(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``a`` from float to half in round-nearest-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_2xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __float2half_rd(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-math mode.
 *
 * @details The function converts type of ``a`` from float to half in round-math mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __float2half_rm(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-even mode.
 *
 * @details The function converts type of ``a`` from float to half in round-nearest-even mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __float2half_rn(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from float to half in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __float2half(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from half to int in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *  #include <bang.h>
 *
 *   __mlu_entry__ void kernel(float a) {
 *     int result;
 *     result = __half2int_tz(a);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ int __half2int_tz(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-off-zero mode.
 *
 * @details The function converts type of ``a`` from half to int in round-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2int_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ int __half2int_oz(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-up mode.
 *
 * @details The function converts type of ``a`` from half to int in round-up mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2int_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ int __half2int_up(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-down mode.
 *
 * @details The function converts type of ``a`` from half to int in round-down mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2int_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ int __half2int_dn(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``a`` from half to int in round-nearest-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2int_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ int __half2int_rd(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-math mode.
 *
 * @details The function converts type of ``a`` from half to int in round-math mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2int_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ int __half2int_rm(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-even mode.
 *
 * @details The function converts type of ``a`` from half to int in round-nearest-even mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2int_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ int __half2int_rn(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from half to int in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2int_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ int __half2int(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from int to half in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *  #include <bang.h>
 *
 *   __mlu_entry__ void kernel(int a) {
 *     half result;
 *     result = __int2half_tz(a);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ half __int2half_tz(int a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-off-zero mode.
 *
 * @details The function converts type of ``a`` from int to half in round-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__int2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __int2half_oz(int a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-up mode.
 *
 * @details The function converts type of ``a`` from int to half in round-up mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__int2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __int2half_up(int a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-down mode.
 *
 * @details The function converts type of ``a`` from int to half in round-down mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__int2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __int2half_dn(int a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``a`` from int to half in round-nearest-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__int2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __int2half_rd(int a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-math mode.
 *
 * @details The function converts type of ``a`` from int to half in round-math mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__int2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __int2half_rm(int a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-even mode.
 *
 * @details The function converts type of ``a`` from int to half in round-nearest-even mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__int2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __int2half_rn(int a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from int to half in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__int2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __int2half(int a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from unsigned int to half in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   __mlu_entry__ void kernel(int a) {
 *     half result;
 *     result = __uint2half_tz(a);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ half __uint2half_tz(unsigned int a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-off-zero mode.
 *
 * @details The function converts type of ``a`` from unsigned int to half in round-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__uint2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __uint2half_oz(unsigned int a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-up mode.
 *
 * @details The function converts type of ``a`` from unsigned int to half in round-up mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__uint2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __uint2half_up(unsigned int a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-off-zero mode.
 *
 * @details The function converts type of ``a`` from unsigned int to half in round-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__uint2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __uint2half_dn(unsigned int a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``a`` from unsigned int to half in round-nearest-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__uint2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __uint2half_rd(unsigned int a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-math mode.
 *
 * @details The function converts type of ``a`` from unsigned int to half in round-math mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__uint2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __uint2half_rm(unsigned int a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-even mode.
 *
 * @details The function converts type of ``a`` from unsigned int to half in round-nearest-even mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__uint2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __uint2half_rn(unsigned int a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from unsigned int to half in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__uint2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __uint2half(unsigned int a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from half to short in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   __mlu_entry__ void kernel(half a) {
 *     short result;
 *     result = __half2short_tz(a);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ short __half2short_tz(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-off-zero mode.
 *
 * @details The function converts type of ``a`` from half to short in round-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2short_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ short __half2short_oz(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-up mode.
 *
 * @details The function converts type of ``a`` from half to short in round-up mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2short_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ short __half2short_up(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-down mode.
 *
 * @details The function converts type of ``a`` from half to short in round-down mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2short_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ short __half2short_dn(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``a`` from half to short in round-nearest-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2short_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ short __half2short_rd(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-math mode.
 *
 * @details The function converts type of ``a`` from half to short in round-math mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2short_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ short __half2short_rm(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-even mode.
 *
 * @details The function converts type of ``a`` from half to short in round-nearest-even mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2short_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ short __half2short_rn(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from half to short in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2short_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ short __half2short(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from short to half in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   __mlu_entry__ void kernel(short a) {
 *     half result;
 *     result = __short2half_tz(a);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ half __short2half_tz(short a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-off-zero mode.
 *
 * @details The function converts type of ``a`` from short to half in round-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__short2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __short2half_oz(short a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-up mode.
 *
 * @details The function converts type of ``a`` from short to half in round-up mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__short2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __short2half_up(short a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-down mode.
 *
 * @details The function converts type of ``a`` from short to half in round-down mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__short2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __short2half_dn(short a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``a`` from short to half in round-nearest-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__short2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __short2half_rd(short a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-math mode.
 *
 * @details The function converts type of ``a`` from short to half in round-math mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__short2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __short2half_rm(short a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-even mode.
 *
 * @details The function converts type of ``a`` from short to half in round-nearest-even mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__short2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __short2half_rn(short a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from short to half in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__short2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __short2half(short a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from char to half in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @code
 *
 *   #include <bang.h>
 *
 *   __mlu_entry__ void kernel(char a) {
 *     half result;
 *     result = __char2half_tz(a);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ half __char2half_tz(char a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from char to half in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__char2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __char2half(char a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-off-zero mode.
 *
 * @details The function converts type of ``a`` from char to half in round-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__char2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __char2half_oz(char a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-up mode.
 *
 * @details The function converts type of ``a`` from char to half in round-up mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__char2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __char2half_up(char a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-down mode.
 *
 * @details The function converts type of ``a`` from char to half in round-down mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__char2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __char2half_dn(char a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``a`` from char to half in round-nearest-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__char2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __char2half_rd(char a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-math mode.
 *
 * @details The function converts type of ``a`` from char to half in round-math mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__char2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __char2half_rm(char a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-even mode.
 *
 * @details The function converts type of ``a`` from char to half in round-nearest-even mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__char2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __char2half_rn(char a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from unsigned char to half in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @code
 *
 *   #include <bang.h>
 *
 *   __mlu_entry__ void kernel(unsigned char a) {
 *     half result;
 *     result = __uchar2half_tz(a);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ half __uchar2half_tz(unsigned char a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from unsigned char to half in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__uchar2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __uchar2half(unsigned char a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-off-zero mode.
 *
 * @details The function converts type of ``a`` from unsigned char to half in round-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__uchar2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __uchar2half_oz(unsigned char a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-up mode.
 *
 * @details The function converts type of ``a`` from unsigned char to half in round-up mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__uchar2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __uchar2half_up(unsigned char a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-down mode.
 *
 * @details The function converts type of ``a`` from unsigned char to half in round-down mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__uchar2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __uchar2half_dn(unsigned char a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``a`` from unsigned char to half in round-nearest-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__uchar2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __uchar2half_rd(unsigned char a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-math mode.
 *
 * @details The function converts type of ``a`` from unsigned char to half in round-math mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__uchar2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __uchar2half_rm(unsigned char a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-even mode.
 *
 * @details The function converts type of ``a`` from unsigned char to half in round-nearest-even mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__uchar2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __uchar2half_rn(unsigned char a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from char to float in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @code
 *
 *   #include <bang.h>
 *
 *   __mlu_entry__ void kernel(char a) {
 *     float result;
 *     result = __char2float_tz(a);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ float __char2float_tz(char a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from char to float in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__char2float_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ float __char2float(char a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-off-zero mode.
 *
 * @details The function converts type of ``a`` from char to float in round-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__char2float_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ float __char2float_oz(char a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-up mode.
 *
 * @details The function converts type of ``a`` from char to float in round-up mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__char2float_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ float __char2float_up(char a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-down mode.
 *
 * @details The function converts type of ``a`` from char to float in round-down mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__char2float_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ float __char2float_dn(char a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``a`` from char to float in round-nearest-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__char2float_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ float __char2float_rd(char a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-math mode.
 *
 * @details The function converts type of ``a`` from char to float in round-math mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__char2float_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ float __char2float_rm(char a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-even mode.
 *
 * @details The function converts type of ``a`` from char to float in round-nearest-even mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__char2float_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ float __char2float_rn(char a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from unsigned char to float in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @code
 *
 *   #include <bang.h>
 *
 *   __mlu_entry__ void kernel(unsigned char a) {
 *     float result;
 *     result = __uchar2float_tz(a);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ float __uchar2float_tz(unsigned char a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from unsigned char to float in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__uchar2float_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ float __uchar2float(unsigned char a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-off-zero mode.
 *
 * @details The function converts type of ``a`` from unsigned char to float in round-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__uchar2float_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ float __uchar2float_oz(unsigned char a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-up mode.
 *
 * @details The function converts type of ``a`` from unsigned char to float in round-up mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__uchar2float_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ float __uchar2float_up(unsigned char a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-down mode.
 *
 * @details The function converts type of ``a`` from unsigned char to float in round-down mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__uchar2float_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ float __uchar2float_dn(unsigned char a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``a`` from unsigned char to float in round-nearest-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__uchar2float_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ float __uchar2float_rd(unsigned char a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-math mode.
 *
 * @details The function converts type of ``a`` from unsigned char to float in round-math mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__uchar2float_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ float __uchar2float_rm(unsigned char a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-even mode.
 *
 * @details The function converts type of ``a`` from unsigned char to float in round-nearest-even mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__uchar2float_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ float __uchar2float_rn(unsigned char a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from unsigned short to half in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   __mlu_entry__ void kernel(unsigned short a) {
 *     half result;
 *     result = __ushort2half_tz(a);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ half __ushort2half_tz(unsigned short a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-off-zero mode.
 *
 * @details The function converts type of ``a`` from unsigned short to half in round-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__ushort2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __ushort2half_oz(unsigned short a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-up mode.
 *
 * @details The function converts type of ``a`` from unsigned short to half in round-up mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__ushort2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __ushort2half_up(unsigned short a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-down mode.
 *
 * @details The function converts type of ``a`` from unsigned short to half in round-down mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__ushort2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __ushort2half_dn(unsigned short a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``a`` from unsigned short to half in round-nearest-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__ushort2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __ushort2half_rd(unsigned short a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-math mode.
 *
 * @details The function converts type of ``a`` from unsigned short to half in round-math mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__ushort2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __ushort2half_rm(unsigned short a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-even mode.
 *
 * @details The function converts type of ``a`` from unsigned short to half in round-nearest-even mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__ushort2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ half __ushort2half_rn(unsigned short a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from float to int in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   __mlu_entry__ void kernel(float a) {
 *     int result;
 *     result = __float2int_tz(a);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ int __float2int_tz(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-off-zero mode.
 *
 * @details The function converts type of ``a`` from float to int in round-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2int_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ int __float2int_oz(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-up mode.
 *
 * @details The function converts type of ``a`` from float to int in round-up mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2int_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ int __float2int_up(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-down mode.
 *
 * @details The function converts type of ``a`` from float to int in round-down mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2int_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ int __float2int_dn(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``a`` from float to int in round-nearest-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2int_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ int __float2int_rd(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-math mode.
 *
 * @details The function converts type of ``a`` from float to int in round-math mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2int_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ int __float2int_rm(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-even mode.
 *
 * @details The function converts type of ``a`` from float to int in round-nearest-even mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2int_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ int __float2int_rn(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from float to int in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2int_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ int __float2int(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from float to short in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   __mlu_entry__ void kernel(float a) {
 *     short result;
 *     result = __float2short_tz(a);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ short __float2short_tz(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-off-zero mode.
 *
 * @details The function converts type of ``a`` from float to short in round-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2short_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ short __float2short_oz(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-up mode.
 *
 * @details The function converts type of ``a`` from float to short in round-up mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2short_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ short __float2short_up(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-down mode.
 *
 * @details The function converts type of ``a`` from float to short in round-down mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2short_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ short __float2short_dn(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``a`` from float to short in round-nearest-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2short_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ short __float2short_rd(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-math mode.
 *
 * @details The function converts type of ``a`` from float to short in round-math mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2short_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ short __float2short_rm(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-even mode.
 *
 * @details The function converts type of ``a`` from float to short in round-nearest-even mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2short_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ short __float2short_rn(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from float to short in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2short_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ short __float2short(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from int to float in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   __mlu_entry__ void kernel(int a) {
 *     float result;
 *     result = __int2float(a);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ float __int2float(int a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from int to float in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__int2float for more details.
*/
static __mlu_func__ __mlu_builtin__ float __int2float_tz(int a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-off-zero mode.
 *
 * @details The function converts type of ``a`` from int to float in round-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__int2float for more details.
*/
static __mlu_func__ __mlu_builtin__ float __int2float_oz(int a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-up mode.
 *
 * @details The function converts type of ``a`` from int to float in round-up mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__int2float for more details.
*/
static __mlu_func__ __mlu_builtin__ float __int2float_up(int a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-down mode.
 *
 * @details The function converts type of ``a`` from int to float in round-down mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__int2float for more details.
*/
static __mlu_func__ __mlu_builtin__ float __int2float_dn(int a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``a`` from int to float in round-nearest-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__int2float for more details.
*/
static __mlu_func__ __mlu_builtin__ float __int2float_rd(int a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-math mode.
 *
 * @details The function converts type of ``a`` from int to float in round-math mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__int2float for more details.
*/
static __mlu_func__ __mlu_builtin__ float __int2float_rm(int a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-even mode.
 *
 * @details The function converts type of ``a`` from int to float in round-nearest-even mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__int2float for more details.
*/
static __mlu_func__ __mlu_builtin__ float __int2float_rn(int a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from unsigned int to float in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   __mlu_entry__ void kernel(unsigned int a) {
 *     float result;
 *     result = __uint2float_tz(a);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ float __uint2float_tz(unsigned int a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-off-zero mode.
 *
 * @details The function converts type of ``a`` from unsigned int to float in round-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__uint2float_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ float __uint2float_oz(unsigned int a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-up mode.
 *
 * @details The function converts type of ``a`` from unsigned int to float in round-up mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__uint2float_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ float __uint2float_up(unsigned int a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-down mode.
 *
 * @details The function converts type of ``a`` from unsigned int to float in round-down mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__uint2float_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ float __uint2float_dn(unsigned int a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``a`` from unsigned int to float in round-nearest-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__uint2float_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ float __uint2float_rd(unsigned int a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-math mode.
 *
 * @details The function converts type of ``a`` from unsigned int to float in round-math mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__uint2float_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ float __uint2float_rm(unsigned int a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-even mode.
 *
 * @details The function converts type of ``a`` from unsigned int to float in round-nearest-even mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__uint2float_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ float __uint2float_rn(unsigned int a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from unsigned int to float in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__uint2float_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ float __uint2float(unsigned int a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from short to float in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   __mlu_entry__ void kernel(short a) {
 *     float result;
 *     result = __short2float_tz(a);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ float __short2float_tz(short a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-off-zero mode.
 *
 * @details The function converts type of ``a`` from short to float in round-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__short2float_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ float __short2float_oz(short a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-up mode.
 *
 * @details The function converts type of ``a`` from short to float in round-up mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__short2float_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ float __short2float_up(short a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-down mode.
 *
 * @details The function converts type of ``a`` from short to float in round-down mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__short2float_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ float __short2float_dn(short a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``a`` from short to float in round-nearest-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__short2float_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ float __short2float_rd(short a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-math mode.
 *
 * @details The function converts type of ``a`` from short to float in round-math mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__short2float_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ float __short2float_rm(short a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-even mode.
 *
 * @details The function converts type of ``a`` from short to float in round-nearest-even mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__short2float_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ float __short2float_rn(short a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from short to float in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__short2float_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ float __short2float(short a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from unsigned short to float in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   __mlu_entry__ void kernel(unsigned short a) {
 *     float result;
 *     result = __ushort2float_tz(a);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ float __ushort2float_tz(unsigned short a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-off-zero mode.
 *
 * @details The function converts type of ``a`` from unsigned short to float in round-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__ushort2float_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ float __ushort2float_oz(unsigned short a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-up mode.
 *
 * @details The function converts type of ``a`` from unsigned short to float in round-up mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__ushort2float_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ float __ushort2float_up(unsigned short a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-down mode.
 *
 * @details The function converts type of ``a`` from unsigned short to float in round-down mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__ushort2float_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ float __ushort2float_dn(unsigned short a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``a`` from unsigned short to float in round-nearest-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__ushort2float_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ float __ushort2float_rd(unsigned short a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-math mode.
 *
 * @details The function converts type of ``a`` from unsigned short to float in round-math mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__ushort2float_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ float __ushort2float_rm(unsigned short a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-even mode.
 *
 * @details The function converts type of ``a`` from unsigned short to float in round-nearest-even mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__ushort2float_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ float __ushort2float_rn(unsigned short a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from unsigned short to float in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__ushort2float_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ float __ushort2float(unsigned short a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from half to float in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_2xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   __mlu_entry__ void kernel(half a) {
 *     float result;
 *     result = __half2float(a);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ float __half2float(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from half to float in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_2xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2float for more details.
*/
static __mlu_func__ __mlu_builtin__ float __half2float_tz(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-off-zero mode.
 *
 * @details The function converts type of ``a`` from half to float in round-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_2xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2float for more details.
*/
static __mlu_func__ __mlu_builtin__ float __half2float_oz(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-up mode.
 *
 * @details The function converts type of ``a`` from half to float in round-up mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_2xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2float for more details.
*/
static __mlu_func__ __mlu_builtin__ float __half2float_up(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-down mode.
 *
 * @details The function converts type of ``a`` from half to float in round-down mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_2xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2float for more details.
*/
static __mlu_func__ __mlu_builtin__ float __half2float_dn(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``a`` from half to float in round-nearest-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_2xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2float for more details.
*/
static __mlu_func__ __mlu_builtin__ float __half2float_rd(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-math mode.
 *
 * @details The function converts type of ``a`` from half to float in round-math mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2float for more details.
*/
static __mlu_func__ __mlu_builtin__ float __half2float_rm(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-even mode.
 *
 * @details The function converts type of ``a`` from half to float in round-nearest-even mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2float for more details.
*/
static __mlu_func__ __mlu_builtin__ float __half2float_rn(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from half to char in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   __mlu_entry__ void kernel(half a) {
 *     char result;
 *     result = __half2char(a);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ char __half2char(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from half to char in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2char for more details.
*/
static __mlu_func__ __mlu_builtin__ char __half2char_tz(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-off-zero mode.
 *
 * @details The function converts type of ``a`` from half to char in round-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2char for more details.
*/
static __mlu_func__ __mlu_builtin__ char __half2char_oz(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-up mode.
 *
 * @details The function converts type of ``a`` from half to char in round-up mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2char for more details.
*/
static __mlu_func__ __mlu_builtin__ char __half2char_up(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-down mode.
 *
 * @details The function converts type of ``a`` from half to char in round-down mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2char for more details.
*/
static __mlu_func__ __mlu_builtin__ char __half2char_dn(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``a`` from half to char in round-nearest-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2char for more details.
*/
static __mlu_func__ __mlu_builtin__ char __half2char_rd(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-math mode.
 *
 * @details The function converts type of ``a`` from half to char in round-math mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2char for more details.
*/
static __mlu_func__ __mlu_builtin__ char __half2char_rm(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-even mode.
 *
 * @details The function converts type of ``a`` from half to char in round-nearest-even mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2char for more details.
*/
static __mlu_func__ __mlu_builtin__ char __half2char_rn(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from half to unsigned char in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   __mlu_entry__ void kernel(half a) {
 *     unsigned char result;
 *     result = __half2uchar(a);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ unsigned char __half2uchar(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from half to unsigned char in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2uchar for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned char __half2uchar_tz(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-off-zero mode.
 *
 * @details The function converts type of ``a`` from half to unsigned char in round-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2uchar for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned char __half2uchar_oz(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-up mode.
 *
 * @details The function converts type of ``a`` from half to unsigned char in round-up mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2uchar for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned char __half2uchar_up(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-down mode.
 *
 * @details The function converts type of ``a`` from half to unsigned char in round-down mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2uchar for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned char __half2uchar_dn(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``a`` from half to unsigned char in round-nearest-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2uchar for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned char __half2uchar_rd(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-math mode.
 *
 * @details The function converts type of ``a`` from half to unsigned char in round-math mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2uchar for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned char __half2uchar_rm(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-even mode.
 *
 * @details The function converts type of ``a`` from half to unsigned char in round-nearest-even mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2uchar for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned char __half2uchar_rn(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from half to unsigned int in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   __mlu_entry__ void kernel(half a) {
 *     unsigned int result;
 *     result = __half2uint(a);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ unsigned int __half2uint(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from half to unsigned int in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2uint for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned int __half2uint_tz(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-off-zero mode.
 *
 * @details The function converts type of ``a`` from half to unsigned int in round-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2uint for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned int __half2uint_oz(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-up mode.
 *
 * @details The function converts type of ``a`` from half to unsigned int in round-up mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2uint for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned int __half2uint_up(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-down mode.
 *
 * @details The function converts type of ``a`` from half to unsigned int in round-down mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2uint for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned int __half2uint_dn(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``a`` from half to unsigned int in round-nearest-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2uint for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned int __half2uint_rd(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-math mode.
 *
 * @details The function converts type of ``a`` from half to unsigned int in round-math mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2uint for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned int __half2uint_rm(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-even mode.
 *
 * @details The function converts type of ``a`` from half to unsigned int in round-nearest-even mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2uint for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned int __half2uint_rn(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from half to unsigned short in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   __mlu_entry__ void kernel(half a) {
 *     unsigned short result;
 *     result = __half2ushort(a);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ unsigned short __half2ushort(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from half to unsigned short in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2ushort for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned short __half2ushort_tz(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-off-zero mode.
 *
 * @details The function converts type of ``a`` from half to unsigned short in round-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2ushort for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned short __half2ushort_oz(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-up mode.
 *
 * @details The function converts type of ``a`` from half to unsigned short in round-up mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2ushort for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned short __half2ushort_up(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-down mode.
 *
 * @details The function converts type of ``a`` from half to unsigned short in round-down mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2ushort for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned short __half2ushort_dn(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``a`` from half to unsigned short in round-nearest-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2ushort for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned short __half2ushort_rd(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-math mode.
 *
 * @details The function converts type of ``a`` from half to unsigned short in round-math mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2ushort for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned short __half2ushort_rm(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-even mode.
 *
 * @details The function converts type of ``a`` from half to unsigned short in round-nearest-even mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__half2ushort for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned short __half2ushort_rn(half a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from float to char in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   __mlu_entry__ void kernel(float a) {
 *     char result;
 *     result = __float2char(a);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ char __float2char(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from float to char in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2char for more details.
*/
static __mlu_func__ __mlu_builtin__ char __float2char_tz(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-off-zero mode.
 *
 * @details The function converts type of ``a`` from float to char in round-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2char for more details.
*/
static __mlu_func__ __mlu_builtin__ char __float2char_oz(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-up mode.
 *
 * @details The function converts type of ``a`` from float to char in round-up mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2char for more details.
*/
static __mlu_func__ __mlu_builtin__ char __float2char_up(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-down mode.
 *
 * @details The function converts type of ``a`` from float to char in round-down mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2char for more details.
*/
static __mlu_func__ __mlu_builtin__ char __float2char_dn(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``a`` from float to char in round-nearest-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2char for more details.
*/
static __mlu_func__ __mlu_builtin__ char __float2char_rd(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-math mode.
 *
 * @details The function converts type of ``a`` from float to char in round-math mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2char for more details.
*/
static __mlu_func__ __mlu_builtin__ char __float2char_rm(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-even mode.
 *
 * @details The function converts type of ``a`` from float to char in round-nearest-even mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2char for more details.
*/
static __mlu_func__ __mlu_builtin__ char __float2char_rn(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from float to unsigned char in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   __mlu_entry__ void kernel(float a) {
 *     unsigned char result;
 *     result = __float2uchar(a);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ unsigned char __float2uchar(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from float to unsigned char in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2uchar for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned char __float2uchar_tz(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-off-zero mode.
 *
 * @details The function converts type of ``a`` from float to unsigned char in round-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2uchar for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned char __float2uchar_oz(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-up mode.
 *
 * @details The function converts type of ``a`` from float to unsigned char in round-up mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2uchar for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned char __float2uchar_up(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-down mode.
 *
 * @details The function converts type of ``a`` from float to unsigned char in round-down mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2uchar for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned char __float2uchar_dn(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``a`` from float to unsigned char in round-nearest-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2uchar for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned char __float2uchar_rd(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-math mode.
 *
 * @details The function converts type of ``a`` from float to unsigned char in round-math mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2uchar for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned char __float2uchar_rm(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-even mode.
 *
 * @details The function converts type of ``a`` from float to unsigned char in round-nearest-even mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2uchar for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned char __float2uchar_rn(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from float to unsigned int in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   __mlu_entry__ void kernel(float a) {
 *     unsigned int result;
 *     result = __float2uint(a);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ unsigned int __float2uint(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from float to unsigned int in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2uint for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned int __float2uint_tz(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-off-zero mode.
 *
 * @details The function converts type of ``a`` from float to unsigned int in round-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2uint for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned int __float2uint_oz(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-up mode.
 *
 * @details The function converts type of ``a`` from float to unsigned int in round-up mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2uint for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned int __float2uint_up(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-down mode.
 *
 * @details The function converts type of ``a`` from float to unsigned int in round-down mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2uint for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned int __float2uint_dn(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``a`` from float to unsigned int in round-nearest-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2uint for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned int __float2uint_rd(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-math mode.
 *
 * @details The function converts type of ``a`` from float to unsigned int in round-math mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2uint for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned int __float2uint_rm(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-even mode.
 *
 * @details The function converts type of ``a`` from float to unsigned int in round-nearest-even mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2uint for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned int __float2uint_rn(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from float to unsigned short in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   __mlu_entry__ void kernel(float a) {
 *     unsigned short result;
 *     result = __float2ushort(a);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ unsigned short __float2ushort(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-to-zero mode.
 *
 * @details The function converts type of ``a`` from float to unsigned short in round-to-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2ushort for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned short __float2ushort_tz(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-off-zero mode.
 *
 * @details The function converts type of ``a`` from float to unsigned short in round-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2ushort for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned short __float2ushort_oz(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-up mode.
 *
 * @details The function converts type of ``a`` from float to unsigned short in round-up mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2ushort for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned short __float2ushort_up(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-down mode.
 *
 * @details The function converts type of ``a`` from float to unsigned short in round-down mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2ushort for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned short __float2ushort_dn(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``a`` from float to unsigned short in round-nearest-off-zero mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2ushort for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned short __float2ushort_rd(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-math mode.
 *
 * @details The function converts type of ``a`` from float to unsigned short in round-math mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2ushort for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned short __float2ushort_rm(float a);

//Group:Scalar Type Conversion Functions
/**
 * @brief Converts data type in round-nearest-even mode.
 *
 * @details The function converts type of ``a`` from float to unsigned short in round-nearest-even mode.
 *
 * @param[in] a The source data.
 *
 * @return The result of conversion.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * See the example of ::__float2ushort for more details.
*/
static __mlu_func__ __mlu_builtin__ unsigned short __float2ushort_rn(float a);

//Group:Stream Type Conversion Functions
/**
 * @brief Return the round of the input element-wisely.
 *
 * @details The function performs round operation element-wisely on ``<src>`` and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src0 The address of the source vector.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<dst>`` and ``<src>`` can not be homologous operands;
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - ``<elem_count>`` must be greater than zero;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_binary_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
*/
static __mlu_func__ __mlu_builtin__ void __bang_round(float* dst,
                                                      float* src,
                                                      int elem_count);

//Group:Stream Type Conversion Functions
/**
 * @brief Return the floor of the input element-wisely.
 *
 * @details The function performs floor operation element-wisely on ``<src>`` and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src0 The address of the source vector.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<dst>`` and ``<src>`` can not be homologous operands;
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - ``<elem_count>`` must be greater than zero;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_binary_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
*/
static __mlu_func__ __mlu_builtin__ void __bang_floor(float* dst,
                                                      float* src,
                                                      int elem_count);

static __mlu_func__ __mlu_builtin__ void __bang_maximum(float* dst,
                                                        float* src0,
                                                        float* src1,
                                                        int elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_maximum(half* dst,
                                                        half* src0,
                                                        half* src1,
                                                        int elem_count);

static __mlu_func__ __mlu_builtin__ void __bang_minimum(float* dst,
                                                        float* src0,
                                                        float* src1,
                                                        int elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_minimum(half* dst,
                                                        half* src0,
                                                        half* src1,
                                                        int elem_count);

static __mlu_func__ __mlu_builtin__ void __bang_cycle_maximum(float* dst,
                                                              float* src,
                                                              float* seg,
                                                              int src_elem_count,
                                                              int seg_elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_cycle_maximum(half* dst,
                                                              half* src,
                                                              half* seg,
                                                              int src_elem_count,
                                                              int seg_elem_count);

static __mlu_func__ __mlu_builtin__ void __bang_cycle_minimum(float* dst,
                                                              float* src,
                                                              float* seg,
                                                              int src_elem_count,
                                                              int seg_elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_cycle_minimum(half* dst,
                                                              half* src,
                                                              half* seg,
                                                              int src_elem_count,
                                                              int seg_elem_count);
//Group:Stream Comparison Functions
static __mlu_func__ __mlu_builtin__ void __bang_nan_maximum(half* dst,
                                                            half* src0,
                                                            half* src1,
                                                            int elem_count);
//Group:Stream Comparison Functions
/**
 * @brief Finds maximum value of each two corresponding elements in the two vectors.
 *
 * @details Compares two vectors and returns a new vector containing the element-wise maxima. If one of the elements being compared is a NaN, then that element is returned.
 *
 * @param[out] dst The address of destination vector
 * @param[in] src0 The address of first source vector
 * @param[in] src1 The address of second source vector
 * @param[in] elem_count The elements number of source vector
 * @return ``void``.
 * @remark
 * \rst
 * - ``<elem_count>`` must be greater than zero;
 * - ``<src0>``, ``<src1>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<dst>`` and ``<src0>`` or ``<src1>`` can be homologous operands;
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_operation_functions_with_elementwise` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= (m)tp_3xx``.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_nan_maximum(float* dst,
                                                            float* src0,
                                                            float* src1,
                                                            int elem_count);
//Group:Stream Comparison Functions
static __mlu_func__ __mlu_builtin__ void __bang_nan_minimum(half* dst,
                                                            half* src0,
                                                            half* src1,
                                                            int elem_count);
//Group:Stream Comparison Functions
/**
 * @brief Finds minimum value of each two corresponding elements in the two vectors.
 *
 * @details Compares two vectors and returns a new vector containing the element-wise minima. If one of the elements being compared is a NaN, then that element is returned.
 *
 * @param[out] dst The address of destination vector
 * @param[in] src0 The address of first source vector
 * @param[in] src1 The address of second source vector
 * @param[in] elem_count The elements number of source vector
 * @return ``void``.
 * @remark
 * \rst
 * - ``<elem_count>`` must be greater than zero;
 * - ``<src0>``, ``<src1>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<dst>`` and ``<src0>`` or ``<src1>`` can be homologous operands;
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_operation_functions_with_elementwise` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= (m)tp_3xx``.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_nan_minimum(float* dst,
                                                            float* src0,
                                                            float* src1,
                                                            int elem_count);
//Group:Stream Comparison Functions
static __mlu_func__ __mlu_builtin__ void __bang_cycle_nan_maximum(float* dst,
                                                                  float* src,
                                                                  float* seg,
                                                                  int src_elem_count,
                                                                  int seg_elem_count);
//Group:Stream Comparison Functions
/**
 * @brief Divides ``<src>`` into ``<src_elem_count>`` / ``<seg_elem_count>`` parts. Each element in each part applies max operation (select the maximum value) with the corresponding element in ``<seg>``. The result is assigned to ``<dst>``. If one of the elements being compared is a NaN, then that element is returned.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of first source vector.
 * @param[in] seg The address of second source vector.
 * @param[in] src_elem_count The elements number of ``<src>`` vector.
 * @param[in] seg_elem_count The elements number of ``<seg>`` vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<src_elem_count>`` and ``<seg_elem_count>`` must be greater than zero;
 * - ``<src_elem_count>`` must be divisible by ``<seg_elem_count>``;
 * - ``<src>``, ``<seg>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_operation_functions_with_elementwise` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= (m)tp_3xx``.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_cycle_nan_maximum(half* dst,
                                                                  half* src,
                                                                  half* seg,
                                                                  int src_elem_count,
                                                                  int seg_elem_count);
//Group:Stream Comparison Functions
static __mlu_func__ __mlu_builtin__ void __bang_cycle_nan_minimum(float* dst,
                                                                  float* src,
                                                                  float* seg,
                                                                  int src_elem_count,
                                                                  int seg_elem_count);
//Group:Stream Comparison Functions
/**
 * @brief Divides ``<src>`` into ``<src_elem_count>`` / ``<seg_elem_count>`` parts. Each element in each part applies min operation (select the minimum value) with the corresponding element in ``<seg>``. The result is assigned to ``<dst>``. If one of the elements being compared is a NaN, then that element is returned.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of first source vector.
 * @param[in] seg The address of second source vector.
 * @param[in] src_elem_count The elements number of ``<src>`` vector.
 * @param[in] seg_elem_count The elements number of ``<seg>`` vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<src_elem_count>`` and ``<seg_elem_count>`` must be greater than zero;
 * - ``<src_elem_count>`` must be divisible by ``<seg_elem_count>``;
 * - ``<src>``, ``<seg>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_operation_functions_with_elementwise` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= (m)tp_3xx``.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_cycle_nan_minimum(half* dst,
                                                                  half* src,
                                                                  half* seg,
                                                                  int src_elem_count,
                                                                  int seg_elem_count);
//Group:Stream Type Conversion Functions
static __mlu_func__ __mlu_builtin__ void __bang_fix82half(half* dst,
                                                          fix8* src,
                                                          int src_count,
                                                          int fix_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-to-zero mode.
 *
 * @details The function converts type of ``<src>`` from fix8 to half element-wisely in round-to-zero mode and saves the result in ``<dst>``.
 * \rst
 * The data type conversion process is illustrated by Figure :ref:`convert_with_stride`. ``<src>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<src_stride>`` bytes. ``<dst>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<dst_stride>`` bytes. In each block of ``<src>``, this function converts first ``<src_count>`` elements according to ``<fix_position>`` in round-to-zero mode, and saves the result in blocks in ``<dst>`` sequentially. If ``<src_stride>`` is zero, this function only converts the first block ``<segnum> + 1`` times.
 * \endrst
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 * @param[in] dst_stride Destination address stride in bytes.
 * @param[in] src_stride Source address stride in bytes.
 * @param[in] segnum Section number.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<fix_position>`` must be in the range ``[-31,32]`` on ``(m)tp_1xx``;
 * - ``<fix_position>`` must be in the range ``[-127,127]`` on ``(m)tp_2xx`` and higher;
 * - ``<dst_stride>`` and ``<src_stride>`` must be divisible by 64 on ``(m)tp_1xx``;
 * - ``<dst_stride>`` must be greater than zero and a multiple of sizeof(half);
 * - :math:`<dst\_stride> \div sizeof(half) \ge <src\_count>`;
 * - ``<src_stride>`` must be greater than or equal to zero, and divisible by sizeof(fix8);
 * - :math:`<src\_stride> \div sizeof(fix8) \ge <src\_count>` if ``<src_stride>`` is greater than zero;
 * - ``<segnum>`` must be greater than or equal to zero;
 * - ``<src>`` and ``<dst>`` can not be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SRC_STRIDE 160
 *   #define DST_STRIDE 320
 *   #define LEN 128
 *   #define SEG_NUM 20
 *   #define POS 5
 *
 *   __mlu_entry__ void kernel(half *dst, fix8 *src, int size) {
 *     __nram__ fix8 src_tmp[SRC_STRIDE * SEG_NUM + LEN];
 *     __nram__ half dst_tmp[DST_STRIDE / sizeof(half) * SEG_NUM + LEN];
 *     __memcpy(src_tmp, src, size, GDRAM2NRAM);
 *     __bang_fix82half(dst_tmp, src_tmp, LEN, POS, DST_STRIDE, SRC_STRIDE, SEG_NUM);
 *     __memcpy(dst, dst_tmp, (DST_STRIDE * SEG_NUM + LEN * sizeof(half)), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_fix82half(half* dst,
                                                          fix8* src,
                                                          int src_count,
                                                          int fix_position,
                                                          int dst_stride,
                                                          int src_stride,
                                                          int segnum);

//Group:Stream Type Conversion Functions
static __mlu_func__ __mlu_builtin__ void __bang_int82half(half* dst,
                                                          int8* src,
                                                          int src_count,
                                                          int fix_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-to-zero mode.
 *
 * @details The function converts type of ``<src>`` from int8 to half element-wisely in round-to-zero mode and saves the result in ``<dst>``.
 * \rst
 * The data type conversion process is illustrated by Figure :ref:`convert_with_stride`. ``<src>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<src_stride>`` bytes. ``<dst>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<dst_stride>`` bytes. In each block of ``<src>``, this function converts first ``<src_count>`` elements according to ``<fix_position>`` in round-to-zero mode, and saves the result in blocks in ``<dst>`` sequentially. If ``<src_stride>`` is zero, this function only converts the first block ``<segnum> + 1`` times.
 * \endrst
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 * @param[in] dst_stride Destination address stride in bytes.
 * @param[in] src_stride Source address stride in bytes.
 * @param[in] segnum Section number.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<fix_position>`` must be in the range ``[-31,32]`` on ``(m)tp_1xx``;
 * - ``<fix_position>`` must be in the range ``[-127,127]`` on ``(m)tp_2xx`` and higher;
 * - ``<dst_stride>`` and ``<src_stride>`` must be divisible by 64 on ``(m)tp_1xx``;
 * - ``<dst_stride>`` must be greater than zero and divisible by sizeof(half);
 * - :math:`<dst\_stride> \div sizeof(half) \ge <src\_count>`;
 * - ``<src_stride>`` must be greater than or equal to zero, and divisible by sizeof(int8);
 * - :math:`<src\_stride> \div sizeof(int8) \ge <src\_count>` if ``<src_stride>`` is greater than zero;
 * - ``<segnum>`` must be greater than or equal to zero;
 * - ``<src>`` and ``<dst>`` can not be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SRC_STRIDE 160
 *   #define DST_STRIDE 320
 *   #define LEN 128
 *   #define SEG_NUM 20
 *   #define POS 5
 *
 *   __mlu_entry__ void kernel(half *dst, int8 *src, int size) {
 *     __nram__ int8 src_tmp[SRC_STRIDE * SEG_NUM + LEN];
 *     __nram__ half dst_tmp[DST_STRIDE / sizeof(half) * SEG_NUM + LEN];
 *     __memcpy(src_tmp, src, size, GDRAM2NRAM);
 *     __bang_int82half(dst_tmp, src_tmp, LEN, POS, DST_STRIDE, SRC_STRIDE, SEG_NUM);
 *     __memcpy(dst, dst_tmp, (DST_STRIDE * SEG_NUM + LEN * sizeof(half)), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int82half(half* dst,
                                                          int8* src,
                                                          int src_count,
                                                          int fix_position,
                                                          int dst_stride,
                                                          int src_stride,
                                                          int segnum);

//Group:Stream Type Conversion Functions
static __mlu_func__ __mlu_builtin__ void __bang_uchar2half(half* dst,
                                                           unsigned char* src,
                                                           int src_count);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-to-zero mode.
 *
 * @details The function converts type of ``<src>`` from unsigned char to half element-wisely in round-to-zero mode and saves the result in ``<dst>``.
 * \rst
 * The data type conversion process is illustrated by Figure :ref:`convert_with_stride`. ``<src>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<src_stride>`` bytes. ``<dst>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<dst_stride>`` bytes. In each block of ``<src>``, this function converts first ``<src_count>`` elements in round-to-zero mode, and saves the result in blocks in ``<dst>`` sequentially. If ``<src_stride>`` is zero, this function only converts the first block ``<segnum> + 1`` times.
 * \endrst
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] dst_stride Destination address stride in bytes.
 * @param[in] src_stride Source address stride in bytes.
 * @param[in] segnum Section number.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst_stride>`` and ``<src_stride>`` must be divisible by 64 on ``(m)tp_1xx``;
 * - ``<dst_stride>`` must be greater than zero and divisible by sizeof(half);
 * - :math:`<dst\_stride> \div sizeof(half) \ge <src\_count>`;
 * - ``<src_stride>`` must be greater than or equal to zero, and divisible by sizeof(unsigned char);
 * - ``<src>`` and ``<dst>`` can not be homologous operands;
 * - :math:`<src\_stride> \div sizeof(unsigned char) \ge <src\_count>` if ``<src_stride>`` is greater than zero;
 * - ``<segnum>`` must be greater than or equal to zero;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SRC_STRIDE 160
 *   #define DST_STRIDE 320
 *   #define LEN 128
 *   #define SEG_NUM 20
 *
 *   __mlu_entry__ void kernel(half *dst, unsigned char *src, int size) {
 *     __nram__ unsigned char src_tmp[SRC_STRIDE * SEG_NUM + LEN];
 *     __nram__ half dst_tmp[DST_STRIDE / sizeof(half) * SEG_NUM + LEN];
 *     __memcpy(src_tmp, src, size, GDRAM2NRAM);
 *     __bang_uchar2half(dst_tmp, src_tmp, LEN, DST_STRIDE, SRC_STRIDE, SEG_NUM);
 *     __memcpy(dst, dst_tmp, (DST_STRIDE * SEG_NUM + LEN * sizeof(half)), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_uchar2half(half* dst,
                                                           unsigned char* src,
                                                           int src_count,
                                                           int dst_stride,
                                                           int src_stride,
                                                           int segnum);

//Group:Stream Type Conversion Functions
static __mlu_func__ __mlu_builtin__ void __bang_short2half(half* dst,
                                                           short* src,
                                                           int src_count);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-to-zero mode.
 *
 * @details The function converts type of ``<src>`` from short to half element-wisely in round-to-zero mode and saves the result in ``<dst>``.
 * \rst
 * The data type conversion process is illustrated by Figure :ref:`convert_with_stride`. ``<src>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<src_stride>`` bytes. ``<dst>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<dst_stride>`` bytes. In each block of ``<src>``, this function converts first ``<src_count>`` elements in round-to-zero mode, and saves the result in blocks in ``<dst>`` sequentially. If ``<src_stride>`` is zero, this function only converts the first block ``<segnum> + 1`` times.
 * \endrst
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] dst_stride Destination address stride in bytes.
 * @param[in] src_stride Source address stride in bytes.
 * @param[in] segnum Section number.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and divisible by 64 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst_stride>`` and ``<src_stride>`` must be divisible by 64 on ``(m)tp_1xx``;
 * - ``<dst_stride>`` must be greater than zero and divisible by sizeof(half);
 * - :math:`<dst\_stride> \div sizeof(half) \ge <src\_count>`;
 * - ``<src_stride>`` must be greater than or equal to zero, and divisible by sizeof(short);
 * - :math:`<src\_stride> \div sizeof(short) \ge <src\_count>` if ``<src_stride>`` is greater than zero;
 * - ``<segnum>`` must be greater than or equal to zero;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SRC_STRIDE 160
 *   #define DST_STRIDE 320
 *   #define LEN 128
 *   #define SEG_NUM 20
 *   #define POS 5
 *
 *   __mlu_entry__ void kernel(half *dst, short *src, int size) {
 *     __nram__ short src_tmp[SRC_STRIDE * SEG_NUM + LEN];
 *     __nram__ half dst_tmp[DST_STRIDE / sizeof(half) * SEG_NUM + LEN];
 *     __memcpy(src_tmp, src, size * sizeof(short), GDRAM2NRAM);
 *     __bang_short2half(dst_tmp, src_tmp, LEN, POS, DST_STRIDE, SRC_STRIDE, SEG_NUM);
 *     __memcpy(dst, dst_tmp, (DST_STRIDE * SEG_NUM + LEN * sizeof(half)), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_short2half(half* dst,
                                                           short* src,
                                                           int src_count,
                                                           int dst_stride,
                                                           int src_stride,
                                                           int segnum);

//Group:Stream Type Conversion Functions
static __mlu_func__ __mlu_builtin__ void __bang_float2half_tz(half* dst,
                                                              float* src,
                                                              int src_count);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-to-zero mode.
 *
 * @details The function converts type of ``<src>`` from float to half element-wisely in round-to-zero mode and saves the result in ``<dst>``.
 * \rst
 * The data type conversion process is illustrated by Figure :ref:`convert_with_stride`. ``<src>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<src_stride>`` bytes. ``<dst>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<dst_stride>`` bytes. In each block of ``<src>``, this function converts first ``<src_count>`` elements in round-to-zero mode, and saves the result in blocks in ``<dst>`` sequentially. If ``<src_stride>`` is zero, this function only converts the first block ``<segnum> + 1`` times.
 * \endrst
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] dst_stride Destination address stride in bytes.
 * @param[in] src_stride Source address stride in bytes.
 * @param[in] segnum Section number.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and divisible by 64 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst_stride>`` and ``<src_stride>`` must be divisible by 64 on ``(m)tp_1xx``;
 * - ``<dst_stride>`` must be greater than zero and divisible by sizeof(half);
 * - :math:`<dst\_stride> \div sizeof(half) \ge <src\_count>`;
 * - ``<src_stride>`` must be greater than or equal to zero, and divisible by sizeof(float);
 * - :math:`<src\_stride> \div sizeof(float) \ge <src\_count>` if ``<src_stride>`` is greater than zero;
 * - ``<segnum>`` must be greater than or equal to zero;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SRC_STRIDE 160
 *   #define DST_STRIDE 320
 *   #define LEN 128
 *   #define SEG_NUM 20
 *   #define POS 5
 *
 *   __mlu_entry__ void kernel(half *dst, float *src, int size) {
 *     __nram__ float src_tmp[SRC_STRIDE * SEG_NUM + LEN];
 *     __nram__ half dst_tmp[DST_STRIDE / sizeof(half) * SEG_NUM + LEN];
 *     __memcpy(src_tmp, src, size * sizeof(float), GDRAM2NRAM);
 *     __bang_float2half_tz(dst_tmp, src_tmp, LEN, POS, DST_STRIDE, SRC_STRIDE, SEG_NUM);
 *     __memcpy(dst, dst_tmp, (DST_STRIDE * SEG_NUM + LEN * sizeof(half)), NRAM2GDRAM);
 *   }
 *
 * @endcode.
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2half_tz(half* dst,
                                                              float* src,
                                                              int src_count,
                                                              int dst_stride,
                                                              int src_stride,
                                                              int segnum);

//Group:Stream Type Conversion Functions
static __mlu_func__ __mlu_builtin__ void __bang_float2half_dn(half* dst,
                                                              float* src,
                                                              int src_count);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-down mode.
 *
 * @details The function converts type of ``<src>`` from float to half element-wisely in round-down mode and saves the result in ``<dst>``.
 * \rst
 * The data type conversion process is illustrated by Figure :ref:`convert_with_stride`. ``<src>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<src_stride>`` bytes. ``<dst>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<dst_stride>`` bytes. In each block of ``<src>``, this function converts first ``<src_count>`` elements in round-down mode, and saves the result in blocks in ``<dst>`` sequentially. If ``<src_stride>`` is zero, this function only converts the first block ``<segnum> + 1`` times.
 * \endrst
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] dst_stride Destination address stride in bytes.
 * @param[in] src_stride Source address stride in bytes.
 * @param[in] segnum Section number.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and divisible by 64 on ``(m)tp_2xx``;
 * - ``<dst_stride>`` must be greater than zero and divisible by sizeof(half);
 * - :math:`<dst\_stride> \div sizeof(half) \ge <src\_count>`;
 * - ``<src_stride>`` must be greater than or equal to zero, and divisible by sizeof(float);
 * - :math:`<src\_stride> \div sizeof(float) \ge <src\_count>` if ``<src_stride>`` is greater than zero;
 * - ``<segnum>`` must be greater than or equal to zero;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * See the example of ::__bang_float2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2half_dn(half* dst,
                                                              float* src,
                                                              int src_count,
                                                              int dst_stride,
                                                              int src_stride,
                                                              int segnum);

//Group:Stream Type Conversion Functions
static __mlu_func__ __mlu_builtin__ void __bang_float2half_oz(half* dst,
                                                              float* src,
                                                              int src_count);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from float to half element-wisely in round-off-zero mode and saves the result in ``<dst>``.
 * \rst
 * The data type conversion process is illustrated by Figure :ref:`convert_with_stride`. ``<src>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<src_stride>`` bytes. ``<dst>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<dst_stride>`` bytes. In each block of ``<src>``, this function converts first ``<src_count>`` elements in round-off-zero mode, and saves the result in blocks in ``<dst>`` sequentially. If ``<src_stride>`` is zero, this function only converts the first block ``<segnum> + 1`` times.
 * \endrst
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] dst_stride Destination address stride in bytes.
 * @param[in] src_stride Source address stride in bytes.
 * @param[in] segnum Section number.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and divisible by 64 on ``(m)tp_2xx``;
 * - ``<dst_stride>`` must be greater than zero and divisible by sizeof(half);
 * - :math:`<dst\_stride> \div sizeof(half) \ge <src\_count>`;
 * - ``<src_stride>`` must be greater than or equal to zero, and divisible by sizeof(float);
 * - :math:`<src\_stride> \div sizeof(float) \ge <src\_count>` if ``<src_stride>`` is greater than zero;
 * - ``<segnum>`` must be greater than or equal to zero;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= (m)tp_2xx`` .
 *
 * @par Example
 * See the example of ::__bang_float2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2half_oz(half* dst,
                                                              float* src,
                                                              int src_count,
                                                              int dst_stride,
                                                              int src_stride,
                                                              int segnum);

//Group:Stream Type Conversion Functions
static __mlu_func__ __mlu_builtin__ void __bang_float2half_up(half* dst,
                                                              float* src,
                                                              int src_count);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-up mode.
 *
 * @details The function converts type of ``<src>`` from float to half element-wisely in round-up mode and saves the result in ``<dst>``.
 * \rst
 * The data type conversion process is illustrated by Figure :ref:`convert_with_stride`. ``<src>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<src_stride>`` bytes. ``<dst>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<dst_stride>`` bytes. In each block of ``<src>``, this function converts first ``<src_count>`` elements in round-up mode, and saves the result in blocks in ``<dst>`` sequentially. If ``<src_stride>`` is zero, this function only converts the first block ``<segnum> + 1`` times.
 * \endrst
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] dst_stride Destination address stride in bytes.
 * @param[in] src_stride Source address stride in bytes.
 * @param[in] segnum Section number.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and divisible by 64 on ``(m)tp_2xx``;
 * - ``<dst_stride>`` must be greater than zero and divisible by sizeof(half);
 * - :math:`<dst\_stride> \div sizeof(half) \ge <src\_count>`;
 * - ``<src_stride>`` must be greater than or equal to zero, and divisible by sizeof(float);
 * - :math:`<src\_stride> \div sizeof(float) \ge <src\_count>` if ``<src_stride>`` is greater than zero;
 * - ``<segnum>`` must be greater than or equal to zero;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= (m)tp_2xx`` .
 *
 * @par Example
 * See the example of ::__bang_float2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2half_up(half* dst,
                                                              float* src,
                                                              int src_count,
                                                              int dst_stride,
                                                              int src_stride,
                                                              int segnum);

//Group:Stream Type Conversion Functions
static __mlu_func__ __mlu_builtin__ void __bang_float2half_rd(half* dst,
                                                              float* src,
                                                              int src_count);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from float to half element-wisely in round-nearest-off-zero mode and saves the result in ``<dst>``.
 * \rst
 * The data type conversion process is illustrated by Figure :ref:`convert_with_stride`. ``<src>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<src_stride>`` bytes. ``<dst>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<dst_stride>`` bytes. In each block of ``<src>``, this function converts first ``<src_count>`` elements in round-nearest-off-zero mode, and saves the result in blocks in ``<dst>`` sequentially. If ``<src_stride>`` is zero, this function only converts the first block ``<segnum> + 1`` times.
 * \endrst
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] dst_stride Destination address stride in bytes.
 * @param[in] src_stride Source address stride in bytes.
 * @param[in] segnum Section number.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and divisible by 64 on ``(m)tp_2xx``;
 * - ``<dst_stride>`` must be greater than zero and divisible by sizeof(half);
 * - :math:`<dst\_stride> \div sizeof(half) \ge <src\_count>`;
 * - ``<src_stride>`` must be greater than or equal to zero, and divisible by sizeof(float);
 * - :math:`<src\_stride> \div sizeof(float) \ge <src\_count>` if ``<src_stride>`` is greater than zero;
 * - ``<segnum>`` must be greater than or equal to zero;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * See the example of ::__bang_float2half_tz for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2half_rd(half* dst,
                                                              float* src,
                                                              int src_count,
                                                              int dst_stride,
                                                              int src_stride,
                                                              int segnum);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-math mode.
 *
 * @details The function converts type of ``<src>`` from float to half element-wisely in round-math mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The elements number of conversion.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<src_count>`` must be greater than zero;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(half *dst, float *src) {
 *     __nram__ float src_tmp[SIZE];
 *     __nram__ half dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);
 *     __bang_float2half_rm(dst_tmp, src_tmp, SIZE);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(half), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2half_rm(half* dst,
                                                              float* src,
                                                              int src_count);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-nearest-even mode.
 *
 * @details The function converts type of ``<src>`` from float to half element-wisely in round-nearest-even mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The elements number of conversion.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<src_count>`` must be greater than zero;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * See the example of ::__bang_float2half_rm for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2half_rn(half* dst,
                                                              float* src,
                                                              int src_count);

static __mlu_func__ __mlu_builtin__ void __bang_float2half_sr(half* dst,
                                                              float* src,
                                                              int* srv,
                                                              int count);

static __mlu_func__ __mlu_builtin__ void __bang_float2tf32_sr(float* dst,
                                                              float* src,
                                                              int* srv,
                                                              int count);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-math mode.
 *
 * @details The function converts type of ``<src>`` from float to bfloat16_t element-wisely in round-math mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The elements number of conversion.
 *
 * @return ``void``.
 *
 * @remark
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_count>`` must be greater than zero.
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(bfloat16_t *dst, float *src) {
 *     __nram__ float src_tmp[SIZE];
 *     __nram__ bfloat16_t dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);
 *     __bang_float2bfloat16_rm(dst_tmp, src_tmp, SIZE);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(bfloat16_t), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2bfloat16_rm(bfloat16_t* dst,
                                                                  float* src,
                                                                  int src_count);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-nearest-even mode.
 *
 * @details The function converts type of ``<src>`` from float to bfloat16_t element-wisely in round-nearest-even mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The elements number of conversion.
 *
 * @return ``void``.
 *
 * @remark
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_count>`` must be greater than zero.
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * See the example of ::__bang_float2bfloat16_rm for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2bfloat16_rn(bfloat16_t* dst,
                                                                  float* src,
                                                                  int src_count);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from float to bfloat16_t element-wisely in round-nearest-off-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The elements number of conversion.
 *
 * @return ``void``.
 *
 * @remark
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_count>`` must be greater than zero.
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * See the example of ::__bang_float2bfloat16_rm for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2bfloat16_rd(bfloat16_t* dst,
                                                                  float* src,
                                                                  int src_count);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-up mode.
 *
 * @details The function converts type of ``<src>`` from float to bfloat16_t element-wisely in round-up mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The elements number of conversion.
 *
 * @return ``void``.
 *
 * @remark
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_count>`` must be greater than zero.
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * See the example of ::__bang_float2bfloat16_rm for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2bfloat16_up(bfloat16_t* dst,
                                                                  float* src,
                                                                  int src_count);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from float to bfloat16_t element-wisely in round-off-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The elements number of conversion.
 *
 * @return ``void``.
 *
 * @remark
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_count>`` must be greater than zero.
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * See the example of ::__bang_float2bfloat16_rm for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2bfloat16_oz(bfloat16_t* dst,
                                                                  float* src,
                                                                  int src_count);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-down mode.
 *
 * @details The function converts type of ``<src>`` from float to bfloat16_t element-wisely in round-down mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The elements number of conversion.
 *
 * @return ``void``.
 *
 * @remark
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_count>`` must be greater than zero.
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * See the example of ::__bang_float2bfloat16_rm for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2bfloat16_dn(bfloat16_t* dst,
                                                                  float* src,
                                                                  int src_count);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-to-zero mode.
 *
 * @details The function converts type of ``<src>`` from float to bfloat16_t element-wisely in round-to-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The elements number of conversion.
 *
 * @return ``void``.
 *
 * @remark
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_count>`` must be greater than zero.
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * See the example of ::__bang_float2bfloat16_rm for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2bfloat16_tz(bfloat16_t* dst,
                                                                  float* src,
                                                                  int src_count);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-math mode.
 *
 * @details The function converts type of ``<src>`` from bfloat16_t to float element-wisely in round-math mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The elements number of conversion.
 *
 * @return ``void``.
 *
 * @remark
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<src>`` and ``<dst>`` can not be homologous operands;
 * - ``<src_count>`` must be greater than zero.
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(float *dst, bfloat16_t *src) {
 *     __nram__ bfloat16_t src_tmp[SIZE];
 *     __nram__ float dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(bfloat16_t), GDRAM2NRAM);
 *     __bang_bfloat162float_rm(dst_tmp, src_tmp, SIZE);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(float), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_bfloat162float_rm(float* dst,
                                                                  bfloat16_t* src,
                                                                  int src_count);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-nearest-even mode.
 *
 * @details The function converts type of ``<src>`` from bfloat16_t to float element-wisely in round-nearest-even mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The elements number of conversion.
 *
 * @return ``void``.
 *
 * @remark
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<src>`` and ``<dst>`` can not be homologous operands;
 * - ``<src_count>`` must be greater than zero.
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * See the example of ::__bang_bfloat162float_rm for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_bfloat162float_rn(float* dst,
                                                                  bfloat16_t* src,
                                                                  int src_count);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from bfloat16_t to float element-wisely in round-nearest-off-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The elements number of conversion.
 *
 * @return ``void``.
 *
 * @remark
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<src>`` and ``<dst>`` can not be homologous operands;
 * - ``<src_count>`` must be greater than zero.
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * See the example of ::__bang_bfloat162float_rm for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_bfloat162float_rd(float* dst,
                                                                  bfloat16_t* src,
                                                                  int src_count);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-up mode.
 *
 * @details The function converts type of ``<src>`` from bfloat16_t to float element-wisely in round-up mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The elements number of conversion.
 *
 * @return ``void``.
 *
 * @remark
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<src>`` and ``<dst>`` can not be homologous operands;
 * - ``<src_count>`` must be greater than zero.
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * See the example of ::__bang_bfloat162float_rm for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_bfloat162float_up(float* dst,
                                                                  bfloat16_t* src,
                                                                  int src_count);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from bfloat16_t to float element-wisely in round-off-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The elements number of conversion.
 *
 * @return ``void``.
 *
 * @remark
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<src>`` and ``<dst>`` can not be homologous operands;
 * - ``<src_count>`` must be greater than zero.
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * See the example of ::__bang_bfloat162float_rm for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_bfloat162float_oz(float* dst,
                                                                  bfloat16_t* src,
                                                                  int src_count);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-down mode.
 *
 * @details The function converts type of ``<src>`` from bfloat16_t to float element-wisely in round-down mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The elements number of conversion.
 *
 * @return ``void``.
 *
 * @remark
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<src>`` and ``<dst>`` can not be homologous operands;
 * - ``<src_count>`` must be greater than zero.
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * See the example of ::__bang_bfloat162float_rm for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_bfloat162float_dn(float* dst,
                                                                  bfloat16_t* src,
                                                                  int src_count);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-to-zero mode.
 *
 * @details The function converts type of ``<src>`` from bfloat16_t to float element-wisely in round-to-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The elements number of conversion.
 *
 * @return ``void``.
 *
 * @remark
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<src>`` and ``<dst>`` can not be homologous operands;
 * - ``<src_count>`` must be greater than zero.
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``..
 *
 * @par Example
 * See the example of ::__bang_bfloat162float_rm for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_bfloat162float_tz(float* dst,
                                                                  bfloat16_t* src,
                                                                  int src_count);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-down mode.
 *
 * @details The function converts type of ``<src>`` from half to int16 element-wisely in round-down mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and divisible by 64 on ``(m)tp_2xx``;
 * - ``<fix_position>`` must be in the range ``[-127,127]``;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= (m)tp_2xx`` .
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *   #define POS 5
 *
 *   __mlu_entry__ void kernel(int16 *dst, half *src) {
 *     __nram__ half src_tmp[SIZE];
 *     __nram__ int16 dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(half), GDRAM2NRAM);
 *     __bang_half2int16_dn(dst_tmp, src_tmp, SIZE, POS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int16), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_half2int16_dn(int16* dst,
                                                              half* src,
                                                              int src_count,
                                                              int fix_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-to-zero mode.
 *
 * @details The function converts type of ``<src>`` from half to int16 element-wisely in round-to-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and divisible by 64 on ``(m)tp_2xx``;
 * - ``<fix_position>`` must be in the range ``[-127,127]``;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= (m)tp_2xx`` .
 *
 * @par Example
 * See the example of ::__bang_half2int16_dn for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_half2int16_tz(int16* dst,
                                                              half* src,
                                                              int src_count,
                                                              int fix_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from half to int16 element-wisely in round-off-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and divisible by 64 on ``(m)tp_2xx``;
 * - ``<fix_position>`` must be in the range ``[-127,127]``;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= (m)tp_2xx`` .
 *
 * @par Example
 * See the example of ::__bang_half2int16_dn for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_half2int16_oz(int16* dst,
                                                              half* src,
                                                              int src_count,
                                                              int fix_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-up mode.
 *
 * @details The function converts type of ``<src>`` from half to int16 element-wisely in round-up mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and divisible by 64 on ``(m)tp_2xx``;
 * - ``<fix_position>`` must be in the range ``[-127,127]``;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= (m)tp_2xx`` .
 *
 * @par Example
 * See the example of ::__bang_half2int16_dn for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_half2int16_up(int16* dst,
                                                              half* src,
                                                              int src_count,
                                                              int fix_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from half to int16 element-wisely in round-nearest-off-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and divisible by 64 on ``(m)tp_2xx``;
 * - ``<fix_position>`` must be in the range ``[-127,127]``;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= (m)tp_2xx`` .
 *
 * @par Example
 * See the example of ::__bang_half2int16_dn for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_half2int16_rd(int16* dst,
                                                              half* src,
                                                              int src_count,
                                                              int fix_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-math mode.
 *
 * @details The function converts type of ``<src>`` from half to int16 element-wisely in round-math mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<src_count>`` must be greater than zero;
 * - ``<fix_position>`` must be in the range ``[-127,127]``;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * See the example of ::__bang_half2int16_dn for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_half2int16_rm(int16* dst,
                                                              half* src,
                                                              int src_count,
                                                              int fix_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-nearest-even mode.
 *
 * @details The function converts type of ``<src>`` from half to int16 element-wisely in round-nearest-even mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<src_count>`` must be greater than zero;
 * - ``<fix_position>`` must be in the range ``[-127,127]``;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * See the example of ::__bang_half2int16_dn for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_half2int16_rn(int16* dst,
                                                              half* src,
                                                              int src_count,
                                                              int fix_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-to-zero mode.
 *
 * @details The function converts type of ``<src>`` from int16 to half element-wisely in round-to-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and divisible by 64 on ``(m)tp_2xx``;
 * - ``<fix_position>`` must be in the range ``[-127,127]``;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *   #define POS 5
 *
 *   __mlu_entry__ void kernel(half *dst, int16 *src) {
 *     __nram__ int16 src_tmp[SIZE];
 *     __nram__ half dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int16), GDRAM2NRAM);
 *     __bang_int162half(dst_tmp, src_tmp, SIZE, POS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(half), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int162half(half* dst,
                                                           int16* src,
                                                           int src_count,
                                                           int fix_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-down mode.
 *
 * @details The function converts type of ``<src>`` from float to int16 element-wisely in round-down mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and divisible by 64 on ``(m)tp_2xx``;
 * - ``<fix_position>`` must be in the range ``[-127,127]``;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *   #define POS 5
 *
 *   __mlu_entry__ void kernel(int16 *dst, float *src) {
 *     __nram__ float src_tmp[SIZE];
 *     __nram__ int16 dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);
 *     __bang_float2int16_dn(dst_tmp, src_tmp, SIZE, POS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int16), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2int16_dn(int16* dst,
                                                               float* src,
                                                               int src_count,
                                                               int fix_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-to-zero mode.
 *
 * @details The function converts type of ``<src>`` from float to int16 element-wisely in round-to-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and divisible by 64 on ``(m)tp_2xx``;
 * - ``<fix_position>`` must be in the range ``[-127,127]``.
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - Seethe table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * See the example of ::__bang_float2int16_dn for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2int16_tz(int16* dst,
                                                               float* src,
                                                               int src_count,
                                                               int fix_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from float to int16 element-wisely in round-off-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and divisible by 64 on ``(m)tp_2xx``;
 * - ``<fix_position>`` must be in the range ``[-127,127]``;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * See the example of ::__bang_float2int16_dn for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2int16_oz(int16* dst,
                                                               float* src,
                                                               int src_count,
                                                               int fix_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-up mode.
 *
 * @details The function converts type of ``<src>`` from float to int16 element-wisely in round-up mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and divisible by 64 on ``(m)tp_2xx``;
 * - ``<fix_position>`` must be in the range ``[-127,127]``;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * See the example of ::__bang_float2int16_dn for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2int16_up(int16* dst,
                                                               float* src,
                                                               int src_count,
                                                               int fix_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from float to int16 element-wisely in round-nearest-off-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and divisible by 64 on ``(m)tp_2xx``;
 * - ``<fix_position>`` must be in the range ``[-127,127]``;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * See the example of ::__bang_float2int16_dn for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2int16_rd(int16* dst,
                                                               float* src,
                                                               int src_count,
                                                               int fix_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-math mode.
 *
 * @details The function converts type of ``<src>`` from float to int16 element-wisely in round-math mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<src_count>`` must be greater than zero;
 * - ``<fix_position>`` must be in the range ``[-127,127]``;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * See the example of ::__bang_float2int16_dn for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2int16_rm(int16* dst,
                                                               float* src,
                                                               int src_count,
                                                               int fix_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-nearest-even mode.
 *
 * @details The function converts type of ``<src>`` from float to int16 element-wisely in round-nearest-even mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<src_count>`` must be greater than zero.
 * - ``<fix_position>`` must be in the range ``[-127,127]``;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * See the example of ::__bang_float2int16_dn for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2int16_rn(int16* dst,
                                                               float* src,
                                                               int src_count,
                                                               int fix_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-to-zero mode.
 *
 * @details The function converts type of ``<src>`` from int16 to float element-wisely in round-to-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and divisible by 64 on ``(m)tp_2xx``;
 * - ``<fix_position>`` must be in the range ``[-127,127]``;
 * - ``<src>`` and ``<dst>`` can not be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *   #define POS 5
 *
 *   __mlu_entry__ void kernel(float *dst, int16 *src) {
 *     __nram__ int16 src_tmp[SIZE];
 *     __nram__ float dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);
 *     __bang_int162float(dst_tmp, src_tmp, SIZE, POS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int16), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int162float(float* dst,
                                                            int16* src,
                                                            int src_count,
                                                            int fix_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-down mode.
 *
 * @details The function converts type of ``<src>`` from float to int8 element-wisely in round-down mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The elements number of conversion.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and divisible by 128 on ``(m)tp_2xx``;
 * - ``<fix_position>`` must be in the range ``[-127,127]``;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *   #define POS 5
 *
 *   __mlu_entry__ void kernel(int8 *dst, float *src) {
 *     __nram__ float src_tmp[SIZE];
 *     __nram__ int8 dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);
 *     __bang_float2int8_dn(dst_tmp, src_tmp, SIZE, POS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int8), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2int8_dn(int8* dst,
                                                              float* src,
                                                              int src_count,
                                                              int fix_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-to-zero mode.
 *
 * @details The function converts type of ``<src>`` from float to int8 element-wisely in round-to-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The elements number of conversion.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and divisible by 128 on ``(m)tp_2xx``;
 * - ``<fix_position>`` must be in the range ``[-127,127]``;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * @par
 * See the example of ::__bang_float2int8_dn for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2int8_tz(int8* dst,
                                                              float* src,
                                                              int src_count,
                                                              int fix_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from float to int8 element-wisely in round-off-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The elements number of conversion.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and divisible by 128 on ``(m)tp_2xx``;
 * - ``<fix_position>`` must be in the range ``[-127,127]``;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * @par
 * See the example of ::__bang_float2int8_dn for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2int8_oz(int8* dst,
                                                              float* src,
                                                              int src_count,
                                                              int fix_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-up mode.
 *
 * @details The function converts type of ``<src>`` from float to int8 element-wisely in round-up mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The elements number of conversion.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and divisible by 128 on ``(m)tp_2xx``;
 * - ``<fix_position>`` must be in the range ``[-127,127]``;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * @par
 * See the example of ::__bang_float2int8_dn for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2int8_up(int8* dst,
                                                              float* src,
                                                              int src_count,
                                                              int fix_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from float to int8 element-wisely in round-nearest-off-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The elements number of conversion.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and divisible by 128 on ``(m)tp_2xx``;
 * - ``<fix_position>`` must be in the range ``[-127,127]``;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * @par
 * See the example of ::__bang_float2int8_dn for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2int8_rd(int8* dst,
                                                              float* src,
                                                              int src_count,
                                                              int fix_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts element data type element-wisely in round-math mode.
 *
 * @details The function converts type of ``<src>`` from float to int8 element-wisely in round-math mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The elements number of conversion.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<src_count>`` must be greater than zero;
 * - ``<fix_position>`` must be in the range ``[-127,127]``;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @par
 * See the example of ::__bang_float2int8_dn for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2int8_rm(int8* dst,
                                                              float* src,
                                                              int src_count,
                                                              int fix_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts element data type element-wisely in round-nearest-even mode.
 *
 * @details The function converts type of ``<src>`` from float to int8 element-wisely in round-nearest-even mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The elements number of conversion.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<src_count>`` must be greater than zero;
 * - ``<fix_position>`` must be in the range ``[-127,127]``;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @par
 * See the example of ::__bang_float2int8_dn for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2int8_rn(int8* dst,
                                                              float* src,
                                                              int src_count,
                                                              int fix_position);

static __mlu_func__ __mlu_builtin__ void __bang_int2float(float* dst,
                                                          float* dst_addition,
                                                          int* src,
                                                          float* src_addition,
                                                          int src_count);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-to-zero mode.
 *
 * @details The function converts type of ``<src>`` from int to float element-wisely in round-to-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The elements number of conversion.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<src_count>`` must be greater than zero;
 * - ``<fix_position>`` must be in the range ``[-127,127]``;
 * - ``<src>`` and ``<dst>`` can not be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_integer_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322`` ;
 *     - CNCC Version: ``cncc --version >= 3.0.0`` ;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30`` ;
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *   #define POS 5
 *
 *   __mlu_entry__ void kernel(float *dst, int *src) {
 *     __nram__ int src_tmp[SIZE];
 *     __nram__ float dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int), GDRAM2NRAM);
 *     __bang_int2float(dst_tmp, src_tmp, SIZE, POS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(float), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int2float(float* dst,
                                                          int* src,
                                                          int src_count,
                                                          int fix_position);

static __mlu_func__ __mlu_builtin__ void __bang_float2int(int* dst,
                                                          float* dst_addition,
                                                          float* src,
                                                          float* src_addition,
                                                          int src_count);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-down mode.
 *
 * @details The function converts type of ``<src>`` from float to int element-wisely in round-down mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The elements number of conversion.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<src_count>`` must be greater than zero;
 * - ``<fix_position>`` must be in the range ``[-127,127]``;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *   #define POS 5
 *
 *   __mlu_entry__ void kernel(int *dst, float *src) {
 *     __nram__ float src_tmp[SIZE];
 *     __nram__ int dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);
 *     __bang_float2int_dn(dst_tmp, src_tmp, SIZE, POS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2int_dn(int* dst,
                                                             float* src,
                                                             int src_count,
                                                             int fix_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-to-zero mode.
 *
 * @details The function converts type of ``<src>`` from float to int element-wisely in round-to-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The elements number of conversion.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<src_count>`` must be greater than zero;
 * - ``<fix_position>`` must be in the range ``[-127,127]``;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @par
 * See the example of ::__bang_float2int_dn for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2int_tz(int* dst,
                                                             float* src,
                                                             int src_count,
                                                             int fix_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from float to int element-wisely in round-off-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The elements number of conversion.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<src_count>`` must be greater than zero;
 * - ``<fix_position>`` must be in the range ``[-127,127]``;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @par
 * See the example of ::__bang_float2int_dn for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2int_oz(int* dst,
                                                             float* src,
                                                             int src_count,
                                                             int fix_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-up mode.
 *
 * @details The function converts type of ``<src>`` from float to int element-wisely in round-up mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The elements number of conversion.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<src_count>`` must be greater than zero;
 * - ``<fix_position>`` must be in the range ``[-127,127]``;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @par
 * See the example of ::__bang_float2int_dn for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2int_up(int* dst,
                                                             float* src,
                                                             int src_count,
                                                             int fix_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from float to int element-wisely in round-nearest-off-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The elements number of conversion.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<src_count>`` must be greater than zero;
 * - ``<fix_position>`` must be in the range ``[-127,127]``;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @par
 * See the example of ::__bang_float2int_dn for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2int_rd(int* dst,
                                                             float* src,
                                                             int src_count,
                                                             int fix_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-math mode.
 *
 * @details The function converts type of ``<src>`` from float to int element-wisely in round-math mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The elements number of conversion.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<src_count>`` must be greater than zero;
 * - ``<fix_position>`` must be in the range ``[-127,127]``;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @par
 * See the example of ::__bang_float2int_dn for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2int_rm(int* dst,
                                                             float* src,
                                                             int src_count,
                                                             int fix_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-nearest-even mode.
 *
 * @details The function converts type of ``<src>`` from float to int element-wisely in round-nearest-even mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The elements number of conversion.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<src_count>`` must be greater than zero;
 * - ``<fix_position>`` must be in the range ``[-127,127]``;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @par
 * See the example of ::__bang_float2int_dn for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2int_rn(int* dst,
                                                             float* src,
                                                             int src_count,
                                                             int fix_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-to-zero mode.
 *
 * @details The function converts type of ``<src>`` from int8 to float element-wisely in round-to-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The elements number of conversion.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and divisible by 128 on ``(m)tp_2xx``;
 * - ``<fix_position>`` must be in the range ``[-127,127]``;
 * - ``<src>`` and ``<dst>`` can not be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *   #define POS 5
 *
 *   __mlu_entry__ void kernel(float *dst, int8 *src) {
 *     __nram__ int8 src_tmp[SIZE];
 *     __nram__ float dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int8), GDRAM2NRAM);
 *     __bang_int82float(dst_tmp, src_tmp, SIZE, POS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(float), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int82float(float* dst,
                                                           int8* src,
                                                           int src_count,
                                                           int fix_position);

//Group:Stream Type Conversion Functions
static __mlu_func__ __mlu_builtin__ void __bang_half2int8_dn(int8* dst,
                                                             half* src,
                                                             int src_count,
                                                             int fix_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-down mode.
 *
 * @details The function converts type of ``<src>`` from half to int8 element-wisely in round-down mode and saves the result in ``<dst>``.
 * \rst
 * The data type conversion process is illustrated by Figure :ref:`convert_with_stride`. ``<src>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<src_stride>`` bytes. ``<dst>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<dst_stride>`` bytes. In each block of ``<src>``, this function converts first ``<src_count>`` elements according to ``<fix_position>`` in round-down mode, and saves the result in blocks in ``<dst>`` sequentially. If ``<src_stride>`` is zero, this function only converts the first block ``<segnum> + 1`` times.
 *
 *   .. _convert_with_stride:
 *
 *   .. figure:: ../img/convert_with_stride.*
 *      :scale: 60%
 *
 *      The Process of Conversion With Stride
 *
 * \endrst
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The elements number.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 * @param[in] dst_stride Destination address stride in bytes.
 * @param[in] src_stride Source address stride in bytes.
 * @param[in] segnum Section number.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<fix_position>`` must be in the range ``[-31,31]`` on ``(m)tp_1xx``;
 * - ``<fix_position>`` must be in the range ``[-127,127]`` on ``(m)tp_2xx`` and higher;
 * - ``<dst_stride>`` and ``<src_stride>`` must be divisible by 64 on ``(m)tp_1xx``;
 * - ``<dst_stride>`` must be greater than zero and divisible by sizeof(int8);
 * - :math:`<dst\_stride> \div sizeof(int8) \ge <src\_count>`;
 * - ``<src_stride>`` must be greater than or equal to zero, and divisible by sizeof(half);
 * - :math:`<src\_stride> \div sizeof(half) \ge <src\_count>` if ``<src_stride>`` is greater than zero;
 * - ``<segnum>`` must be greater than or equal to zero;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SRC_STRIDE 160
 *   #define DST_STRIDE 320
 *   #define LEN 128
 *   #define SEG_NUM 20
 *   #define POS 5
 *
 *   __mlu_entry__ void kernel(int8 *dst, half *src, int size) {
 *     __nram__ half src_tmp[SRC_STRIDE * SEG_NUM + LEN];
 *     __nram__ int8 dst_tmp[DST_STRIDE / sizeof(int8) * SEG_NUM + LEN];
 *     __memcpy(src_tmp, src, size, GDRAM2NRAM);
 *     __bang_half2int8_dn(dst_tmp, src_tmp, LEN, POS, DST_STRIDE, SRC_STRIDE, SEG_NUM);
 *     __memcpy(dst, dst_tmp, (DST_STRIDE * SEG_NUM + LEN * sizeof(half)), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_half2int8_dn(int8* dst,
                                                             half* src,
                                                             int src_count,
                                                             int fix_position,
                                                             int dst_stride,
                                                             int src_stride,
                                                             int segnum);

//Group:Stream Type Conversion Functions
static __mlu_func__ __mlu_builtin__ void __bang_half2int8_tz(int8* dst,
                                                             half* src,
                                                             int src_count,
                                                             int fix_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-to-zero mode.
 *
 * @details The function converts type of ``<src>`` from half to int8 element-wisely in round-to-zero mode and saves the result in ``<dst>``.
 * \rst
 * The data type conversion process is illustrated by Figure :ref:`convert_with_stride`. ``<src>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<src_stride>`` bytes. ``<dst>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<dst_stride>`` bytes. In each block of ``<src>``, this function converts first ``<src_count>`` elements according to ``<fix_position>`` in round-to-zero mode, and saves the result in blocks in ``<dst>`` sequentially. If ``<src_stride>`` is zero, this function only converts the first block ``<segnum> + 1`` times.
 * \endrst
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 * @param[in] dst_stride Destination address stride in bytes.
 * @param[in] src_stride Source address stride in bytes.
 * @param[in] segnum Section number.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and be divisible by 128 on ``(m)tp_2xx``;
 * - ``<fix_position>`` must be in the range ``[-127,127]``;
 * - ``<dst_stride>`` must be greater than zero and divisible by sizeof(int8);
 * - :math:`<dst\_stride> \div sizeof(int8) \ge <src\_count>`;
 * - ``<src_stride>`` must be greater than or equal to zero, and divisible by sizeof(half);
 * - :math:`<src\_stride> \div sizeof(half) \ge <src\_count>` if ``<src_stride>`` is greater than zero;
 * - ``<segnum>`` must be greater than or equal to zero;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * @par
 * See the example of ::__bang_half2int8_dn for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_half2int8_tz(int8* dst,
                                                             half* src,
                                                             int src_count,
                                                             int fix_position,
                                                             int dst_stride,
                                                             int src_stride,
                                                             int segnum);

//Group:Stream Type Conversion Functions
static __mlu_func__ __mlu_builtin__ void __bang_half2int8_oz(int8* dst,
                                                             half* src,
                                                             int src_count,
                                                             int fix_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from half to int8 element-wisely in round-off-zero mode and saves the result in ``<dst>``.
 * \rst
 * The data type conversion process is illustrated by Figure :ref:`convert_with_stride`. ``<src>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<src_stride>`` bytes. ``<dst>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<dst_stride>`` bytes. In each block of ``<src>``, this function converts first ``<src_count>`` elements according to ``<fix_position>`` in round-off-zero mode, and saves the result in blocks in ``<dst>`` sequentially. If ``<src_stride>`` is zero, this function only converts the first block ``<segnum> + 1`` times.
 * \endrst
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 * @param[in] dst_stride Destination address stride in bytes.
 * @param[in] src_stride Source address stride in bytes.
 * @param[in] segnum Section number.
 *
 * @return ``void`.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and divisible by 128 on ``(m)tp_2xx``;
 * - ``<fix_position>`` must be in the range ``[-127,127]``;
 * - ``<src_stride>`` must be greater than or equal to zero, and divisible by sizeof(in8);
 * - :math:`<dst\_stride> \div sizeof(int8) \ge <src\_count>`;
 * - ``<src_stride>`` must be greater than or equal to zero, and divisible by sizeof(half);
 * - :math:`<src\_stride> \div sizeof(half) \ge <src\_count>` if ``<src_stride>`` is greater than zero;
 * - ``<segnum>`` must be greater than or equal to zero;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * @par
 * See the example of ::__bang_half2int8_dn for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_half2int8_oz(int8* dst,
                                                             half* src,
                                                             int src_count,
                                                             int fix_position,
                                                             int dst_stride,
                                                             int src_stride,
                                                             int segnum);

//Group:Stream Type Conversion Functions
static __mlu_func__ __mlu_builtin__ void __bang_half2int8_up(int8* dst,
                                                             half* src,
                                                             int src_count,
                                                             int fix_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-up mode.
 *
 * @details The function converts type of ``<src>`` from half to int8 element-wisely in round-up mode and saves the result in ``<dst>``.
 * \rst
 * The data type conversion process is illustrated by Figure :ref:`convert_with_stride`. ``<src>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<src_stride>`` bytes. ``<dst>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<dst_stride>`` bytes. In each block of ``<src>``, this function converts first ``<src_count>`` elements according to ``<fix_position>`` in round-up mode, and saves the result in blocks in ``<dst>`` sequentially. If ``<src_stride>`` is zero, this function only converts the first block ``<segnum> + 1`` times.
 * \endrst
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 * @param[in] dst_stride Destination address stride in bytes.
 * @param[in] src_stride Source address stride in bytes.
 * @param[in] segnum Section number.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and divisible by 128 on ``(m)tp_2xx``;
 * - ``<fix_position>`` must be in the range ``[-127,127]``;
 * - ``<dst_stride>`` must be greater than zero and divisible by sizeof(int8);
 * - :math:`<dst\_stride> \div sizeof(int8) \ge <src\_count>`;
 * - ``<src_stride>`` must be greater than or equal to zero, and divisible by sizeof(half);
 * - :math:`<src\_stride> \div sizeof(half) \ge <src\_count>` if ``<src_stride>`` is greater than zero;
 * - ``<segnum>`` must be greater than or equal to zero;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * @par
 * See the example of ::__bang_half2int8_dn for more details.
 */
static __mlu_func__ __mlu_builtin__ void __bang_half2int8_up(int8* dst,
                                                             half* src,
                                                             int src_count,
                                                             int fix_position,
                                                             int dst_stride,
                                                             int src_stride,
                                                             int segnum);

//Group:Stream Type Conversion Functions
static __mlu_func__ __mlu_builtin__ void __bang_half2int8_rd(int8* dst,
                                                             half* src,
                                                             int src_count,
                                                             int fix_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from half to int8 element-wisely in round-nearest-off-zero mode and saves the result in ``<dst>``.
 * \rst
 * The data type conversion process is illustrated by Figure :ref:`convert_with_stride`. ``<src>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<src_stride>`` bytes. ``<dst>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<dst_stride>`` bytes. In each block of ``<src>``, this function converts first ``<src_count>`` elements according to ``<fix_position>`` in round-nearest-off-zero mode, and saves the result in blocks in ``<dst>`` sequentially. If ``<src_stride>`` is zero, this function only converts the first block ``<segnum> + 1`` times.
 * \endrst
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 * @param[in] dst_stride Destination address stride in bytes.
 * @param[in] src_stride Source address stride in bytes.
 * @param[in] segnum Section number.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on (m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and divisible by 128 on ``(m)tp_2xx``;
 * - ``<fix_position>`` must be in the range ``[-127,127]``;
 * - ``<dst_stride>`` must be greater than zero and divisible by sizeof(int8);
 * - :math:`<dst\_stride> \div sizeof(int8) \ge <src\_count>`;
 * - ``<src_stride>`` must be greater than or equal to zero, and divisible by sizeof(half);
 * - :math:`<src\_stride> \div sizeof(half) \ge <src\_count>` if ``<src_stride>`` is greater than zero;
 * - ``<segnum>`` must be greater than or equal to zero;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * @par
 * See the example of ::__bang_half2int8_dn for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_half2int8_rd(int8* dst,
                                                             half* src,
                                                             int src_count,
                                                             int fix_position,
                                                             int dst_stride,
                                                             int src_stride,
                                                             int segnum);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-math mode.
 *
 * @details The function converts type of ``<src>`` from half to int8 element-wisely in round-math mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<fix_position>`` must be in the range ``[-127,127]``;
 * - ``<src_count>`` must be greater than zero;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @par
 * See the example of ::__bang_half2int8_dn for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_half2int8_rm(int8* dst,
                                                             half* src,
                                                             int src_count,
                                                             int fix_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-nearest-even mode.
 *
 * @details The function converts type of ``<src>`` from half to int8 element-wisely in round-nearest-even mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<fix_position>`` must be in the range ``[-127,127]``;
 * - ``<src_count>`` must be greater than zero;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @par
 * See the example of ::__bang_half2int8_dn for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_half2int8_rn(int8* dst,
                                                             half* src,
                                                             int src_count,
                                                             int fix_position);

//Group:Stream Type Conversion Functions
static __mlu_func__ __mlu_builtin__ void __bang_half2uchar_dn(unsigned char* dst,
                                                              half* src,
                                                              int src_count);

//Group:Stream Type Conversion Functions
static __mlu_func__ __mlu_builtin__ void __bang_half2uchar_dn(signed char* dst,
                                                              half* src,
                                                              int src_count);
//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-down mode.
 *
 * @details The function converts type of ``<src>`` from half to unsigned char element-wisely in round-down mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_addition The address of additional vector for source.
 * @param[in] src_count The number of elements.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` , ``<dst>`` and ``<src_addition>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The difference between two version is that the version without ``<src_addition>`` can convert data in the range of ``[0,127]``, the version with ``<src_addition>`` can convert data in the range of ``[0,255]``;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(unsigned char *dst, half *src) {
 *     __nram__ half src_tmp[SIZE];
 *     __nram__ half src_addition[SIZE];
 *     __nram__ unsigned char dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(half), GDRAM2NRAM);
 *     __bang_half2uchar_dn(dst_tmp, src_tmp, src_addition, SIZE);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(unsigned char), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_half2uchar_dn(unsigned char* dst,
                                                              half* src,
                                                              half* src_addition,
                                                              int src_count);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-down mode.
 *
 * @details The function converts type of ``<src>`` from half to signed char element-wisely in round-down mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(signed char *dst, half *src) {
 *     __nram__ half src_tmp[SIZE];
 *     __nram__ signed char dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(half), GDRAM2NRAM);
 *     __bang_half2char_dn(dst_tmp, src_tmp, SIZE);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(signed char), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_half2char_dn(signed char* dst,
                                                             half* src,
                                                             int src_count);

//Group:Stream Type Conversion Functions
static __mlu_func__ __mlu_builtin__ void __bang_half2short_dn(short* dst,
                                                              half* src,
                                                              int src_count);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-down mode.
 *
 * @details The function converts type of ``<src>`` from half to short element-wisely in round-down mode and saves the result in ``<dst>``.
 * \rst
 * The data type conversion process is illustrated by Figure :ref:`convert_with_stride`. ``<src>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<src_stride>`` bytes. ``<dst>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<dst_stride>`` bytes. In each block of ``<src>``, this function converts first ``<src_count>`` elements in round-down mode, and saves the result in blocks in ``<dst>`` sequentially. If ``<src_stride>`` is zero, this function only converts the first block ``<segnum> + 1`` times.
 * \endrst
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] dst_stride Destination address stride in bytes.
 * @param[in] src_stride Source address stride in bytes.
 * @param[in] segnum Section number.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and divisible by 64 on ``(m)tp_2xx``;
 * - ``<dst_stride>`` must be greater than zero and divisible by sizeof(short);
 * - :math:`<dst\_stride> \div sizeof(short) \ge <src\_count>`;
 * - ``<src_stride>`` must be greater than or equal to zero, and divisible by sizeof(half);
 * - :math:`<src\_stride> \div sizeof(half) \ge <src\_count>` if ``<src_stride>`` is greater than zero;
 * - ``<segnum>`` must be greater than or equal to zero;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SRC_STRIDE 160
 *   #define DST_STRIDE 320
 *   #define LEN 128
 *   #define SEG_NUM 20
 *
 *   __mlu_entry__ void kernel(short *dst, half *src, int size) {
 *     __nram__ half src_tmp[SRC_STRIDE * SEG_NUM + LEN];
 *     __nram__ short dst_tmp[DST_STRIDE / sizeof(short) * SEG_NUM + LEN];
 *     __memcpy(src_tmp, src, size * sizeof(half), GDRAM2NRAM);
 *     __bang_half2short_dn(dst_tmp, src_tmp, LEN, DST_STRIDE, SRC_STRIDE, SEG_NUM);
 *     __memcpy(dst, dst_tmp, (DST_STRIDE * SEG_NUM + LEN * sizeof(short)), NRAM2GDRAM);
 *   }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_half2short_dn(short* dst,
                                                              half* src,
                                                              int src_count,
                                                              int dst_stride,
                                                              int src_stride,
                                                              int segnum);

//Group:Stream Type Conversion Functions
static __mlu_func__ __mlu_builtin__ void __bang_half2short_tz(short* dst,
                                                              half* src,
                                                              int src_count);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-to-zero mode.
 *
 * @details The function converts type of ``<src>`` from half to short element-wisely in round-to-zero mode and saves the result in ``<dst>``.
 * \rst
 * The data type conversion process is illustrated by Figure :ref:`convert_with_stride`. ``<src>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<src_stride>`` bytes. ``<dst>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<dst_stride>`` bytes. In each block of ``<src>``, this function converts first ``<src_count>`` elements in round-to-zero mode, and saves the result in blocks in ``<dst>`` sequentially. If ``<src_stride>`` is zero, this function only converts the first block ``<segnum> + 1`` times.
 * \endrst
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] dst_stride Destination address stride in bytes.
 * @param[in] src_stride Source address stride in bytes.
 * @param[in] segnum Section number.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and divisible by 64 on ``(m)tp_2xx``;
 * - ``<dst_stride>`` must be greater than zero and divisible by sizeof(short);
 * - :math:`<dst\_stride> \div sizeof(short) \ge <src\_count>`;
 * - ``<src_stride>`` must be greater than or equal to zero, and divisible by sizeof(half);
 * - :math:`<src\_stride> \div sizeof(half) \ge <src\_count>` if ``<src_stride>`` is greater than zero;
 * - ``<segnum>`` must be greater than or equal to zero;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * @par
 * See the example of ::__bang_half2short_dn for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_half2short_tz(short* dst,
                                                              half* src,
                                                              int src_count,
                                                              int dst_stride,
                                                              int src_stride,
                                                              int segnum);

//Group:Stream Type Conversion Functions
static __mlu_func__ __mlu_builtin__ void __bang_half2short_oz(short* dst,
                                                              half* src,
                                                              int src_count);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from half to short element-wisely in round-off-zero mode and saves the result in ``<dst>``.
 * \rst
 * The data type conversion process is illustrated by Figure :ref:`convert_with_stride`. ``<src>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<src_stride>`` bytes. ``<dst>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<dst_stride>`` bytes. In each block of ``<src>``, this function converts first ``<src_count>`` elements in round-off-zero mode, and saves the result in blocks in ``<dst>`` sequentially. If ``<src_stride>`` is zero, this function only converts the first block ``<segnum> + 1`` times.
 * \endrst
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] dst_stride Destination address stride in bytes.
 * @param[in] src_stride Source address stride in bytes.
 * @param[in] segnum Section number.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and divisible by 64 on ``(m)tp_2xx``;
 * - ``<dst_stride>`` must be greater than zero and divisible by sizeof(short);
 * - :math:`<dst\_stride> \div sizeof(short) \ge <src\_count>`;
 * - ``<src_stride>`` must be greater than or equal to zero, and divisible by sizeof(half);
 * - :math:`<src\_stride> \div sizeof(half) \ge <src\_count>` if ``<src_stride>`` is greater than zero;
 * - ``<segnum>`` must be greater than or equal to zero;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * @par
 * See the example of ::__bang_half2short_dn for more details.
 */
static __mlu_func__ __mlu_builtin__ void __bang_half2short_oz(short* dst,
                                                              half* src,
                                                              int src_count,
                                                              int dst_stride,
                                                              int src_stride,
                                                              int segnum);

//Group:Stream Type Conversion Functions
static __mlu_func__ __mlu_builtin__ void __bang_half2short_up(short* dst,
                                                              half* src,
                                                              int src_count);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-up mode.
 *
 * @details The function converts type of ``<src>`` from half to short element-wisely in round-up mode and saves the result in ``<dst>``.
 * \rst
 * The data type conversion process is illustrated by Figure :ref:`convert_with_stride`. ``<src>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<src_stride>`` bytes. ``<dst>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<dst_stride>`` bytes. In each block of ``<src>``, this function converts first ``<src_count>`` elements in round-up mode, and saves the result in blocks in ``<dst>`` sequentially. If ``<src_stride>`` is zero, this function only converts the first block ``<segnum> + 1`` times.
 * \endrst
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] dst_stride Destination address stride in bytes.
 * @param[in] src_stride Source address stride in bytes.
 * @param[in] segnum Section number.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and divisible by 64 on ``(m)tp_2xx``;
 * - ``<dst_stride>`` must be greater than zero and divisible by sizeof(short);
 * - :math:`<dst\_stride> \div sizeof(short) \ge <src\_count>`;
 * - ``<src_stride>`` must be greater than or equal to zero, and divisible by sizeof(half);
 * - :math:`<src\_stride> \div sizeof(half) \ge <src\_count>` if ``<src_stride>`` is greater than zero;
 * - ``<segnum>`` must be greater than or equal to zero;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * @par
 * See the example of ::__bang_half2short_dn for more details.
 */
static __mlu_func__ __mlu_builtin__ void __bang_half2short_up(short* dst,
                                                              half* src,
                                                              int src_count,
                                                              int dst_stride,
                                                              int src_stride,
                                                              int segnum);

//Group:Stream Type Conversion Functions
static __mlu_func__ __mlu_builtin__ void __bang_half2short_rd(short* dst,
                                                              half* src,
                                                              int src_count);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from half to short element-wisely in round-nearest-off-zero mode and saves the result in ``<dst>``.
 * \rst
 * The data type conversion process is illustrated by Figure :ref:`convert_with_stride`. ``<src>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<src_stride>`` bytes. ``<dst>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<dst_stride>`` bytes. In each block of ``<src>``, this function converts first ``<src_count>`` elements in round-nearest-off-zero mode, and saves the result in blocks in ``<dst>`` sequentially. If ``<src_stride>`` is zero, this function only converts the first block ``<segnum> + 1`` times.
 * \endrst
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] dst_stride Destination address stride in bytes.
 * @param[in] src_stride Source address stride in bytes.
 * @param[in] segnum Section number.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and divisible by 64 on ``(m)tp_2xx``;
 * - ``<dst_stride>`` must be greater than zero and divisible by sizeof(short);
 * - :math:`<dst\_stride> \div sizeof(short) \ge <src\_count>`;
 * - ``<src_stride>`` must be greater than or equal to zero, and divisible by sizeof(half);
 * - :math:`<src\_stride> \div sizeof(half) \ge <src\_count>` if ``<src_stride>`` is greater than zero;
 * - ``<segnum>`` must be greater than or equal to zero;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * @par
 * See the example of ::__bang_half2short_dn for more details.
 */
static __mlu_func__ __mlu_builtin__ void __bang_half2short_rd(short* dst,
                                                              half* src,
                                                              int src_count,
                                                              int dst_stride,
                                                              int src_stride,
                                                              int segnum);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-math mode.
 *
 * @details The function converts type of ``<src>`` from half to short element-wisely in round-math mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The elements number of conversion.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<src_count>`` must be greater than zero;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(short *dst, half *src) {
 *     __nram__ half src_tmp[SIZE];
 *     __nram__ short dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(half), GDRAM2NRAM);
 *     __bang_half2short_rm(dst_tmp, src_tmp, SIZE);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(short), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_half2short_rm(short* dst,
                                                              half* src,
                                                              int src_count);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-nearest-even mode.
 *
 * @details The function converts type of ``<src>`` from half to short element-wisely in round-nearest-even mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The elements number of conversion.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<src_count>`` must be greater than zero;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_integer` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @par
 * See the example of ::__bang_half2short_rm for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_half2short_rn(short* dst,
                                                              half* src,
                                                              int src_count);

//Group:Stream Type Conversion Functions
static __mlu_func__ __mlu_builtin__ void __bang_half2float(float* dst,
                                                           half* src,
                                                           int src_count);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-to-zero mode.
 *
 * @details The function converts type of ``<src>`` from half to float element-wisely in round-to-zero mode and saves the result in ``<dst>``.
 * \rst
 * The data type conversion process is illustrated by Figure :ref:`convert_with_stride`. ``<src>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<src_stride>`` bytes. ``<dst>`` includes ``<segnum> + 1`` blocks, and each block consists of ``<dst_stride>`` bytes. In each block of ``<src>``, this function converts first ``<src_count>`` elements in round-to-zero mode, and saves the result in blocks in ``<dst>`` sequentially. If ``<src_stride>`` is zero, this function only converts the first block ``<segnum> + 1`` times.
 * \endrst
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] dst_stride Destination address stride in bytes.
 * @param[in] src_stride Source address stride in bytes.
 * @param[in] segnum Section number.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src_count>`` must be greater than zero and divisible by 64 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst_stride>`` and ``<src_stride>`` must be divisible by 64 on ``(m)tp_1xx``;
 * - ``<dst_stride>`` must be greater than zero and divisible by sizeof(float);
 * - :math:`<dst\_stride> \div sizeof(float) \ge <src\_count>`;
 * - ``<src_stride>`` must be greater than or equal to zero, and divisible by sizeof(half);
 * - :math:`<src\_stride> \div sizeof(half) \ge <src\_count>` if ``<src_stride>`` is greater than zero;
 * - ``<segnum>`` must be greater than or equal to zero;
 * - ``<src>`` and ``<dst>`` can not be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_type_conversion_from_floating_point_to_floating_point` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SRC_STRIDE 160
 *   #define DST_STRIDE 512
 *   #define LEN 128
 *   #define SEG_NUM 20
 *
 *   __mlu_entry__ void kernel(float *dst, half *src, int size) {
 *     __nram__ half src_tmp[SRC_STRIDE * SEG_NUM + LEN];
 *     __nram__ float dst_tmp[DST_STRIDE / sizeof(float) * SEG_NUM + LEN];
 *     __memcpy(src_tmp, src, size * sizeof(half), GDRAM2NRAM);
 *     __bang_half2float(dst_tmp, src_tmp, LEN, DST_STRIDE, SRC_STRIDE, SEG_NUM);
 *     __memcpy(dst, dst_tmp, (DST_STRIDE * SEG_NUM + LEN * sizeof(float)), NRAM2GDRAM);
 *   }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_half2float(float* dst,
                                                           half* src,
                                                           int src_count,
                                                           int dst_stride,
                                                           int src_stride,
                                                           int segnum);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-to-zero mode.
 *
 * @details The function converts type of ``<src>`` from half to signed char element-wisely in round-to-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_count>`` must be greater than zero.
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *   #define DST_POS 3
 *   #define SRC_POS 5
 *
 *   __mlu_entry__ void kernel(signed char *dst, short *src) {
 *     __nram__ short src_tmp[SIZE];
 *     __nram__ signed char dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(short), GDRAM2NRAM);
 *     __bang_short2char(dst_tmp, src_tmp, SIZE, DST_POS, SRC_POS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(signed char), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_short2char(signed char* dst,
                                                           short* src,
                                                           int src_count,
                                                           int dst_position,
                                                           int src_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-to-zero mode.
 *
 * @details The function converts type of ``<src>`` from int to signed char element-wisely round-to-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_count>`` must be greater than zero.
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *   #define DST_POS 3
 *   #define SRC_POS 5
 *
 *   __mlu_entry__ void kernel(signed char *dst, int *src) {
 *     __nram__ int src_tmp[SIZE];
 *     __nram__ signed char dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int), GDRAM2NRAM);
 *     __bang_short2char(dst_tmp, src_tmp, SIZE, DST_POS, SRC_POS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(signed char), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int2char(signed char* dst,
                                                         int* src,
                                                         int src_count,
                                                         int dst_position,
                                                         int src_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-to-zero mode.
 *
 * @details The function converts type of ``<src>`` from signed char to short element-wisely in round-to-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``;
 * - ``<src>`` and ``<dst>`` can not be homologous operands;
 * - ``<src_count>`` must be greater than zero.
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *   #define DST_POS 3
 *   #define SRC_POS 5
 *
 *   __mlu_entry__ void kernel(short *dst, signed char *src) {
 *     __nram__ signed char src_tmp[SIZE];
 *     __nram__ short dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(signed char), GDRAM2NRAM);
 *     __bang_char2short(dst_tmp, src_tmp, SIZE, DST_POS, SRC_POS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(short), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_char2short(short* dst,
                                                           signed char* src,
                                                           int src_count,
                                                           int dst_position,
                                                           int src_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-to-zero mode.
 *
 * @details The function converts type of ``<src>`` from int to short element-wisely in round-to-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_count>`` must be greater than zero.
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *   #define DST_POS 3
 *   #define SRC_POS 5
 *
 *   __mlu_entry__ void kernel(short *dst, int *src) {
 *     __nram__ int src_tmp[SIZE];
 *     __nram__ short dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int), GDRAM2NRAM);
 *     __bang_int2short(dst_tmp, src_tmp, SIZE, DST_POS, SRC_POS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(short), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int2short(short* dst,
                                                          int* src,
                                                          int src_count,
                                                          int dst_position,
                                                          int src_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-to-zero mode.
 *
 * @details The function converts type of ``<src>`` from signed char to int element-wisely in round-to-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``;
 * - ``<src>`` and ``<dst>`` can not be homologous operands;
 * - ``<src_count>`` must be greater than zero.
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *   #define DST_POS 3
 *   #define SRC_POS 5
 *
 *   __mlu_entry__ void kernel(int *dst, signed char *src) {
 *     __nram__ signed char src_tmp[SIZE];
 *     __nram__ int dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(signed char), GDRAM2NRAM);
 *     __bang_char2int(dst_tmp, src_tmp, SIZE, DST_POS, SRC_POS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_char2int(int* dst,
                                                         signed char* src,
                                                         int src_count,
                                                         int dst_position,
                                                         int src_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-to-zero mode.
 *
 * @details The function converts type of ``<src>`` from ``float`` to ``int4`` element-wisely in round-to-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, float *src) {
 *     __nram__ float src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);
 *     __bang_float2int4_tz(dst_tmp, src_tmp, SIZE, POS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2int4_tz(int4x2_t* dst,
                                                              float* src,
                                                              int size,
                                                              int dst_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from ``float`` to ``int4`` element-wisely in round-off-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, float *src) {
 *     __nram__ float src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);
 *     __bang_float2int4_oz(dst_tmp, src_tmp, SIZE, POS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2int4_oz(int4x2_t* dst,
                                                              float* src,
                                                              int size,
                                                              int dst_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-up mode.
 *
 * @details The function converts type of ``<src>`` from ``float`` to ``int4`` element-wisely in round-up mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, float *src) {
 *     __nram__ float src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);
 *     __bang_float2int4_up(dst_tmp, src_tmp, SIZE, POS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2int4_up(int4x2_t* dst,
                                                              float* src,
                                                              int size,
                                                              int dst_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-down mode.
 *
 * @details The function converts type of ``<src>`` from ``float`` to ``int4`` element-wisely in round-down mode. and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, float *src) {
 *     __nram__ float src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);
 *     __bang_float2int4_dn(dst_tmp, src_tmp, SIZE, POS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2int4_dn(int4x2_t* dst,
                                                              float* src,
                                                              int size,
                                                              int dst_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from ``float`` to ``int4`` element-wisely in round-nearest-off-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, float *src) {
 *     __nram__ float src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);
 *     __bang_float2int4_rd(dst_tmp, src_tmp, SIZE, POS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2int4_rd(int4x2_t* dst,
                                                              float* src,
                                                              int size,
                                                              int dst_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-nearest-even mode.
 *
 * @details The function converts type of ``<src>`` from ``float`` to ``int4`` element-wisely in round-nearest-even mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, float *src) {
 *     __nram__ float src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);
 *     __bang_float2int4_rn(dst_tmp, src_tmp, SIZE, POS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2int4_rn(int4x2_t* dst,
                                                              float* src,
                                                              int size,
                                                              int dst_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-math mode.
 *
 * @details The function converts type of ``<src>`` from ``float`` to ``int4`` element-wisely in round-math mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, float *src) {
 *     __nram__ float src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);
 *     __bang_float2int4_rm(dst_tmp, src_tmp, SIZE, POS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_float2int4_rm(int4x2_t* dst,
                                                              float* src,
                                                              int size,
                                                              int dst_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-to-zero mode.
 *
 * @details The function converts type of ``<src>`` from ``half`` to ``int4`` element-wisely in round-to-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, half *src) {
 *     __nram__ half src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(half), GDRAM2NRAM);
 *     __bang_half2int4_tz(dst_tmp, src_tmp, SIZE, POS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_half2int4_tz(int4x2_t* dst,
                                                             half* src,
                                                             int size,
                                                             int dst_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from ``half`` to ``int4`` element-wisely in in round-off-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, half *src) {
 *     __nram__ half src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(half), GDRAM2NRAM);
 *     __bang_half2int4_oz(dst_tmp, src_tmp, SIZE, POS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_half2int4_oz(int4x2_t* dst,
                                                             half* src,
                                                             int size,
                                                             int dst_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-up mode.
 *
 * @details The function converts type of ``<src>`` from ``half`` to ``int4`` element-wisely in round-up mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, half *src) {
 *     __nram__ half src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(half), GDRAM2NRAM);
 *     __bang_half2int4_up(dst_tmp, src_tmp, SIZE, POS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_half2int4_up(int4x2_t* dst,
                                                             half* src,
                                                             int size,
                                                             int dst_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-down mode.
 *
 * @details The function converts type of ``<src>`` from ``half`` to ``int4`` element-wisely in round-down mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, half *src) {
 *     __nram__ half src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(half), GDRAM2NRAM);
 *     __bang_half2int4_dn(dst_tmp, src_tmp, SIZE, POS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_half2int4_dn(int4x2_t* dst,
                                                             half* src,
                                                             int size,
                                                             int dst_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from ``half`` to ``int4`` element-wisely in round-nearest-off-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, float *src) {
 *     __nram__ float src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(float), GDRAM2NRAM);
 *     __bang_float2int4_tz(dst_tmp, src_tmp, SIZE, POS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_half2int4_rd(int4x2_t* dst,
                                                             half* src,
                                                             int size,
                                                             int dst_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-nearest-even mode.
 *
 * @details The function converts type of ``<src>`` from ``half`` to ``int4`` element-wisely in round-nearest-even mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, half *src) {
 *     __nram__ half src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(half), GDRAM2NRAM);
 *     __bang_half2int4_rn(dst_tmp, src_tmp, SIZE, POS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_half2int4_rn(int4x2_t* dst,
                                                             half* src,
                                                             int size,
                                                             int dst_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-math mode.
 *
 * @details The function converts type of ``<src>`` from ``half`` to ``int4`` element-wisely in round-math mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, half *src) {
 *     __nram__ half src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(half), GDRAM2NRAM);
 *     __bang_half2int4_rm(dst_tmp, src_tmp, SIZE, POS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_half2int4_rm(int4x2_t* dst,
                                                             half* src,
                                                             int size,
                                                             int dst_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-to-zero mode.
 *
 * @details The function converts type of ``<src>`` from ``bfloat16_t`` to ``int4`` element-wisely in round-to-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, bfloat16_t *src) {
 *     __nram__ bfloat16_t src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(bfloat16_t), GDRAM2NRAM);
 *     __bang_bfloat162int4_tz(dst_tmp, src_tmp, SIZE, POS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_bfloat162int4_tz(int4x2_t* dst,
                                                                 bfloat16_t* src,
                                                                 int size,
                                                                 int dst_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from ``bfloat16_t`` to ``int4`` element-wisely in round-off-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, bfloat16_t *src) {
 *     __nram__ bfloat16_t src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(bfloat16_t), GDRAM2NRAM);
 *     __bang_bfloat162int4_oz(dst_tmp, src_tmp, SIZE, POS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_bfloat162int4_oz(int4x2_t* dst,
                                                                 bfloat16_t* src,
                                                                 int size,
                                                                 int dst_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-up mode.
 *
 * @details The function converts type of ``<src>`` from ``bfloat16_t`` to ``int4`` element-wisely in round-up mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, bfloat16_t *src) {
 *     __nram__ bfloat16_t src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(bfloat16_t), GDRAM2NRAM);
 *     __bang_bfloat162int4_up(dst_tmp, src_tmp, SIZE, POS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_bfloat162int4_up(int4x2_t* dst,
                                                                 bfloat16_t* src,
                                                                 int size,
                                                                 int dst_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-down mode.
 *
 * @details The function converts type of ``<src>`` from ``bfloat16_t`` to ``int4`` element-wisely in round-down mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, bfloat16_t *src) {
 *     __nram__ bfloat16_t src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(bfloat16_t), GDRAM2NRAM);
 *     __bang_bfloat162int4_dn(dst_tmp, src_tmp, SIZE, POS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_bfloat162int4_dn(int4x2_t* dst,
                                                                 bfloat16_t* src,
                                                                 int size,
                                                                 int dst_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from ``bfloat16_t`` to ``int4`` element-wisely in round-nearest-off-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, bfloat16_t *src) {
 *     __nram__ bfloat16_t src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(bfloat16_t), GDRAM2NRAM);
 *     __bang_bfloat162int4_rd(dst_tmp, src_tmp, SIZE, POS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_bfloat162int4_rd(int4x2_t* dst,
                                                                 bfloat16_t* src,
                                                                 int size,
                                                                 int dst_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-math mode.
 *
 * @details The function converts type of ``<src>`` from ``bfloat16_t`` to ``int4`` element-wisely in round-math mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, bfloat16_t *src) {
 *     __nram__ bfloat16_t src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(bfloat16_t), GDRAM2NRAM);
 *     __bang_bfloat162int4_rm(dst_tmp, src_tmp, SIZE, POS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_bfloat162int4_rm(int4x2_t* dst,
                                                                 bfloat16_t* src,
                                                                 int size,
                                                                 int dst_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-nearest-even mode.
 *
 * @details The function converts type of ``<src>`` from ``bfloat16_t`` to ``int4`` element-wisely in round-nearest-even mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, bfloat16_t *src) {
 *     __nram__ bfloat16_t src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(bfloat16_t), GDRAM2NRAM);
 *     __bang_bfloat162int4_rn(dst_tmp, src_tmp, SIZE, POS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_bfloat162int4_rn(int4x2_t* dst,
                                                                 bfloat16_t* src,
                                                                 int size,
                                                                 int dst_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-to-zero mode.
 *
 * @details The function converts type of ``<src>`` from ``char`` to ``int4`` element-wisely in round-to-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, char *src) {
 *     __nram__ char src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(char), GDRAM2NRAM);
 *     __bang_int82int4_tz(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int82int4_tz(int4x2_t* dst,
                                                             char* src,
                                                             int size,
                                                             int dst_position,
                                                             int src_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from ``char`` to ``int4`` element-wisely in round-off-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, char *src) {
 *     __nram__ char src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(char), GDRAM2NRAM);
 *     __bang_int82int4_oz(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int82int4_oz(int4x2_t* dst,
                                                             char* src,
                                                             int size,
                                                             int dst_position,
                                                             int src_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-up mode.
 *
 * @details The function converts type of ``<src>`` from ``char`` to ``int4`` element-wisely in round-up mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, char *src) {
 *     __nram__ char src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(char), GDRAM2NRAM);
 *     __bang_int82int4_up(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int82int4_up(int4x2_t* dst,
                                                             char* src,
                                                             int size,
                                                             int dst_position,
                                                             int src_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-down mode.
 *
 * @details The function converts type of ``<src>`` from ``char`` to ``int4`` element-wisely in round-down mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, char *src) {
 *     __nram__ char src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(char), GDRAM2NRAM);
 *     __bang_int82int4_dn(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int82int4_dn(int4x2_t* dst,
                                                             char* src,
                                                             int size,
                                                             int dst_position,
                                                             int src_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from ``char`` to ``int4`` element-wisely in round-nearest-off-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, char *src) {
 *     __nram__ char src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(char), GDRAM2NRAM);
 *     __bang_int82int4_rd(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int82int4_rd(int4x2_t* dst,
                                                             char* src,
                                                             int size,
                                                             int dst_position,
                                                             int src_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-math mode.
 *
 * @details The function converts type of ``<src>`` from ``char`` to ``int4`` element-wisely in round-math mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, char *src) {
 *     __nram__ char src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(char), GDRAM2NRAM);
 *     __bang_int82int4_rm(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int82int4_rm(int4x2_t* dst,
                                                             char* src,
                                                             int size,
                                                             int dst_position,
                                                             int src_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-nearest-even mode.
 *
 * @details The function converts type of ``<src>`` from ``char`` to ``int4`` element-wisely in round-nearest-even mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, char *src) {
 *     __nram__ char src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(char), GDRAM2NRAM);
 *     __bang_int82int4_rn(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int82int4_rn(int4x2_t* dst,
                                                             char* src,
                                                             int size,
                                                             int dst_position,
                                                             int src_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-to-zero mode.
 *
 * @details The function converts type of ``<src>`` from ``short`` to ``int4`` element-wisely in round-to-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, short *src) {
 *     __nram__ short src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(short), GDRAM2NRAM);
 *     __bang_int162int4_tz(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int162int4_tz(int4x2_t* dst,
                                                              short* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from ``short`` to ``int4`` element-wisely in round-off-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, short *src) {
 *     __nram__ short src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(short), GDRAM2NRAM);
 *     __bang_int162int4_oz(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int162int4_oz(int4x2_t* dst,
                                                              short* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-up mode.
 *
 * @details The function converts type of ``<src>`` from ``short`` to ``int4`` element-wisely in round-up mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, short *src) {
 *     __nram__ short src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(short), GDRAM2NRAM);
 *     __bang_int162int4_up(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int162int4_up(int4x2_t* dst,
                                                              short* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-down mode.
 *
 * @details The function converts type of ``<src>`` from ``short`` to ``int4`` element-wisely in round-down mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, short *src) {
 *     __nram__ short src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(short), GDRAM2NRAM);
 *     __bang_int162int4_dn(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int162int4_dn(int4x2_t* dst,
                                                              short* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from ``short`` to ``int4`` element-wisely in round-nearest-off-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, short *src) {
 *     __nram__ short src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(short), GDRAM2NRAM);
 *     __bang_int162int4_rd(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int162int4_rd(int4x2_t* dst,
                                                              short* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-math mode.
 *
 * @details The function converts type of ``<src>`` from ``short`` to ``int4`` element-wisely in round-math mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, short *src) {
 *     __nram__ short src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(short), GDRAM2NRAM);
 *     __bang_int162int4_rm(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int162int4_rm(int4x2_t* dst,
                                                              short* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-nearest-even mode.
 *
 * @details The function converts type of ``<src>`` from ``short`` to ``int4`` element-wisely in round-nearest-even mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, short *src) {
 *     __nram__ short src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(short), GDRAM2NRAM);
 *     __bang_int162int4_rn(dst_tmp, src_tmp, SIZE);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int162int4_rn(int4x2_t* dst,
                                                              short* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-to-zero mode.
 *
 * @details The function converts type of ``<src>`` from ``int`` to ``int4`` element-wisely in round-to-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, int *src) {
 *     __nram__ int src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int), GDRAM2NRAM);
 *     __bang_int322int4_tz(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int322int4_tz(int4x2_t* dst,
                                                              int* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from ``int`` to ``int4`` element-wisely in round-off-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, int *src) {
 *     __nram__ int src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int), GDRAM2NRAM);
 *     __bang_int322int4_oz(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int322int4_oz(int4x2_t* dst,
                                                              int* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-up mode.
 *
 * @details The function converts type of ``<src>`` from ``int`` to ``int4`` element-wisely in round-up mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, int *src) {
 *     __nram__ int src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int), GDRAM2NRAM);
 *     __bang_int322int4_up(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int322int4_up(int4x2_t* dst,
                                                              int* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-down mode.
 *
 * @details The function converts type of ``<src>`` from ``int`` to ``int4`` element-wisely in round-down mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, int *src) {
 *     __nram__ int src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int), GDRAM2NRAM);
 *     __bang_int322int4_dn(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int322int4_dn(int4x2_t* dst,
                                                              int* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from ``int`` to ``int4`` element-wisely in round-nearest-off-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, int *src) {
 *     __nram__ int src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int), GDRAM2NRAM);
 *     __bang_int322int4_rd(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int322int4_rd(int4x2_t* dst,
                                                              int* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-math mode.
 *
 * @details The function converts type of ``<src>`` from ``int`` to ``int4`` element-wisely in round-math mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, int *src) {
 *     __nram__ int src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int), GDRAM2NRAM);
 *     __bang_int322int4_rm(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int322int4_rm(int4x2_t* dst,
                                                              int* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-nearest-even mode.
 *
 * @details The function converts type of ``<src>`` from ``int`` to ``int4`` element-wisely in round-nearest-even mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int4x2_t *dst, int *src) {
 *     __nram__ int src_tmp[SIZE];
 *     __nram__ int4x2_t dst_tmp[SIZE/2];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int), GDRAM2NRAM);
 *     __bang_int322int4_rn(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int4x2_t) / 2, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int322int4_rn(int4x2_t* dst,
                                                              int* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-to-zero mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``float`` element-wisely in round-to-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(float *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ float dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42float_tz(dst_tmp, src_tmp, SIZE, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(float), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42float_tz(float* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int src_position);
//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``float`` element-wisely in round-off-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(float *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ float dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42float_oz(dst_tmp, src_tmp, SIZE, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(float), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42float_oz(float* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int src_position);
//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-up mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``float`` element-wisely in round-up mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(float *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ float dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42float_up(dst_tmp, src_tmp, SIZE, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(float), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42float_up(float* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int src_position);
//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-down mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``float`` element-wisely in round-down mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(float *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ float dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42float_dn(dst_tmp, src_tmp, SIZE, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(float), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42float_dn(float* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int src_position);
//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-down mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``float`` element-wisely in round-down mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(float *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ float dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42float_rd(dst_tmp, src_tmp, SIZE, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(float), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42float_rd(float* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int src_position);
//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-math mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``float`` element-wisely in round-math mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(float *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ float dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42float_rm(dst_tmp, src_tmp, SIZE, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(float), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42float_rm(float* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int src_position);
//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-nearest-even mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``float`` element-wisely in round-nearest-even mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(float *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ float dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42float_rn(dst_tmp, src_tmp, SIZE, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(float), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42float_rn(float* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int src_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-to-zero mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``half`` element-wisely in round-to-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(half *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ half dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42half_tz(dst_tmp, src_tmp, SIZE, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(half), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42half_tz(half* dst,
                                                             int4x2_t* src,
                                                             int size,
                                                             int src_position);
//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``half`` element-wisely in round-off-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(half *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ half dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42half_oz(dst_tmp, src_tmp, SIZE, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(half), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42half_oz(half* dst,
                                                             int4x2_t* src,
                                                             int size,
                                                             int src_position);
//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-up mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``half`` element-wisely in round-up mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(half *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ half dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42half_up(dst_tmp, src_tmp, SIZE, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(half), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42half_up(half* dst,
                                                             int4x2_t* src,
                                                             int size,
                                                             int src_position);
//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-down mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``half`` element-wisely in round-down mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(half *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ half dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42half_dn(dst_tmp, src_tmp, SIZE, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(half), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42half_dn(half* dst,
                                                             int4x2_t* src,
                                                             int size,
                                                             int src_position);
//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``half`` element-wisely in round-nearest-off-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(half *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ half dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42half_rd(dst_tmp, src_tmp, SIZE, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(half), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42half_rd(half* dst,
                                                             int4x2_t* src,
                                                             int size,
                                                             int src_position);
//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-math mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``half`` element-wisely in round-math mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(half *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ half dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42half_rm(dst_tmp, src_tmp, SIZE, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(half), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42half_rm(half* dst,
                                                             int4x2_t* src,
                                                             int size,
                                                             int src_position);
//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-nearest-even mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``half`` element-wisely in round-nearest-even mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(half *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ half dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42half_rn(dst_tmp, src_tmp, SIZE, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(half), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42half_rn(half* dst,
                                                             int4x2_t* src,
                                                             int size,
                                                             int src_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-to-zero mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``bfloat16_t`` element-wisely in round-to-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(bfloat16_t *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ bfloat16_t dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42bfloat16_tz(dst_tmp, src_tmp, SIZE, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(bfloat16_t), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42bfloat16_tz(bfloat16_t* dst,
                                                                 int4x2_t* src,
                                                                 int size,
                                                                 int src_position);
//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-down mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``bfloat16_t`` element-wisely in round-down mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(bfloat16_t *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ bfloat16_t dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42bfloat16_dn(dst_tmp, src_tmp, SIZE, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(bfloat16_t), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42bfloat16_dn(bfloat16_t* dst,
                                                                 int4x2_t* src,
                                                                 int size,
                                                                 int src_position);
//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``bfloat16_t`` element-wisely in round-off-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(bfloat16_t *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ bfloat16_t dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42bfloat16_oz(dst_tmp, src_tmp, SIZE, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(bfloat16_t), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42bfloat16_oz(bfloat16_t* dst,
                                                                 int4x2_t* src,
                                                                 int size,
                                                                 int src_position);
//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-up mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``bfloat16_t`` element-wisely in round-up mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(bfloat16_t *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ bfloat16_t dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42bfloat16_up(dst_tmp, src_tmp, SIZE, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(bfloat16_t), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42bfloat16_up(bfloat16_t* dst,
                                                                 int4x2_t* src,
                                                                 int size,
                                                                 int src_position);
//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``bfloat16_t`` element-wisely in round-off-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(bfloat16_t *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ bfloat16_t dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42bfloat16_rd(dst_tmp, src_tmp, SIZE, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(bfloat16_t), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42bfloat16_rd(bfloat16_t* dst,
                                                                 int4x2_t* src,
                                                                 int size,
                                                                 int src_position);
//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-math mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``bfloat16_t`` element-wisely in round-math mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(bfloat16_t *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ bfloat16_t dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42bfloat16_rm(dst_tmp, src_tmp, SIZE, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(bfloat16_t), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42bfloat16_rm(bfloat16_t* dst,
                                                                 int4x2_t* src,
                                                                 int size,
                                                                 int src_position);
//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-nearest-even mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``bfloat16_t`` element-wisely in round-nearest-even mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(bfloat16_t *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ bfloat16_t dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42bfloat16_rn(dst_tmp, src_tmp, SIZE, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(bfloat16_t), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42bfloat16_rn(bfloat16_t* dst,
                                                                 int4x2_t* src,
                                                                 int size,
                                                                 int src_position);
//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-to-zero mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``char`` element-wisely in round-to-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(char *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ char dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42int8_tz(dst_tmp, src_tmp, SIZE, DSRPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(char), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42int8_tz(char* dst,
                                                             int4x2_t* src,
                                                             int size,
                                                             int dst_position,
                                                             int src_position);
//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``char`` element-wisely in round-off-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(char *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ char dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42int8_oz(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(char), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42int8_oz(char* dst,
                                                             int4x2_t* src,
                                                             int size,
                                                             int dst_position,
                                                             int src_position);
//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-up mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``char`` element-wisely in round-up mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(char *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ char dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42int8_oz(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(char), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42int8_up(char* dst,
                                                             int4x2_t* src,
                                                             int size,
                                                             int dst_position,
                                                             int src_position);
//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-up mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``char`` element-wisely in round-up mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(char *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ char dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42int8_oz(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(char), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42int8_dn(char* dst,
                                                             int4x2_t* src,
                                                             int size,
                                                             int dst_position,
                                                             int src_position);
//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``char`` element-wisely in round-nearest-off-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(char *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ char dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42int8_rd(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(char), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42int8_rd(char* dst,
                                                             int4x2_t* src,
                                                             int size,
                                                             int dst_position,
                                                             int src_position);
//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in  round-math mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``char`` element-wisely in  round-math mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(char *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ char dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42int8_rm(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(char), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42int8_rm(char* dst,
                                                             int4x2_t* src,
                                                             int size,
                                                             int dst_position,
                                                             int src_position);
//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-nearest-even mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``char`` element-wisely in round-nearest-even mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(char *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ char dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42int8_rm(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(char), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42int8_rn(char* dst,
                                                             int4x2_t* src,
                                                             int size,
                                                             int dst_position,
                                                             int src_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-to-zero mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``short`` element-wisely in round-to-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(short *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ short dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42int16_tz(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(short), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42int16_tz(short* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position);
//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``short`` element-wisely in round-off-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(short *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ short dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42int16_oz(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(short), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42int16_oz(short* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position);
//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-up mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``short`` element-wisely in round-up mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(short *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ short dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42int16_up(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(short), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42int16_up(short* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position);
//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-down mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``short`` element-wisely in round-down mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(short *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ short dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42int16_dn(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(short), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42int16_dn(short* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position);
//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``short`` element-wisely in round-nearest-off-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(short *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ short dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42int16_rd(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(short), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42int16_rd(short* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position);
//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-math mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``short`` element-wisely in round-math mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(short *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ short dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42int16_rm(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(short), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42int16_rm(short* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position);
//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-nearest-even mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``short`` element-wisely in round-nearest-even mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(short *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ short dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42int16_rn(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(short), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42int16_rn(short* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-to-zero mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``int`` element-wisely in round-to-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ int dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42int32_tz(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42int32_tz(int* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position);
//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``int`` element-wisely in round-off-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ int dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42int32_oz(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42int32_oz(int* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position);
//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-up mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``int`` element-wisely in round-up mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ int dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42int32_up(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42int32_up(int* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position);
//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-down mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``int`` element-wisely in round-down mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ int dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42int32_dn(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42int32_dn(int* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position);
//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-nearest-off-zero mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``int`` element-wisely in round-nearest-off-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``;
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ int dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42int32_rd(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42int32_rd(int* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position);
//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-math mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``int`` element-wisely in round-math mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ int dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42int32_rm(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42int32_rm(int* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position);
//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wisely in round-nearest-even mode.
 *
 * @details The function converts type of ``<src>`` from ``int4`` to ``int`` element-wisely in round-nearest-even mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] size The elements number of conversion.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<size>`` must be greater than zero and be an positive even number;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.7.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *
 *   __mlu_entry__ void kernel(int *dst, int4x2_t *src) {
 *     __nram__ int4x2_t src_tmp[SIZE/2];
 *     __nram__ int dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(int4x2_t) / 2, GDRAM2NRAM);
 *     __bang_int42int32_rn(dst_tmp, src_tmp, SIZE, DSTPOS, SRCPOS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_int42int32_rn(int* dst,
                                                              int4x2_t* src,
                                                              int size,
                                                              int dst_position,
                                                              int src_position);

//Group:Stream Type Conversion Functions
/**
 * @brief Converts data type element-wise in round-to-zero mode.
 *
 * @details The function converts type of ``<src>`` from ``short`` to ``int`` element-wise in round-to-zero mode and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] src_count The number of elements.
 * @param[in] dst_position Scale factor of destination vector. \f$<dst> \div 2^{<dst\_position>}\f$.
 * @param[in] src_position Scale factor of source vector. \f$<src> \div 2^{<src\_position>}\f$.
 *
 * @return ``void``.
 *
 * @remark
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<src_position>`` and ``<dst_position>`` must be in the range ``[-127,127]``;
 * - ``<src>`` and ``<dst>`` can not be homologous operands;
 * - ``<src_count>`` must be greater than zero.
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc -bang-arch >= compute_30``;
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define SIZE 128
 *   #define DST_POS 3
 *   #define SRC_POS 5
 *
 *   __mlu_entry__ void kernel(int *dst, short *src) {
 *     __nram__ short src_tmp[SIZE];
 *     __nram__ int dst_tmp[SIZE];
 *     __memcpy(src_tmp, src, SIZE * sizeof(short), GDRAM2NRAM);
 *     __bang_short2int(dst_tmp, src_tmp, SIZE, DST_POS, SRC_POS);
 *     __memcpy(dst, dst_tmp, SIZE * sizeof(int), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_short2int(int* dst,
                                                          short* src,
                                                          int src_count,
                                                          int dst_position,
                                                          int src_position);

static __mlu_func__ __mlu_builtin__ void __bang_breduce(unsigned char* dst,
                                                        char* src,
                                                        int src_dim_n,
                                                        int src_dim_h,
                                                        int src_dim_w,
                                                        int byte_of_src_dim_c);
static __mlu_func__ __mlu_builtin__ void __bang_breduce(unsigned char* dst,
                                                        short* src,
                                                        int src_dim_n,
                                                        int src_dim_h,
                                                        int src_dim_w,
                                                        int byte_of_src_dim_c);
static __mlu_func__ __mlu_builtin__ void __bang_breduce(unsigned char* dst,
                                                        int* src,
                                                        int src_dim_n,
                                                        int src_dim_h,
                                                        int src_dim_w,
                                                        int byte_of_src_dim_c);

static __mlu_func__ __mlu_builtin__ void __bang_bexpand(char* dst,
                                                        unsigned char* src,
                                                        int dst_dim_n,
                                                        int dst_dim_h,
                                                        int dst_dim_w,
                                                        int byte_of_dst_dim_c);
static __mlu_func__ __mlu_builtin__ void __bang_bexpand(short* dst,
                                                        unsigned char* src,
                                                        int dst_dim_n,
                                                        int dst_dim_h,
                                                        int dst_dim_w,
                                                        int byte_of_dst_dim_c);
static __mlu_func__ __mlu_builtin__ void __bang_bexpand(int* dst,
                                                        unsigned char* src,
                                                        int dst_dim_n,
                                                        int dst_dim_h,
                                                        int dst_dim_w,
                                                        int byte_of_dst_dim_c);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_add(half* dst,
                                                    half* src0,
                                                    half* src1,
                                                    int elem_count);

static __mlu_func__ __mlu_builtin__ void __bang_add(bfloat16_t* dst,
                                                    bfloat16_t* src0,
                                                    bfloat16_t* src1,
                                                    int elem_count);

//Group:Stream Operation Functions
/**
 * @brief Performs addition operation element-wisely.
 *
 * @details The function performs addition operation element-wisely on ``<src0>`` and ``<src1>`` and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src0 The address of the first source vector.
 * @param[in] src1 The address of the second source vector.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src0>``, ``<src1>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src0>``, ``<src1>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>``, ``<src0>`` and ``<src1>`` can be homologous operands;
 * - ``<elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_binary_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define DATA_SIZE 128
 *
 *   __mlu_entry__ void kernel(float* c, float* a, float* b) {
 *     __nram__ float a_tmp[DATA_SIZE];
 *     __nram__ float c_tmp[DATA_SIZE];
 *     __nram__ float b_tmp[DATA_SIZE];
 *     __memcpy(a_tmp, a, DATA_SIZE * sizeof(float), GDRAM2NRAM);
 *     __memcpy(b_tmp, b, DATA_SIZE * sizeof(float), GDRAM2NRAM);
 *     __bang_add(c_tmp, a_tmp, b_tmp, DATA_SIZE);
 *     __memcpy(c, c_tmp, DATA_SIZE * sizeof(float), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_add(float* dst,
                                                    float* src0,
                                                    float* src1,
                                                    int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_add_tz(half* dst,
                                                       half* src0,
                                                       half* src1,
                                                       int elem_count);

//Group:Stream Operation Functions
/**
 * @brief Performs addition operation element-wisely in round-to-zero mode.
 *
 * @details The function performs addition operation element-wisely on ``<src0>`` and ``<src1>`` and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src0 The address of the first source vector.
 * @param[in] src1 The address of the second source vector.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_2xx`` and higher;
 * - ``<src0>``, ``<src1>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src0>``, ``<src1>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<dst>``, ``<src0>`` and ``<src1>`` can be homologous operands;
 * - ``<elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_2xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_binary_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define DATA_SIZE 128
 *
 *   __mlu_entry__ void kernel(float* c, float* a, float* b) {
 *     __nram__ float a_tmp[DATA_SIZE];
 *     __nram__ float c_tmp[DATA_SIZE];
 *     __nram__ float b_tmp[DATA_SIZE];
 *     __memcpy(a_tmp, a, DATA_SIZE * sizeof(float), GDRAM2NRAM);
 *     __memcpy(b_tmp, b, DATA_SIZE * sizeof(float), GDRAM2NRAM);
 *     __bang_add_tz(c_tmp, a_tmp, b_tmp, DATA_SIZE);
 *     __memcpy(c, c_tmp, DATA_SIZE * sizeof(float), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_add_tz(float* dst,
                                                       float* src0,
                                                       float* src1,
                                                       int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_sub(half* dst,
                                                    half* src0,
                                                    half* src1,
                                                    int elem_count);

static __mlu_func__ __mlu_builtin__ void __bang_sub(bfloat16_t* dst,
                                                    bfloat16_t* src0,
                                                    bfloat16_t* src1,
                                                    int elem_count);

//Group:Stream Operation Functions
/**
 * @brief Performs subtraction operation element-wisely.
 *
 * @details The function performs subtraction operation element-wisely on ``<src0>`` and ``<src1>`` and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src0 The address of the first source vector.
 * @param[in] src1 The address of the second source vector.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src0>``, ``<src1>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src0>``, ``<src1>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>``, ``<src0>`` and ``<src1>`` can be homologous operands;
 * - ``<elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_binary_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * See the example of ::__bang_add for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_sub(float* dst,
                                                    float* src0,
                                                    float* src1,
                                                    int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_mul(half* dst,
                                                    half* src0,
                                                    half* src1,
                                                    int elem_count);

static __mlu_func__ __mlu_builtin__ void __bang_mul(bfloat16_t* dst,
                                                    bfloat16_t* src0,
                                                    bfloat16_t* src1,
                                                    int elem_count);

//Group:Stream Operation Functions
/**
 * @brief Performs multiplication operation element-wisely.
 *
 * @details The function performs multiplication operation element-wisely on ``<src0>`` and ``<src1>`` and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src0 The address of the first source vector.
 * @param[in] src1 The address of the second source vector.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src0>``, ``<src1>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src0>``, ``<src1>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>``, ``<src0>`` and ``<src1>`` can be homologous operands;
 * - ``<elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_binary_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * See the example of ::__bang_add for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_mul(float* dst,
                                                    float* src0,
                                                    float* src1,
                                                    int elem_count);

//Group:Surpass Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_div(half* dst,
                                                    half* src0,
                                                    half* src1,
                                                    int elem_count);

//Group:Surpass Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_div(float* dst,
                                                    float* src0,
                                                    float* src1,
                                                    int elem_count);

//Group:Surpass Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_div(short* dst,
                                                    short* src0,
                                                    short* src1,
                                                    int elem_count);

//Group:Surpass Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_div(int* dst,
                                                    int* src0,
                                                    int* src1,
                                                    int elem_count);

//Group:Surpass Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_div(unsigned short* dst,
                                                    unsigned short* src0,
                                                    unsigned short* src1,
                                                    int elem_count);

//Group:Surpass Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_div(unsigned int* dst,
                                                    unsigned int* src0,
                                                    unsigned int* src1,
                                                    int elem_count);

//Group:Surpass Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_div(half* dst,
                                                    half* src0,
                                                    half src1,
                                                    int elem_count);

//Group:Surpass Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_div(float* dst,
                                                    float* src0,
                                                    float src1,
                                                    int elem_count);

//Group:Surpass Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_div(short* dst,
                                                    short* src0,
                                                    short src1,
                                                    int elem_count);

//Group:Surpass Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_div(int* dst,
                                                    int* src0,
                                                    int src1,
                                                    int elem_count);

//Group:Surpass Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_div(unsigned short* dst,
                                                    unsigned short* src0,
                                                    unsigned short src1,
                                                    int elem_count);

//Group:Surpass Operation Functions
/**
 * @brief Calculates the division of ``<src>``.
 *
 * @details This function computes the division of each element in ``<src>`` and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src0 The address of first source vector.
 * @param[in] src1 The address of second source vector, or the value of second source scalar.
 * @param[in] elem_count Number of elements in source and destination.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<elem_count>`` must be a positive integer;
 * - ``<dst>`` and ``<src0>`` must point to ``__nram__`` space;
 * - ``<src1>`` must point to ``__nram__`` space if it is the address of second source vector;
 * - The value of ``<src1>`` can not be equal to zero;
 * - ``<dst>``, ``<src0>`` and ``<src1>`` (vector address) can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_div_operation_function` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *   - BANG Version: ``__BANG_ARCH__ >= 322`` && ``__BANG_ARCH__ != 372``;
 *   - CNCC Version: ``cncc --version >= 3.0.0`` ;
 *   - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30`` && ``--bang-mlu-arch != mtp_372``;
 *   - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322`` && ``--bang-mlu-arch != mtp_372``.
 *
 * @par Example
 * @code
 *
 *    #include <bang.h>
 *
 *    #define DATA_NUM 128
 *
 *    __mlu_entry__ void kernel(int *output, int *src) {
 *      __nram__ int _src[DATA_NUM];
 *      __nram__ int _output[DATA_NUM];
 *      __memcpy(_src, src, DATA_NUM * sizeof(int), GDRAM2NRAM);
 *      __bang_div(_output, _src, 10, DATA_NUM);
 *      __memcpy(output, _output, DATA_NUM * sizeof(int), NRAM2GDRAM);
 *    }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_div(unsigned int* dst,
                                                    unsigned int* src0,
                                                    unsigned int src1,
                                                    int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_div(half* dst,
                                                    half* src0,
                                                    half* src1,
                                                    half* src_addition,
                                                    int elem_count);

//Group:Stream Operation Functions
/**
 * @brief Performs division operation element-wisely.
 *
 * @details The function performs division operation element-wisely on ``<src0>`` and ``<src1>`` and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src0 The address of the first source vector.
 * @param[in] src1 The address of the second source vector.
 * @param[in] src_addition The address of additional vector.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src0>``, ``<src1>``, ``<dst>`` and ``<src_addition>`` must point to ``__nram__`` space;
 * - ``<src0>``, ``<src1>``, ``<dst>`` and ``<src_addition>`` can not be homologous operands;
 * - ``<elem_count> * sizeof(type)`` must be divisible by 128;
 * - The size of ``<src_addition>`` vector is identical to the size of ``<src0>``, ``<src1>`` and ``<dst>``;
 * - ``<elem_count>`` must be greater than zero;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_div_operation_function` for more details;
 * \endrst
 * - For higher precision, use ::__bang_recip and ::__bang_mul on ``mtp_372`` instead of ``__bang_div``;
 * - For higher precision, use surpass function ::__bang_div on ``tp_322``.
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define DATA_SIZE 128
 *
 *   __mlu_entry__ void kernel(float* c, float* a, float* b) {
 *     __nram__ float a_tmp[DATA_SIZE];
 *     __nram__ float c_tmp[DATA_SIZE];
 *     __nram__ float b_tmp[DATA_SIZE];
 *     __nram__ float addition[DATA_SIZE];
 *     __memcpy(a_tmp, a, DATA_SIZE * sizeof(float), GDRAM2NRAM);
 *     __memcpy(b_tmp, b, DATA_SIZE * sizeof(float), GDRAM2NRAM);
 *     __bang_div(c_tmp, a_tmp, b_tmp, src_addition, DATA_SIZE);
 *     __memcpy(c, c_tmp, DATA_SIZE * sizeof(float), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_div(float* dst,
                                                    float* src0,
                                                    float* src1,
                                                    float* src_addition,
                                                    int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_add_const(half* dst,
                                                          half* src,
                                                          half const_value,
                                                          int elem_count);

//Group:Stream Operation Functions
/**
 * @brief Adds a constant value to elements of the source vector.
 *
 * @details The function adds ``<const_value>`` to ``<elem_count>`` elements of ``<src>`` and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] const_value The constant value.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_2xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - This function will be deprecated in the future, please use ::__bang_add_scalar instead.
 *
 * @par
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_binary_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define DATA_SIZE 128
 *
 *   __mlu_entry__ void kernel(float* c, float* a, float b) {
 *     __nram__ float a_tmp[DATA_SIZE];
 *     __nram__ float c_tmp[DATA_SIZE];
 *     __memcpy(a_tmp, a, DATA_SIZE * sizeof(float), GDRAM2NRAM);
 *     __bang_add_const(c_tmp, a_tmp, b, DATA_SIZE);
 *     __memcpy(c, c_tmp, DATA_SIZE * sizeof(float), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_add_const(float* dst,
                                                          float* src,
                                                          float const_value,
                                                          int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_add_scalar(half* dst,
                                                           half* src,
                                                           half const_value,
                                                           int elem_count);

static __mlu_func__ __mlu_builtin__ void __bang_add_scalar(bfloat16_t* dst,
                                                           bfloat16_t* src,
                                                           bfloat16_t const_value,
                                                           int elem_count);


//Group:Stream Operation Functions
/**
 * @brief Adds a constant value to elements of the source vector.
 *
 * @details The function adds ``<const_value>`` to ``<elem_count>`` elements of ``<src>`` and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] const_value The constant value.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_2xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_binary_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define DATA_SIZE 128
 *
 *   __mlu_entry__ void kernel(float* c, float* a, float b) {
 *     __nram__ float a_tmp[DATA_SIZE];
 *     __nram__ float c_tmp[DATA_SIZE];
 *     __memcpy(a_tmp, a, DATA_SIZE * sizeof(float), GDRAM2NRAM);
 *     __bang_add_scalar(c_tmp, a_tmp, b, DATA_SIZE);
 *     __memcpy(c, c_tmp, DATA_SIZE * sizeof(float), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_add_scalar(float* dst,
                                                           float* src,
                                                           float const_value,
                                                           int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_sub_const(half* dst,
                                                          half* src,
                                                          half const_value,
                                                          int elem_count);

//Group:Stream Operation Functions
/**
 * @brief Subtracts a constant value from elements of the source vector.
 *
 * @details The function subtracts ``<const_value>`` from ``<elem_count>`` elements of ``<src>`` and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] const_value The constant value.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_2xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - This function will be deprecated in the future, please use ::__bang_sub_scalar instead;
 *
 * @par
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_binary_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * See the example of ::__bang_add_const for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_sub_const(float* dst,
                                                          float* src,
                                                          float const_value,
                                                          int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_sub_scalar(half* dst,
                                                           half* src,
                                                           half const_value,
                                                           int elem_count);

static __mlu_func__ __mlu_builtin__ void __bang_sub_scalar(bfloat16_t* dst,
                                                           bfloat16_t* src,
                                                           bfloat16_t const_value,
                                                           int elem_count);

//Group:Stream Operation Functions
/**
 * @brief Subtracts a constant value from elements of the source vector.
 *
 * @details The function subtracts ``<const_value>`` from ``<elem_count>`` elements of ``<src>`` and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] const_value The constant value.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_2xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_binary_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * See the example of ::__bang_add_scalar for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_sub_scalar(float* dst,
                                                           float* src,
                                                           float const_value,
                                                           int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_mul_const(half* dst,
                                                          half* src,
                                                          half const_value,
                                                          int elem_count);

//Group:Stream Operation Functions
/**
 * @brief Multiplies elements of the source vector by a scalar.
 *
 * @details The function multiplies ``<elem_count>`` elements of ``<src>`` by ``<const_value>`` and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] const_value The constant value.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - ``<elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - This function will be deprecated in the future, please use ::__bang_mul_scalar instead;
 *
 * @par
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_binary_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * See the example of ::__bang_add_const for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_mul_const(float* dst,
                                                          float* src,
                                                          float const_value,
                                                          int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_mul_scalar(half* dst,
                                                           half* src,
                                                           half const_value,
                                                           int elem_count);

static __mlu_func__ __mlu_builtin__ void __bang_mul_scalar(bfloat16_t* dst,
                                                           bfloat16_t* src,
                                                           bfloat16_t const_value,
                                                           int elem_count);

//Group:Stream Operation Functions
/**
 * @brief Multiplies elements of the source vector by a scalar.
 *
 * @details The function multiplies ``<elem_count>`` elements of ``<src>`` by ``<const_value>`` and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] const_value The constant value.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - ``<elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * See the example of ::__bang_add_scalar for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_mul_scalar(float* dst,
                                                           float* src,
                                                           float const_value,
                                                           int elem_count);

//Group:Stream Comparison Functions
static __mlu_func__ __mlu_builtin__ void __bang_maxeq_scalar(half* dst,
                                                             half* src,
                                                             half const_value,
                                                             int elem_count);

//Group:Stream Comparison Functions
/**
 * @brief Finds the maximum between elements in the source vector and a scalar.
 *
 * @details The function finds the maximum between ``<elem_count>`` elements of ``<src>`` and ``<const_value>`` and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] const_value The constant value.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - ``<elem_count>`` must be greater than zero;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_binary_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * See the example of ::__bang_eq_scalar for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_maxeq_scalar(float* dst,
                                                             float* src,
                                                             float const_value,
                                                             int elem_count);

//Group:Stream Comparison Functions
static __mlu_func__ __mlu_builtin__ void __bang_mineq_scalar(half* dst,
                                                             half* src,
                                                             half const_value,
                                                             int elem_count);

//Group:Stream Comparison Functions
/**
 * @brief Finds the minimum between elements in the source vector and a scalar.
 *
 * @details The function finds the minimum between ``<elem_count>`` elements of ``<src>`` and ``<const_value>`` and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] const_value The constant value.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - ``<elem_count>`` must be greater than zero.
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * See the example of ::__bang_eq_scalar for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_mineq_scalar(float* dst,
                                                             float* src,
                                                             float const_value,
                                                             int elem_count);

//Group:Stream Comparison Functions
static __mlu_func__ __mlu_builtin__ void __bang_eq_scalar(half* dst,
                                                          half* src,
                                                          half const_value,
                                                          int elem_count);

//Group:Stream Comparison Functions
/**
 * @brief Performs equality comparison with elements in the source vector and a scalar.
 *
 * @details The function performs equality comparison with ``<elem_count>`` elements of ``<src>`` and ``<const_value>`` and saves the result in ``<dst>``. If the element of ``<src>`` and ``<const_value>`` are equal, the result is 1.0. Otherwise, the result is 0.0. The type of result is same as the type of the element of ``<src>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] const_value The constant value.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - ``<elem_count>`` must be greater than zero;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define DATA_SIZE 128
 *
 *   __mlu_entry__ void kernel(float* c, float* a, float b) {
 *     __nram__ float a_tmp[DATA_SIZE];
 *     __nram__ float c_tmp[DATA_SIZE];
 *     __memcpy(a_tmp, a, DATA_SIZE * sizeof(float), GDRAM2NRAM);
 *     __bang_eq_scalar(c_tmp, a_tmp, b, DATA_SIZE);
 *     __memcpy(c, c_tmp, DATA_SIZE * sizeof(float), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_eq_scalar(float* dst,
                                                          float* src,
                                                          float const_value,
                                                          int elem_count);

static __mlu_func__ __mlu_builtin__ void __bang_eq_scalar(bfloat16_t* dst,
                                                          bfloat16_t* src,
                                                          bfloat16_t const_value,
                                                          int elem_count);

//Group:Stream Comparison Functions
static __mlu_func__ __mlu_builtin__ void __bang_ne_scalar(half* dst,
                                                          half* src,
                                                          half const_value,
                                                          int elem_count);

//Group:Stream Comparison Functions
/**
 * @brief Performs inequality comparison with elements in the source vector and a scalar.
 *
 * @details The function performs inequality comparison with ``<elem_count>`` elements of ``<src>`` and ``<const_value>`` and saves the result in ``<dst>``. The type of result is same as the type of ``<src>``. If the element of ``<src>`` and ``<const_value>`` are not equal, the result is 1.0. Otherwise, the result is 0.0. The type of result is same as the type of the element of ``<src>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] const_value The constant value.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - ``<elem_count>`` must be greater than zero;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * See the example of ::__bang_eq_scalar for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_ne_scalar(float* dst,
                                                          float* src,
                                                          float const_value,
                                                          int elem_count);

static __mlu_func__ __mlu_builtin__ void __bang_ne_scalar(bfloat16_t* dst,
                                                          bfloat16_t* src,
                                                          bfloat16_t const_value,
                                                          int elem_count);

//Group:Stream Comparison Functions
static __mlu_func__ __mlu_builtin__ void __bang_le_scalar(half* dst,
                                                          half* src,
                                                          half const_value,
                                                          int elem_count);

//Group:Stream Comparison Functions
/**
 * @brief Compares elements in the source vector with a scalar to determine whether the elements are less than or equal to the scalar.
 *
 * @details The function compares ``<elem_count>`` elements in ``<src>`` with ``<const_value>`` to determine whether the elements are less than or equal to ``<const_value>`` and saves the result in ``<dst>``. If the element of ``<src>`` is less than or equal to ``<const_value>``, the result is 1.0. Otherwise, the result is 0.0. The type of result is same as the type of the element of ``<src>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] const_value The constant value.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - ``<elem_count>`` must be greater than zero;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * See the example of ::__bang_eq_scalar for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_le_scalar(float* dst,
                                                          float* src,
                                                          float const_value,
                                                          int elem_count);

static __mlu_func__ __mlu_builtin__ void __bang_le_scalar(bfloat16_t* dst,
                                                          bfloat16_t* src,
                                                          bfloat16_t const_value,
                                                          int elem_count);

//Group:Stream Comparison Functions
static __mlu_func__ __mlu_builtin__ void __bang_lt_scalar(half* dst,
                                                          half* src,
                                                          half const_value,
                                                          int elem_count);

//Group:Stream Comparison Functions
/**
 * @brief Compares elements in the source vector with a scalar to determine whether the elements are less than the scalar.
 *
 * @details The function compares ``<elem_count>`` elements in ``<src>`` with ``<const_value>`` to determine whether the elements are less than ``<const_value>`` and saves the result in ``<dst>``. If the element of ``<src>`` is less than ``<const_value>``, the result is 1.0. Otherwise, the result is 0.0. The type of result is same as the type of the element of ``<src>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] const_value The constant value.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - ``<elem_count>`` must be greater than zero;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * See the example of ::__bang_eq_scalar for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_lt_scalar(float* dst,
                                                          float* src,
                                                          float const_value,
                                                          int elem_count);

static __mlu_func__ __mlu_builtin__ void __bang_lt_scalar(bfloat16_t* dst,
                                                          bfloat16_t* src,
                                                          bfloat16_t const_value,
                                                          int elem_count);

//Group:Stream Comparison Functions
static __mlu_func__ __mlu_builtin__ void __bang_ge_const(half* dst,
                                                         half* src,
                                                         half const_value,
                                                         int elem_count);

//Group:Stream Comparison Functions
/**
 * @brief Compares elements in the source vector with a scalar to determine whether the elements are greater than or equal to the scalar.
 *
 * @details The function compares ``<elem_count>`` elements in ``<src>`` with ``<const_value>`` to determine whether the elements are greater than or equal to ``<const_value>`` and saves the result in ``<dst>``. If the element of ``<src>`` is greater than or equal to ``<const_value>``, the result is 1.0. Otherwise, the result is 0.0. The type of result is same as the type of the element of ``<src>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] const_value The constant value.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - This function will be deprecated in the future, please use ::__bang_ge_scalar instead;
 *
 * @par
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= (m)tp_1xx``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define DATA_SIZE 128
 *
 *   __mlu_entry__ void kernel(float* c, float* a, float b) {
 *     __nram__ float a_tmp[DATA_SIZE];
 *     __nram__ float c_tmp[DATA_SIZE];
 *     __memcpy(a_tmp, a, DATA_SIZE * sizeof(float), GDRAM2NRAM);
 *     __bang_ge_scalar(c_tmp, a_tmp, b, DATA_SIZE);
 *     __memcpy(c, c_tmp, DATA_SIZE * sizeof(float), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_ge_const(float* dst,
                                                         float* src,
                                                         float const_value,
                                                         int elem_count);

//Group:Stream Comparison Functions
static __mlu_func__ __mlu_builtin__ void __bang_ge_scalar(half* dst,
                                                          half* src,
                                                          half const_value,
                                                          int elem_count);

//Group:Stream Comparison Functions
/**
 * @brief Compares elements in the source vector with a scalar to determine whether the elements are greater than or equal to the scalar.
 *
 * @details The function compares ``<elem_count>`` elements in ``<src>`` with ``<const_value>`` to determine whether the elements are greater than or equal to ``<const_value>`` and saves the result in ``<dst>``.  If the element of ``<src>`` is greater than or equal to ``<const_value>``, the result is 1.0. Otherwise, the result is 0.0. The type of result is same as the type of the element of ``<src>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] const_value The constant value.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` can be homologous operands;
 * - ``<elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 *
 * @par
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= (m)tp_1xx``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define DATA_SIZE 128
 *
 *   __mlu_entry__ void kernel(float* c, float* a, float b) {
 *     __nram__ float a_tmp[DATA_SIZE];
 *     __nram__ float c_tmp[DATA_SIZE];
 *     __memcpy(a_tmp, a, DATA_SIZE * sizeof(float), GDRAM2NRAM);
 *     __bang_ge_scalar(c_tmp, a_tmp, b, DATA_SIZE);
 *     __memcpy(c, c_tmp, DATA_SIZE * sizeof(float), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_ge_scalar(float* dst,
                                                          float* src,
                                                          float const_value,
                                                          int elem_count);

static __mlu_func__ __mlu_builtin__ void __bang_ge_scalar(bfloat16_t* dst,
                                                          bfloat16_t* src,
                                                          bfloat16_t const_value,
                                                          int elem_count);

//Group:Stream Comparison Functions
static __mlu_func__ __mlu_builtin__ void __bang_gt_scalar(half* dst,
                                                          half* src,
                                                          half const_value,
                                                          int elem_count);

//Group:Stream Comparison Functions
/**
 * @brief Compares elements in the source vector with a scalar to determine whether the elements are greater than the scalar.
 *
 * @details The function compares ``<elem_count>`` elements in ``<src>`` with ``<const_value>`` to determine whether the elements are greater than ``<const_value>`` and saves the result in ``<dst>``. If the element of ``<src>`` is greater than ``<const_value>``, the result is 1.0. Otherwise, the result is 0.0. The type of result is same as the type of the element of ``<src>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] const_value The constant value.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - ``<elem_count>`` must be greater than zero;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * See the example of ::__bang_eq_scalar for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_gt_scalar(float* dst,
                                                          float* src,
                                                          float const_value,
                                                          int elem_count);

static __mlu_func__ __mlu_builtin__ void __bang_gt_scalar(bfloat16_t* dst,
                                                          bfloat16_t* src,
                                                          bfloat16_t const_value,
                                                          int elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_and_scalar(half* dst,
                                                           half* src,
                                                           half const_value,
                                                           int elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_and_scalar(int* dst,
                                                           int* src,
                                                           int const_value,
                                                           int elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_and_scalar(short* dst,
                                                           short* src,
                                                           short const_value,
                                                           int elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_and_scalar(char* dst,
                                                           char* src,
                                                           char const_value,
                                                           int elem_count);

static __mlu_func__ __mlu_builtin__ void __bang_and_scalar(bfloat16_t* dst,
                                                           bfloat16_t* src,
                                                           bfloat16_t const_value,
                                                           int elem_count);
//Group:Stream Logic and Bit Operation Functions
/**
 * @brief Performs logical AND operation between elements in the source vector and a scalar.
 *
 * @details The function performs logical AND operation between ``<elem_count>`` elements of ``<src>`` and ``<const_value>`` and saves the result in ``<dst>``. If both the element of ``<src>`` and ``<const_value>`` are non-zero, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of ``<src>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] const_value The constant value.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``int``, ``short`` and ``char`` are supported on ``(m)tp_3xx`` and higher;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - ``<elem_count>`` must be greater than zero;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_binary_logic_and_bit_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define DATA_SIZE 128
 *
 *   __mlu_entry__ void kernel(float* c, float* a, float b) {
 *     __nram__ float a_tmp[DATA_SIZE];
 *     __nram__ float c_tmp[DATA_SIZE];
 *     __memcpy(a_tmp, a, DATA_SIZE * sizeof(float), GDRAM2NRAM);
 *     __bang_and_scalar(c_tmp, a_tmp, b, DATA_SIZE);
 *     __memcpy(c, c_tmp, DATA_SIZE * sizeof(float), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_and_scalar(float* dst,
                                                           float* src,
                                                           float const_value,
                                                           int elem_count);

//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_or_scalar(half* dst,
                                                          half* src,
                                                          half const_value,
                                                          int elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_or_scalar(int* dst,
                                                          int* src,
                                                          int const_value,
                                                          int elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_or_scalar(short* dst,
                                                          short* src,
                                                          short const_value,
                                                          int elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_or_scalar(char* dst,
                                                          char* src,
                                                          char const_value,
                                                          int elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_or_scalar(bfloat16_t* dst,
                                                          bfloat16_t* src,
                                                          bfloat16_t const_value,
                                                          int elem_count);

//Group:Stream Logic and Bit Operation Functions
/**
 * @brief Performs logical OR operation between elements in the source vector and a scalar.
 *
 * @details The function performs logical OR operation between ``<elem_count>`` elements of ``<src>`` and ``<const_value>`` and saves the result in ``<dst>``. If either the element of ``<src>`` or ``<const_value>`` is non-zero, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of ``<src>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] const_value The constant value.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``int``, ``short`` and ``char`` are supported on ``(m)tp_3xx`` and higher;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - ``<elem_count>`` must be greater than zero;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_binary_logic_and_bit_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * See the example of ::__bang_and_scalar for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_or_scalar(float* dst,
                                                          float* src,
                                                          float const_value,
                                                          int elem_count);

//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_xor_scalar(half* dst,
                                                           half* src,
                                                           half const_value,
                                                           int elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_xor_scalar(int* dst,
                                                           int* src,
                                                           int const_value,
                                                           int elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_xor_scalar(short* dst,
                                                           short* src,
                                                           short const_value,
                                                           int elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_xor_scalar(char* dst,
                                                           char* src,
                                                           char const_value,
                                                           int elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_xor_scalar(bfloat16_t* dst,
                                                           bfloat16_t* src,
                                                           bfloat16_t const_value,
                                                           int elem_count);

//Group:Stream Logic and Bit Operation Functions
/**
 * @brief Performs logical XOR operation between elements in the source vector and a scalar.
 *
 * @details The function performs logical OR operation between ``<elem_count>`` elements of ``<src>`` and ``<const_value>`` and saves the result in ``<dst>``. If the element of ``<src>`` is zero and ``<const_value>`` is non-zero, or the element of ``<src>`` is non-zero and ``<const_value>`` is zero, the result is 1. Otherwise, the result is 0. The type of result is same as the type of the element of ``<src>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] const_value The constant value.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``int``, ``short`` and ``char`` are supported on ``(m)tp_3xx`` and higher;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - ``<elem_count>`` must be greater than zero;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_binary_logic_and_bit_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * See the example of ::__bang_and_scalar for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_xor_scalar(float* dst,
                                                           float* src,
                                                           float const_value,
                                                           int elem_count);

//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_band_scalar(half* dst,
                                                            half* src,
                                                            half const_value,
                                                            int elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_band_scalar(int* dst,
                                                            int* src,
                                                            int const_value,
                                                            int elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_band_scalar(short* dst,
                                                            short* src,
                                                            short const_value,
                                                            int elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_band_scalar(char* dst,
                                                            char* src,
                                                            char const_value,
                                                            int elem_count);

//Group:Stream Logic and Bit Operation Functions
/**
 * @brief Performs AND operation between elements in the source vector and a scalar bit-wise.
 *
 * @details The function performs AND operation between ``<elem_count>`` elements of ``<src>`` and ``<const_value>`` bit-wise and saves the result in ``<dst>``. If both the element of ``<src>`` and ``<const_value>`` are non-zero, the bit of result is 1. Otherwise, the bit of result is 0.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] const_value The constant value.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * - ``int``, ``short`` and ``char`` are supported on ``(m)tp_3xx`` and higher;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - ``<elem_count>`` must be greater than zero.
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define DATA_SIZE 128
 *
 *   __mlu_entry__ void kernel(float* c, float* a, float b) {
 *     __nram__ float a_tmp[DATA_SIZE];
 *     __nram__ float c_tmp[DATA_SIZE];
 *     __memcpy(a_tmp, a, DATA_SIZE * sizeof(float), GDRAM2NRAM);
 *     __bang_band_scalar(c_tmp, a_tmp, b, DATA_SIZE);
 *     __memcpy(c, c_tmp, DATA_SIZE * sizeof(float), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_band_scalar(float* dst,
                                                            float* src,
                                                            float const_value,
                                                            int elem_count);

//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_bor_scalar(half* dst,
                                                           half* src,
                                                           half const_value,
                                                           int elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_bor_scalar(int* dst,
                                                           int* src,
                                                           int const_value,
                                                           int elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_bor_scalar(short* dst,
                                                           short* src,
                                                           short const_value,
                                                           int elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_bor_scalar(char* dst,
                                                           char* src,
                                                           char const_value,
                                                           int elem_count);

//Group:Stream Logic and Bit Operation Functions
/**
 * @brief Performs OR operation between elements in the source vector and a scalar bit-wise.
 *
 * @details The function performs OR operation between ``<elem_count>`` elements of ``<src>`` and ``<const_value>`` bit-wise and saves the result in ``<dst>``. If either the element of ``<src>`` or ``<const_value>`` is non-zero, the bit of result is 1. Otherwise, the bit of result is 0.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] const_value The constant value.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * - ``int``, ``short`` and ``char`` are supported on ``(m)tp_3xx`` and higher;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - ``<elem_count>`` must be greater than zero.
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * See the example of ::__bang_band_scalar for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_bor_scalar(float* dst,
                                                           float* src,
                                                           float const_value,
                                                           int elem_count);

//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_bxor_scalar(half* dst,
                                                            half* src,
                                                            half const_value,
                                                            int elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_bxor_scalar(int* dst,
                                                            int* src,
                                                            int const_value,
                                                            int elem_count);

//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_bxor_scalar(short* dst,
                                                            short* src,
                                                            short const_value,
                                                            int elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_bxor_scalar(char* dst,
                                                            char* src,
                                                            char const_value,
                                                            int elem_count);

//Group:Stream Logic and Bit Operation Functions
/**
 * @brief Performs XOR operation between elements in the source vector and a scalar bit-wise.
 *
 * @details The function performs XOR operation between ``<elem_count>`` elements of ``<src>`` and ``<const_value>`` bit-wise and saves the result in ``<dst>``. If the element of ``<src>`` is zero and ``<const_value>`` is non-zero, or the element of ``<src>`` is non-zero and ``<const_value>`` is zero, the bit of result is 1. Otherwise, the bit of result is 0.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] const_value The constant value.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * - ``int``, ``short`` and ``char`` are supported on ``(m)tp_3xx`` and higher;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - ``<elem_count>`` must be greater than zero.
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * See the example of ::__bang_band_scalar for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_bxor_scalar(float* dst,
                                                            float* src,
                                                            float const_value,
                                                            int elem_count);

//Group:Stream Fusion Functions
static __mlu_func__ __mlu_builtin__ void __bang_fusion(mluFusionOpCode op_code,
                                                       half* dst,
                                                       half* src0,
                                                       half src1,
                                                       half src2,
                                                       int dst_src0_elem_count);

//Group:Stream Fusion Functions
static __mlu_func__ __mlu_builtin__ void __bang_fusion(mluFusionOpCode op_code,
                                                       float* dst,
                                                       float* src0,
                                                       float* src1,
                                                       float src2,
                                                       int dst_src0_elem_count,
                                                       int src1_elem_count);

//Group:Stream Fusion Functions
static __mlu_func__ __mlu_builtin__ void __bang_fusion(mluFusionOpCode op_code,
                                                       float* dst,
                                                       float* src0,
                                                       float src1,
                                                       float* src2,
                                                       int dst_src0_elem_count,
                                                       int src2_elem_count);

//Group:Stream Fusion Functions
static __mlu_func__ __mlu_builtin__ void __bang_fusion(mluFusionOpCode op_code,
                                                       float* dst,
                                                       float* src0,
                                                       float src1,
                                                       float src2,
                                                       int dst_src0_elem_count);

//Group:Stream Fusion Functions
static __mlu_func__ __mlu_builtin__ void __bang_fusion(mluFusionOpCode op_code,
                                                       half* dst,
                                                       half* src0,
                                                       half* src1,
                                                       half* src2,
                                                       int dst_src0_elem_count,
                                                       int src1_src2_elem_count);

//Group:Stream Fusion Functions
static __mlu_func__ __mlu_builtin__ void __bang_fusion(mluFusionOpCode op_code,
                                                       half* dst,
                                                       half* src0,
                                                       half* src1,
                                                       half src2,
                                                       int dst_src0_elem_count,
                                                       int src1_elem_count);

//Group:Stream Fusion Functions
static __mlu_func__ __mlu_builtin__ void __bang_fusion(mluFusionOpCode op_code,
                                                       half* dst,
                                                       half* src0,
                                                       half src1,
                                                       half* src2,
                                                       int dst_src0_elem_count,
                                                       int src2_elem_count);

static __mlu_func__ __mlu_builtin__ void __bang_fusion(mluFusionOpCode op_code,
                                                       bfloat16_t* dst,
                                                       bfloat16_t* src0,
                                                       bfloat16_t* src1,
                                                       bfloat16_t* src2,
                                                       int dst_src0_elem_count,
                                                       int src1_src2_elem_count);

static __mlu_func__ __mlu_builtin__ void __bang_fusion(mluFusionOpCode op_code,
                                                       bfloat16_t* dst,
                                                       bfloat16_t* src0,
                                                       bfloat16_t* src1,
                                                       bfloat16_t src2,
                                                       int dst_src0_elem_count,
                                                       int src1_elem_count);

static __mlu_func__ __mlu_builtin__ void __bang_fusion(mluFusionOpCode op_code,
                                                       bfloat16_t* dst,
                                                       bfloat16_t* src0,
                                                       bfloat16_t src1,
                                                       bfloat16_t* src2,
                                                       int dst_src0_elem_count,
                                                       int src2_elem_count);

static __mlu_func__ __mlu_builtin__ void __bang_fusion(mluFusionOpCode op_code,
                                                       bfloat16_t* dst,
                                                       bfloat16_t* src0,
                                                       bfloat16_t src1,
                                                       bfloat16_t src2,
                                                       int dst_src0_elem_count);

//Group:Stream Fusion Functions
/**
 * @brief Performs arithmetic calculation on source vectors element-wisely.
 *
 * @details The function performs arithmetic calculation on vectors ``<src0>`` , ``<src1>`` and ``<src2>`` element-wisely according to ``<op_code>`` and saves the result in ``<dst>``. ``<op_code>`` indicates the type of operator. ``<op_code>`` is assigned to an enumerated type called ``mluFusionOpCode`` that contains eight enumerators listed in the table below.
 * \rst
 *
 * .. table::  Semantics of ``mluFusionOpCode``
 *    :widths: 1 2
 *
 *    +---------------------------+-------------------------------------------------+
 *    | ``mluFusionOpCode`` Type  |                   Semantic                      |
 *    +===========================+=================================================+
 *    | ``FUSION_FMA``            | :math:`<dst> = <src0> \times <src1> + <src2>`   |
 *    +---------------------------+-------------------------------------------------+
 *    | ``FUSION_FMS``            | :math:`<dst> = <src0> \times <src1> - <src2>`   |
 *    +---------------------------+-------------------------------------------------+
 *    | ``FUSION_FAM``            | :math:`<dst> = (<src0> + <src1>) \times <src2>` |
 *    +---------------------------+-------------------------------------------------+
 *    | ``FUSION_FSM``            | :math:`<dst> = (<src0> - <src1>) \times <src2>` |
 *    +---------------------------+-------------------------------------------------+
 *    | ``FUSION_FAA``            | :math:`<dst> = <src0> + <src1> + <src2>`        |
 *    +---------------------------+-------------------------------------------------+
 *    | ``FUSION_FAS``            | :math:`<dst> = <src0> + <src1> - <src2>`        |
 *    +---------------------------+-------------------------------------------------+
 *    | ``FUSION_FSS``            | :math:`<dst> = <src0> - <src1> - <src2>`        |
 *    +---------------------------+-------------------------------------------------+
 *    | ``FUSION_FSA``            | :math:`<dst> = <src0> - <src1> + <src2>`        |
 *    +---------------------------+-------------------------------------------------+
 *
 * .. note:: For the last two characters of enumerators, 'M' means multiplication, 'A' means addition and 'S' means subtraction.
 *
 * \endrst
 *
 * @param[in] op_code The type of operator.
 * @param[out] dst The address of destination vector.
 * @param[in] src0 The address of the first source vector.
 * @param[in] src1 The address of the second source vector or the second scalar.
 * @param[in] src2 The address of the third source vector or the third scalar.
 * @param[in] dst_src0_elem_count The number of elements in destination vector or the first source vector.
 * @param[in] src1_src2_elem_count The number of elements in the second or third vector.
 *
 * @return ``void``.
 *
 * @remark
 * - ``<src0>`` and ``<dst>`` must point to ``__nram__`` space. ``<src1>`` or ``<src2>`` must also point to ``__nram__`` space if it is a vector;
 * - ``<dst>`` and ``<src0>`` must contain the same number of elements;
 * - ``<src1>`` and ``<src2>`` can be either vectors or scalars. When ``<src1>`` or ``<src2>`` is a vector, the element number of ``<dst>`` and ``<src0>`` must be a multiple of that of ``<src1>`` and ``<src2>``. ``<src1>`` and ``<src2>`` will be implicitly extended with copies of itself to have the same element number as ``<dst>`` and ``<src0>``;
 * - ``<dst>`` and ``<src0>`` can be homologous operands;
 * - ``<dst_src0_elem_count>`` and ``<src1_src2_elem_count>`` must be greater than one;
 *
 * @par
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_binary_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define BUF_SIZE 128
 *
 *   __mlu_entry__ void kernel(float *mlu_dst,
 *                             float *mlu_src0,
 *                             float *mlu_src1,
 *                             float *mlu_src2) {
 *       __nram__ float nram_output[BUF_SIZE];
 *       __nram__ float nram_input0[BUF_SIZE];
 *       __nram__ float nram_input1[BUF_SIZE];
 *       __nram__ float nram_input2[BUF_SIZE];
 *       __memcpy(nram_input0, mlu_src0, BUF_SIZE * sizeof(float), GDRAM2NRAM);
 *       __memcpy(nram_input1, mlu_src1, BUF_SIZE * sizeof(float), GDRAM2NRAM);
 *       __memcpy(nram_input2, mlu_src2, BUF_SIZE * sizeof(float), GDRAM2NRAM);
 *       __bang_fusion(FUSION_FMA, nram_output, nram_input0,
 *                     nram_input1, nram_input2, BUF_SIZE, BUF_SIZE);
 *       __memcpy(mlu_dst, nram_output, BUF_SIZE, NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_fusion(mluFusionOpCode op_code,
                                                       float* dst,
                                                       float* src0,
                                                       float* src1,
                                                       float* src2,
                                                       int dst_src0_elem_count,
                                                       int src1_src2_elem_count);

//Group:Stream Comparison Functions
static __mlu_func__ __mlu_builtin__ void __bang_eq(half* dst,
                                                   half* src0,
                                                   half* src1,
                                                   int elem_count);

//Group:Stream Comparison Functions
/**
 * @brief Performs equality comparison with two vectors element-wisely.
 *
 * @details The function performs equality comparison with ``<src0>`` and ``<src1>`` and saves the result in ``<dst>``. If the element of ``<src0>`` and the element of ``<src1>`` are equal, the result is 1.0. Otherwise, the result is 0.0. The type of result is same as the type of the element of ``<src0>`` and ``<src1>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src0 The address of the first source vector.
 * @param[in] src1 The address of the second source vector.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<src0>`` , ``<src1>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<elem_count>`` * ``sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The address of ``<src0>``, ``<src1>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>``, ``<src0>`` and ``<src1>`` can be homologous operands;
 * - ``<elem_count>`` must be greater than zero;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *  #include <bang.h>
 *
 *   #define DATA_SIZE 128
 *
 *   __mlu_entry__ void kernel(float* c, float* a, float* b) {
 *     __nram__ float a_tmp[DATA_SIZE];
 *     __nram__ float c_tmp[DATA_SIZE];
 *     __nram__ float b_tmp[DATA_SIZE];
 *     __memcpy(a_tmp, a, DATA_SIZE * sizeof(float), GDRAM2NRAM);
 *     __memcpy(b_tmp, b, DATA_SIZE * sizeof(float), GDRAM2NRAM);
 *     __bang_eq(c_tmp, a_tmp, b_tmp, DATA_SIZE);
 *     __memcpy(c, c_tmp, DATA_SIZE * sizeof(float), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_eq(float* dst,
                                                   float* src0,
                                                   float* src1,
                                                   int elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_eq(bfloat16_t* dst,
                                                   bfloat16_t* src0,
                                                   bfloat16_t* src1,
                                                   int elem_count);
//Group:Stream Comparison Functions
static __mlu_func__ __mlu_builtin__ void __bang_ne(half* dst,
                                                   half* src0,
                                                   half* src1,
                                                   int elem_count);

//Group:Stream Comparison Functions
/**
 * @brief Performs inequality comparison with two vectors element-wisely.
 *
 * @details The function performs inequality comparison with ``<src0>`` and ``<src1>`` element-wisely and saves the result in ``<dst>``. If the element of ``<src0>`` and the element of ``<src1>`` are not equal, the result is 1.0. Otherwise, the result is 0.0. The type of result is same as the type of the element of ``<src0>`` and ``<src1>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src0 The address of the first source vector.
 * @param[in] src1 The address of the second source vector.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<src0>`` , ``<src1>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<elem_count>`` * ``sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The address of ``<src0>``, ``<src1>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>``, ``<src0>`` and ``<src1>`` can be homologous operands;
 * - ``<elem_count>`` must be greater than zero;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * See the example of ::__bang_eq for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_ne(float* dst,
                                                   float* src0,
                                                   float* src1,
                                                   int elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_ne(bfloat16_t* dst,
                                                   bfloat16_t* src0,
                                                   bfloat16_t* src1,
                                                   int elem_count);
//Group:Stream Comparison Functions
static __mlu_func__ __mlu_builtin__ void __bang_gt(half* dst,
                                                   half* src0,
                                                   half* src1,
                                                   int elem_count);

//Group:Stream Comparison Functions
/**
 * @brief Compares with two vectors element-wisely to determine whether the element in one vector is greater than that in the other.
 *
 * @details The function compares with ``<elem_count>`` elements in ``<src0>`` and ``<src1>`` element-wisely to determine whether the element in ``<src0>`` is greater than that in ``<src1>`` and saves the result in ``<dst>``. If the element of ``<src0>`` is greater than the element of ``<src1>``, the result is 1.0. Otherwise, the result is 0.0. The type of result is same as the type of the element of ``<src0>`` and ``<src1>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src0 The address of the first vector.
 * @param[in] src1 The address of the second vector.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<src0>`` , ``<src1>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<elem_count>`` * ``sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The address of ``<src0>``, ``<src1>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>``, ``<src0>`` and ``<src1>`` can be homologous operands;
 * - ``<elem_count>`` must be greater than zero;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * See the example of ::__bang_eq for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_gt(float* dst,
                                                   float* src0,
                                                   float* src1,
                                                   int elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_gt(bfloat16_t* dst,
                                                   bfloat16_t* src0,
                                                   bfloat16_t* src1,
                                                   int elem_count);
//Group:Stream Comparison Functions
static __mlu_func__ __mlu_builtin__ void __bang_ge(half* dst,
                                                   half* src0,
                                                   half* src1,
                                                   int elem_count);

//Group:Stream Comparison Functions
/**
 * @brief Compares with two vectors element-wisely to determine whether the element in one vector is greater than or equal to that in the other.
 *
 * @details The function compares with ``<elem_count>`` elements in ``<src0>`` and ``<src1>`` element-wisely to determine whether the element in ``<src0>`` is greater than or equal to that in ``<src1>`` and saves the result in ``<dst>``. If the element of ``<src0>`` is greater than or equal to the element of ``<src1>``, the result is 1.0. Otherwise, the result is 0.0. The type of result is same as the type of the element of ``<src0>`` and ``<src1>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src0 The address of the first vector.
 * @param[in] src1 The address of the second vector.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<src0>`` , ``<src1>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<elem_count>`` * ``sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The address of ``<src0>``, ``<src1>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>``, ``<src0>`` and ``<src1>`` can be homologous operands;
 * - ``<elem_count>`` must be greater than zero;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * See the example of ::__bang_eq for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_ge(float* dst,
                                                   float* src0,
                                                   float* src1,
                                                   int elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_ge(bfloat16_t* dst,
                                                   bfloat16_t* src0,
                                                   bfloat16_t* src1,
                                                   int elem_count);
//Group:Stream Comparison Functions
static __mlu_func__ __mlu_builtin__ void __bang_lt(half* dst,
                                                   half* src0,
                                                   half* src1,
                                                   int elem_count);

//Group:Stream Comparison Functions
/**
 * @brief Compares with two vectors element-wisely to determine whether the element in one vector is less than that in the other.
 *
 * @details The function compares with ``<elem_count>`` elements in ``<src0>`` and ``<src1>`` element-wisely to determine whether the element in ``<src0>`` is less than that in ``<src1>`` and saves the result in ``<dst>``. If the element of ``<src0>`` is less than the element of ``<src1>``, the result is 1.0. Otherwise, the result is 0.0. The type of result is same as the type of the element of ``<src0>`` and ``<src1>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src0 The address of the first vector.
 * @param[in] src1 The address of the second vector.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<src0>`` , ``<src1>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<elem_count>`` * ``sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The address of ``<src0>``, ``<src1>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>``, ``<src0>`` and ``<src1>`` can be homologous operands;
 * - ``<elem_count>`` must be greater than zero;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * See the example of ::__bang_eq for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_lt(float* dst,
                                                   float* src0,
                                                   float* src1,
                                                   int elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_lt(bfloat16_t* dst,
                                                   bfloat16_t* src0,
                                                   bfloat16_t* src1,
                                                   int elem_count);
//Group:Stream Comparison Functions
static __mlu_func__ __mlu_builtin__ void __bang_le(half* dst,
                                                   half* src0,
                                                   half* src1,
                                                   int elem_count);

//Group:Stream Comparison Functions
/**
 * @brief Compares with two vectors element-wisely to determine whether the element in one vector is less than or equal to that in the other.
 *
 * @details The function compares with ``<elem_count>`` elements in ``<src0>`` and ``<src1>`` element-wisely to determine whether the element in ``<src0>`` is less than or equal to that in ``<src1>`` and saves the result in ``<dst>``. If the element of ``<src0>`` is less than or equal to the element of ``<src1>``, the result is 1.0. Otherwise, the result is 0.0. The type of result is same as the type of the element of ``<src0>`` and ``<src1>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src0 The address of the first vector.
 * @param[in] src1 The address of the second vector.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<src0>`` , ``<src1>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<elem_count>`` * ``sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The address of ``<src0>``, ``<src1>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>``, ``<src0>`` and ``<src1>`` can be homologous operands;
 * - ``<elem_count>`` must be greater than zero;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * See the example of ::__bang_eq for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_le(float* dst,
                                                   float* src0,
                                                   float* src1,
                                                   int elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_le(bfloat16_t* dst,
                                                   bfloat16_t* src0,
                                                   bfloat16_t* src1,
                                                   int elem_count);
//Group:Stream Comparison Functions
static __mlu_func__ __mlu_builtin__ void __bang_eq_bitindex(half* dst,
                                                            half* src0,
                                                            half* src1,
                                                            int elem_count);

//Group:Stream Comparison Functions
/**
 * @brief Performs equality comparison with two vectors element-wisely. The results are in the form of bits.
 *
 * @details The function performs equality comparison with ``<src0>`` and ``<src1>`` element-wisely. If the two elements are equal, the result is 1. Otherwise, the result is 0. The result will be sequentially saved in ``<dst>``.
 * \rst
 * The comparison process is illustrated in the figure below, the comparison result between the first element ``<element0>`` of ``<src0>`` and the first element ``<element0>`` of ``<src1>`` will be saved in ``<bit0>`` of ``<dst>`` . The other elements do the same comparison in turn.
 *
 *   .. figure:: ../img/bang_eq_bitindex.*
 *      :scale: 60%
 *
 *      The Calculation Process of Half Type ``__bang_eq_bitindex``
 *
 * \endrst
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src0 The address of the first source vector.
 * @param[in] src1 The address of the second source vector.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<src0>`` , ``<src1>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<elem_count>`` * ``sizeof(type)`` must be divisible by 512 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The address of ``<src0>``, ``<src1>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>``, ``<src0>`` and ``<src1>`` can be homologous operands;
 * - ``<elem_count>`` must be greater than zero;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *  #include <bang.h>
 *
 *   #define DATA_SIZE 128
 *
 *   __mlu_entry__ void kernel(float* c, float* a, float* b) {
 *     __nram__ float a_tmp[DATA_SIZE];
 *     __nram__ float c_tmp[DATA_SIZE];
 *     __nram__ float b_tmp[DATA_SIZE];
 *     __memcpy(a_tmp, a, DATA_SIZE * sizeof(float), GDRAM2NRAM);
 *     __memcpy(b_tmp, b, DATA_SIZE * sizeof(float), GDRAM2NRAM);
 *     __bang_eq_bitindex(c_tmp, a_tmp, b_tmp, DATA_SIZE);
 *     __memcpy(c, c_tmp, DATA_SIZE * sizeof(float), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_eq_bitindex(float* dst,
                                                            float* src0,
                                                            float* src1,
                                                            int elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_eq_bitindex(bfloat16_t* dst,
                                                            bfloat16_t* src0,
                                                            bfloat16_t* src1,
                                                            int elem_count);
//Group:Stream Comparison Functions
static __mlu_func__ __mlu_builtin__ void __bang_ne_bitindex(half* dst,
                                                            half* src0,
                                                            half* src1,
                                                            int elem_count);

//Group:Stream Comparison Functions
/**
 * @brief Performs inequality comparison with two vectors element-wisely. The results are in the form of bits.
 *
 * @details The function performs inequality comparison with ``<src0>`` and ``<src1>`` element-wisely. If the two elements are not equal, the result is 1. Otherwise, the result is 0. The result will be sequentially saved in ``<dst>``.
 * \rst
 * The comparison process is illustrated in the figure below, the comparison result between the first element ``<element0>`` of ``<src0>`` and the first element ``<element0>`` of ``<src1>`` will be saved in ``<bit0>`` of ``<dst>`` . The other elements do the same comparison in turn.
 *
 *   .. figure:: ../img/bang_ne_bitindex.*
 *      :scale: 60%
 *
 *      The Calculation Process of Half Type ``__bang_ne_bitindex``
 *
 * \endrst
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src0 The address of the first source vector.
 * @param[in] src1 The address of the second source vector.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<src0>`` , ``<src1>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<elem_count>`` * ``sizeof(type)`` must be divisible by 512 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The address of ``<src0>``, ``<src1>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>``, ``<src0>`` and ``<src1>`` can be homologous operands;
 * - ``<elem_count>`` must be greater than zero;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * See the example of ::__bang_eq_bitindex for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_ne_bitindex(float* dst,
                                                            float* src0,
                                                            float* src1,
                                                            int elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_ne_bitindex(bfloat16_t* dst,
                                                            bfloat16_t* src0,
                                                            bfloat16_t* src1,
                                                            int elem_count);
//Group:Stream Comparison Functions
static __mlu_func__ __mlu_builtin__ void __bang_gt_bitindex(half* dst,
                                                            half* src0,
                                                            half* src1,
                                                            int elem_count);

//Group:Stream Comparison Functions
/**
 * @brief Compares with two vectors element-wisely to determine whether the element in one vector is greater than that in the other. The results are in the form of bits.
 *
 * @details The function compares with ``<elem_count>`` elements in ``<src0>`` and ``<src1>`` element-wisely, if the element of ``<src0>`` is greater than that of ``<src1>``, the result is 1. Otherwise, the result is 0. The result will be sequentially saved in ``<dst>``.
 * \rst
 * The comparison process is illustrated in the figure below, the comparison result between the first element ``<element0>`` of ``<src0>`` and the first element ``<element0>`` of ``<src1>`` will be saved in ``<bit0>`` of ``<dst>`` . The other elements do the same comparison in turn.
 *
 *   .. figure:: ../img/bang_gt_bitindex.*
 *      :scale: 60%
 *
 *      The Calculation Process of Half Type ``__bang_gt_bitindex``
 *
 * \endrst
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src0 The address of the first source vector.
 * @param[in] src1 The address of the second source vector.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<src0>`` , ``<src1>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<elem_count>`` * ``sizeof(type)`` must be divisible by 512 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The address of ``<src0>``, ``<src1>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>``, ``<src0>`` and ``<src1>`` can be homologous operands;
 * - ``<elem_count>`` must be greater than zero;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * See the example of ::__bang_eq_bitindex for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_gt_bitindex(float* dst,
                                                            float* src0,
                                                            float* src1,
                                                            int elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_gt_bitindex(bfloat16_t* dst,
                                                            bfloat16_t* src0,
                                                            bfloat16_t* src1,
                                                            int elem_count);
//Group:Stream Comparison Functions
static __mlu_func__ __mlu_builtin__ void __bang_ge_bitindex(half* dst,
                                                            half* src0,
                                                            half* src1,
                                                            int elem_count);

//Group:Stream Comparison Functions
/**
 * @brief Compares with two vectors element-wisely to determine whether the element in one vector is greater than or equal to that in the other. The results are in the form of bits.
 *
 * @details The function compares with ``<elem_count>`` elements in ``<src0>`` and ``<src1>`` element-wisely, if the element of ``<src0>`` is greater than or equal to that of ``<src1>``, the result is 1. Otherwise, the result is 0. The result will be sequentially saved in ``<dst>``.
 * \rst
 * The comparison process is illustrated in the figure below, the comparison result between the first element ``<element0>`` of ``<src0>`` and the first element ``<element0>`` of ``<src1>`` will be saved in ``<bit0>`` of ``<dst>`` . The other elements do the same comparison in turn.
 *
 *   .. figure:: ../img/bang_ge_bitindex.*
 *      :scale: 60%
 *
 *      The Calculation Process of Half Type ``__bang_ge_bitindex``
 *
 * \endrst
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src0 The address of the first source vector.
 * @param[in] src1 The address of the second source vector.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<src0>`` , ``<src1>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<elem_count>`` * ``sizeof(type)`` must be divisible by 512 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The address of ``<src0>``, ``<src1>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>``, ``<src0>`` and ``<src1>`` can be homologous operands;
 * - ``<elem_count>`` must be greater than zero;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * See the example of ::__bang_eq_bitindex for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_ge_bitindex(float* dst,
                                                            float* src0,
                                                            float* src1,
                                                            int elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_ge_bitindex(bfloat16_t* dst,
                                                            bfloat16_t* src0,
                                                            bfloat16_t* src1,
                                                            int elem_count);
//Group:Stream Comparison Functions
static __mlu_func__ __mlu_builtin__ void __bang_lt_bitindex(half* dst,
                                                            half* src0,
                                                            half* src1,
                                                            int elem_count);

//Group:Stream Comparison Functions
/**
 * @brief Compares with two vectors element-wisely to determine whether the element in one vector is less than that in the other. The results are in the form of bits.
 *
 * @details The function compares with ``<elem_count>`` elements in ``<src0>`` and ``<src1>`` element-wisely, if the element of ``<src0>`` is less than that of ``<src1>``, the result is 1. Otherwise, the result is 0. The result will be sequentially saved in ``<dst>``.
 * \rst
 * The comparison process is illustrated in the figure below, the comparison result between the first element ``<element0>`` of ``<src0>`` and the first element ``<element0>`` of ``<src1>`` will be saved in ``<bit0>`` of ``<dst>`` . The other elements do the same comparison in turn.
 *
 *   .. figure:: ../img/bang_lt_bitindex.*
 *      :scale: 60%
 *
 *      The Calculation Process of Half Type ``__bang_lt_bitindex``
 *
 * \endrst
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src0 The address of the first source vector.
 * @param[in] src1 The address of the second source vector.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<src0>`` , ``<src1>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<elem_count>`` * ``sizeof(type)`` must be divisible by 512 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The address of ``<src0>``, ``<src1>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>``, ``<src0>`` and ``<src1>`` can be homologous operands;
 * - ``<elem_count>`` must be greater than zero;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * See the example of ::__bang_eq_bitindex for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_lt_bitindex(float* dst,
                                                            float* src0,
                                                            float* src1,
                                                            int elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_lt_bitindex(bfloat16_t* dst,
                                                            bfloat16_t* src0,
                                                            bfloat16_t* src1,
                                                            int elem_count);
//Group:Stream Comparison Functions
static __mlu_func__ __mlu_builtin__ void __bang_le_bitindex(half* dst,
                                                            half* src0,
                                                            half* src1,
                                                            int elem_count);

//Group:Stream Comparison Functions
/**
 * @brief Compares with two vectors element-wisely to determine whether the element in one vector is less than or equal to that in the other. The results are in the form of bits.
 *
 * @details The function compares with ``<elem_count>`` elements in ``<src0>`` and ``<src1>`` element-wisely, if the element of ``<src0>`` is less than or equal to that of ``<src1>``, the result is 1. Otherwise, the result is 0. The result will be sequentially saved in ``<dst>``.
 * \rst
 * The comparison process is illustrated in the figure below, the comparison result between the first element ``<element0>`` of ``<src0>`` and the first element ``<element0>`` of ``<src1>`` will be saved in ``<bit0>`` of ``<dst>`` . The other elements do the same comparison in turn.
 *
 *   .. figure:: ../img/bang_le_bitindex.*
 *      :scale: 60%
 *
 *      The Calculation Process of Half Type ``__bang_le_bitindex``
 *
 * \endrst
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src0 The address of the first source vector.
 * @param[in] src1 The address of the second source vector.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<src0>`` , ``<src1>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<elem_count>`` * ``sizeof(type)`` must be divisible by 512 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The address of ``<src0>``, ``<src1>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>``, ``<src0>`` and ``<src1>`` can be homologous operands;
 * - ``<elem_count>`` must be greater than zero;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * See the example of ::__bang_eq_bitindex for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_le_bitindex(float* dst,
                                                            float* src0,
                                                            float* src1,
                                                            int elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_le_bitindex(bfloat16_t* dst,
                                                            bfloat16_t* src0,
                                                            bfloat16_t* src1,
                                                            int elem_count);
//Group:Stream Fusion Functions
static __mlu_func__ __mlu_builtin__ void __bang_fabsmax(half* dst,
                                                        half* src,
                                                        int elem_count);

static __mlu_func__ __mlu_builtin__ void __bang_fabsmax(bfloat16_t* dst,
                                                        bfloat16_t* src,
                                                        int elem_count);

//Group:Stream Fusion Functions
/**
 * @brief Finds the maximum absolute value of the source vector.
 *
 * @details The function performs calculation of the absolute value of ``<src>`` element-wisely, then finds the maximum absolute value and its position index, and saves the maximum absolute value and its index in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<dst>`` and ``<src>`` must point to ``__nram__`` space;
 * - For ``half`` type, the first 2 bytes of ``<dst>`` are used to record the maximum absolute value (``half`` type), and the next 8 bytes are occupied as an index to locate the position of the value. Only the low 22 bits of the 8 bytes index are valid as an integer index, and the high 42 bits are all written to zero;
 * - For ``float`` type, the first 4 bytes of ``<dst>`` are used to record the maximum absolute value (``float`` type), and the next 8 bytes are occupied as an index to locate the position of the value. Only the low 26 bits of the 8 bytes index are valid as an integer index, and the high 38 bits are all written to zero;
 * - ``<dst>`` will occupy 10 bytes for half type and 12 bytes for float type;
 * - When ``<src>`` vector has multiple same maximum absolute values, only the first one and its index will be stored;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - ``<elem_count>`` must be greater than zero;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_operation_functions_with_elementwise` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define RES_ELEM_NUM 16
 *   #define ELEM_NUM 128
 *
 *   __mlu_entry__ void kernel_fabs(float* dst, float *src) {
 *     __nram__ float dst_nram[RES_ELEM_NUM];
 *     __nram__ float src_nram[ELEM_NUM];
 *     __memcpy(src_nram, src, ELEM_NUM * sizeof(float), GDRAM2NRAM);
 *     __bang_fabsmax(dst_nram, src_nram, ELEM_NUM);
 *     __memcpy(dst, dst_nram, RES_ELEM_NUM * sizeof(float), NRAM2GDRAM);
 *   }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_fabsmax(float* dst,
                                                        float* src,
                                                        int elem_count);

//Group:Stream Fusion Functions
static __mlu_func__ __mlu_builtin__ void __bang_fabsmin(half* dst,
                                                        half* src,
                                                        int elem_count);

static __mlu_func__ __mlu_builtin__ void __bang_fabsmin(bfloat16_t* dst,
                                                        bfloat16_t* src,
                                                        int elem_count);

//Group:Stream Fusion Functions
/**
 * @brief Finds the minimum absolute value of the source vector.
 *
 * @details The function performs calculation of the absolute value of ``<src>`` element-wisely, then finds the minimum absolute value and its position index, and saves the minimum absolute value and its index in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<dst>`` and ``<src>`` must point to ``__nram__`` space;
 * - For ``half`` type, the first 2 bytes of ``<dst>`` are used to record the minimum absolute value (``half`` type), and the next 8 bytes are occupied as an index to locate the position of the value. Only the low 22 bits of the 8 bytes index are valid as an integer index, and the high 42 bits are all written to zero;
 * - For ``float`` type, the first 4 bytes of ``<dst>`` are used to record the minimum absolute value (``float`` type), and the next 8 bytes are occupied as an index to locate the position of the value. Only the low 26 bits of the 8 bytes index are valid as an integer index, and the high 38 bits are all written to zero;
 * - ``<dst>`` will occupy 10 bytes for half type and 12 bytes for float type;
 * - When ``<src>`` vector has multiple same minimum absolute values, only the first one and its index will be stored;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - ``<elem_count>`` must be greater than zero;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_operation_functions_with_elementwise` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * See the example of ::__bang_fabsmax for more details.
*/
static __mlu_func__ __mlu_builtin__ void __bang_fabsmin(float* dst,
                                                        float* src,
                                                        int elem_count);

//Group:Stream Fusion Functions
static __mlu_func__ __mlu_builtin__ void __bang_fcmpfilter(CompareMode mode,
                                                           half* dst,
                                                           half* src0,
                                                           half* src1,
                                                           int elem_count);

//Group:Stream Fusion Functions
static __mlu_func__ __mlu_builtin__ void __bang_fcmpfilter(CompareMode mode,
                                                           half* dst,
                                                           half* src0,
                                                           half src1,
                                                           int elem_count);

//Group:Stream Fusion Functions
static __mlu_func__ __mlu_builtin__ void __bang_fcmpfilter(CompareMode mode,
                                                           float* dst,
                                                           float* src0,
                                                           float* src1,
                                                           int elem_count);

static __mlu_func__ __mlu_builtin__ void __bang_fcmpfilter(CompareMode mode,
                                                           bfloat16_t* dst,
                                                           bfloat16_t* src0,
                                                           bfloat16_t src1,
                                                           int elem_count);

static __mlu_func__ __mlu_builtin__ void __bang_fcmpfilter(CompareMode mode,
                                                           bfloat16_t* dst,
                                                           bfloat16_t* src0,
                                                           bfloat16_t* src1,
                                                           int elem_count);

//Group:Stream Fusion Functions
/**
 * @brief Compares two inputs element-wisely according to the given mode.
 *
 * @details The function performs comparison with ``<src0>`` and ``<src1>`` element-wisely according to ``<mode>`` and saves the result in ``<dst>``. ``<mode>`` indicates the type of comparison. ``<mode>`` is assigned to an enumerated type called ``CompareMode`` that contains six enumerators listed in the table below.
 * \rst
 *
 * .. tabularcolumns:: |m{0.45\textwidth}|m{0.45\textwidth}|
 * .. table::  Semantics of ``CompareMode``
 *
 *    +------------------------+--------------------------+
 *    | ``CompareMode`` Type   |         Semantic         |
 *    +========================+==========================+
 *    | ``CMP_EQ``             |      :math:`=`           |
 *    +------------------------+--------------------------+
 *    | ``CMP_NE``             |      :math:`\neq`        |
 *    +------------------------+--------------------------+
 *    | ``CMP_LT``             |      :math:`<`           |
 *    +------------------------+--------------------------+
 *    | ``CMP_LE``             |      :math:`\leq`        |
 *    +------------------------+--------------------------+
 *    | ``CMP_GT``             |      :math:`>`           |
 *    +------------------------+--------------------------+
 *    | ``CMP_GE``             |      :math:`\geq`        |
 *    +------------------------+--------------------------+
 *
 * \endrst
 *
 * @param[in] mode The comparison mode.
 * @param[out] dst The address of destination vector.
 * @param[in] src0 The address of the first source vector.
 * @param[in] src1 The address of the second source vector or the second source scalar.
 * @param[in] elem_count The number of elements in source vector.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - ``<src0>`` and ``<dst>`` must point to ``__nram__`` space. ``<src1>`` must also point to ``__nram__`` space if it is a vector;
 * - ``<src1>`` can be either vectors or scalars. When ``<src1>`` is a vector, the length of ``<src1>`` must be the same as that of ``<src0>``;
 * - ``<dst>`` and ``<src0>`` can be homologous operands;
 * - ``<elem_count>`` must be greater than zero;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - BANG Version: ``__BANG_ARCH__ >= 322``;
 *     - CNCC Version: ``cncc --version >= 3.0.0``;
 *     - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *     - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define ELEM_NUM 128
 *   #define RES_ELEM_NUM (ELEM_NUM + 4)
 *
 *   __mlu_entry__ void kernel_fabs(CompareMode mode, float* dst,
 *                                  float *src0, float *src1) {
 *     __nram__ float dst_nram[RES_ELEM_NUM];
 *     __nram__ float src0_nram[ELEM_NUM];
 *     __nram__ float src1_nram[ELEM_NUM];
 *     __memcpy(src0_nram, src0, ELEM_NUM * sizeof(float), GDRAM2NRAM);
 *     __memcpy(src1_nram, src1, ELEM_NUM * sizeof(float), GDRAM2NRAM);
 *     __bang_fcmpfilter(mode, dst_nram, src0_nram, src1_nram, ELEM_NUM);
 *     __memcpy(dst, dst_nram, RES_ELEM_NUM * sizeof(float), NRAM2GDRAM);
 *  }
 *
 * @endcode
*/
static __mlu_func__ __mlu_builtin__ void __bang_fcmpfilter(CompareMode mode,
                                                           float* dst,
                                                           float* src0,
                                                           float src1,
                                                           int elem_count);

//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_or(half* dst,
                                                   half* src0,
                                                   half* src1,
                                                   int elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_or(int* dst,
                                                   int* src0,
                                                   int* src1,
                                                   int elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_or(short* dst,
                                                   short* src0,
                                                   short* src1,
                                                   int elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_or(char* dst,
                                                   char* src0,
                                                   char* src1,
                                                   int elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_or(bfloat16_t* dst,
                                                   bfloat16_t* src0,
                                                   bfloat16_t* src1,
                                                   int elem_count);
//Group:Stream Logic and Bit Operation Functions
/**
 * @brief Performs logical OR operation between elements in two vectors. If both the elements of ``<src0>`` and ``<src1>`` are zero, the result is 0. Otherwise, the result is 1. The type of result is the same as that of ``<src0>`` and ``<src1>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src0 The address of first source vector.
 * @param[in] src1 The address of second source vector.
 * @param[in] elem_count The elements number of source vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``float`` is supported on ``(m)tp_2xx`` and higher;
 * - ``int``, ``short`` and ``char`` are supported on ``(m)tp_3xx`` and higher;
 * - ``<elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<src0>``, ``<src1>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src0>``, ``<src1>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_binary_logic_and_bit_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_or(float* dst,
                                                   float* src0,
                                                   float* src1,
                                                   int elem_count);

//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_and(half* dst,
                                                    half* src0,
                                                    half* src1,
                                                    int elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_and(int* dst,
                                                    int* src0,
                                                    int* src1,
                                                    int elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_and(short* dst,
                                                    short* src0,
                                                    short* src1,
                                                    int elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_and(char* dst,
                                                    char* src0,
                                                    char* src1,
                                                    int elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_and(bfloat16_t* dst,
                                                    bfloat16_t* src0,
                                                    bfloat16_t* src1,
                                                    int elem_count);
//Group:Stream Logic and Bit Operation Functions
/**
 * @brief Performs logical AND operation between elements in two vectors. If both the elements of ``<src0>`` and ``<src1>`` are non-zero, the result is 1. Otherwise, the result is 0. The type of result is the same as that of ``<src0>`` and ``<src1>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src0 The address of first source vector.
 * @param[in] src1 The address of second source vector.
 * @param[in] elem_count The elements number of source vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``float`` is supported on ``(m)tp_2xx`` and higher;
 * - ``int``, ``short`` and ``char`` are supported on ``(m)tp_3xx`` and higher;
 * - ``<elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<src0>``, ``<src1>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src0>``, ``<src1>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src0>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_binary_logic_and_bit_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *    #include <bang.h>
 *
 *    #define DATA_SIZE 128
 *
 *    __mlu_entry__ void kernel(half* c, half* a, half* b) {
 *      __nram__ half a_tmp[DATA_SIZE];
 *      __nram__ half c_tmp[DATA_SIZE];
 *      __nram__ half b_tmp[DATA_SIZE];
 *      __memcpy(a_tmp, a, DATA_SIZE * sizeof(half), GDRAM2NRAM);
 *      __memcpy(b_tmp, b, DATA_SIZE * sizeof(half), GDRAM2NRAM);
 *      __bang_and(c_tmp, a_tmp, b_tmp, DATA_SIZE);
 *      __memcpy(c, c_tmp, DATA_SIZE * sizeof(half), NRAM2GDRAM);
 *    }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_and(float* dst,
                                                    float* src0,
                                                    float* src1,
                                                    int elem_count);

//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_xor(half* dst,
                                                    half* src0,
                                                    half* src1,
                                                    int elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_xor(int* dst,
                                                    int* src0,
                                                    int* src1,
                                                    int elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_xor(short* dst,
                                                    short* src0,
                                                    short* src1,
                                                    int elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_xor(char* dst,
                                                    char* src0,
                                                    char* src1,
                                                    int elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_xor(bfloat16_t* dst,
                                                    bfloat16_t* src0,
                                                    bfloat16_t* src1,
                                                    int elem_count);
//Group:Stream Logic and Bit Operation Functions
/**
 * @brief Performs logical XOR operation between elements in two vectors. If both the elements of ``<src0>`` and ``<src1>`` are zero or non-zero, the result is 0. Otherwise, the result is 1. The type of result is the same as that of ``<src0>`` and ``<src1>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src0 The address of first source vector.
 * @param[in] src1 The address of second source vector.
 * @param[in] elem_count The elements number of source vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``float`` is supported on ``(m)tp_2xx`` and higher;
 * - ``int``, ``short`` and ``char`` are supported on ``(m)tp_3xx`` and higher;
 * - ``<elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<src0>``, ``<src1>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src0>``, ``<src1>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src0>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_binary_logic_and_bit_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *    #include <bang.h>
 *
 *    #define DATA_SIZE 128
 *
 *    __mlu_entry__ void kernel(half* c, half* a, half* b) {
 *      __nram__ half a_tmp[DATA_SIZE];
 *      __nram__ half c_tmp[DATA_SIZE];
 *      __nram__ half b_tmp[DATA_SIZE];
 *      __memcpy(a_tmp, a, DATA_SIZE * sizeof(half), GDRAM2NRAM);
 *      __memcpy(b_tmp, b, DATA_SIZE * sizeof(half), GDRAM2NRAM);
 *      __bang_xor(c_tmp, a_tmp, b_tmp, DATA_SIZE);
 *      __memcpy(c, c_tmp, DATA_SIZE * sizeof(half), NRAM2GDRAM);
 *    }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_xor(float* dst,
                                                    float* src0,
                                                    float* src1,
                                                    int elem_count);

//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_bor(int* dst,
                                                    int* src0,
                                                    int* src1,
                                                    int elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_bor(short* dst,
                                                    short* src0,
                                                    short* src1,
                                                    int elem_count);
//Group:Stream Logic and Bit Operation Functions
/**
 * @brief Applies bit-wise OR operation on two vectors.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src0 The address of first source vector.
 * @param[in] src1 The address of second source vector.
 * @param[in] elem_count The elements number of source vector.
 * @return ``void``.
 * @remark
 * - ``int`` and ``short`` are supported on ``(m)tp_3xx`` and higher;
 * - ``<elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_2xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<src0>``, ``<src1>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src0>``, ``<src1>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src0>`` can be homologous operands.
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_bor(char* dst,
                                                    char* src0,
                                                    char* src1,
                                                    int elem_count);

//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_band(int* dst,
                                                     int* src0,
                                                     int* src1,
                                                     int elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_band(short* dst,
                                                     short* src0,
                                                     short* src1,
                                                     int elem_count);
//Group:Stream Logic and Bit Operation Functions
/**
 * @brief Applies bit-wise AND operation on two vectors.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src0 The address of first source vector.
 * @param[in] src1 The address of second source vector.
 * @param[in] elem_count The elements number of source vector.
 * @return ``void``.
 * @remark
 * - ``int`` and ``short`` are supported on ``(m)tp_3xx`` and higher;
 * - ``<elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_2xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<src0>``, ``<src1>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src0>``, ``<src1>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src0>`` can be homologous operands.
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * @code
 *
 *    #include <bang.h>
 *
 *    #define DATA_SIZE 128
 *
 *    __mlu_entry__ void kernel(char* c, char* a, char* b) {
 *      __nram__ char a_tmp[DATA_SIZE];
 *      __nram__ char c_tmp[DATA_SIZE];
 *      __nram__ char b_tmp[DATA_SIZE];
 *      __memcpy(a_tmp, a, DATA_SIZE, GDRAM2NRAM);
 *      __memcpy(b_tmp, b, DATA_SIZE, GDRAM2NRAM);
 *      __bang_band(c_tmp, a_tmp, b_tmp, DATA_SIZE);
 *      __memcpy(c, c_tmp, DATA_SIZE, NRAM2GDRAM);
 *    }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_band(char* dst,
                                                     char* src0,
                                                     char* src1,
                                                     int elem_count);

//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_bxor(int* dst,
                                                     int* src0,
                                                     int* src1,
                                                     int elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_bxor(short* dst,
                                                     short* src0,
                                                     short* src1,
                                                     int elem_count);
//Group:Stream Logic and Bit Operation Functions
/**
 * @brief Applies bit-wise XOR operation on two vectors.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src0 The address of first source vector.
 * @param[in] src1 The address of second source vector.
 * @param[in] elem_count The elements number of source vector.
 * @return ``void``.
 * @remark
 * - ``int`` and ``short`` are supported on ``(m)tp_3xx`` and higher;
 * - ``<elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_2xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<src0>``, ``<src1>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src0>``, ``<src1>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src0>`` can be homologous operands.
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_bxor(char* dst,
                                                     char* src0,
                                                     char* src1,
                                                     int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_bnot(int* dst,
                                                     int* src,
                                                     int elem_count);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_bnot(short* dst,
                                                     short* src,
                                                     int elem_count);

//Group:Stream Logic and Bit Operation Functions
/**
 * @brief Applies bit-wise NOT operation on a vector.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count The elements number of source vector.
 * @return ``void``.
 * @remark
 * - ``int`` and ``short`` are supported on ``(m)tp_3xx`` and higher;
 * - ``<elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_2xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src>`` can be homologous operands.
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_bnot(char* dst,
                                                     char* src,
                                                     int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_cycle_add(half* dst,
                                                          half* src,
                                                          half* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_cycle_add(bfloat16_t* dst,
                                                          bfloat16_t* src,
                                                          bfloat16_t* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count);
//Group:Stream Operation Functions
/**
 * @brief Adds two input vectors segment by segment.
 *
 * @details This function divides ``<src>`` into N parts ( ``N = <src_elem_count> / <seg_elem_count>`` ), adds each element in each part of ``<src>`` and the corresponding element in ``<seg>``, and assigns the result to ``<dst>``.
 *
 * \rst
 *
 *      .. figure:: ../img/11.7.*
 *
 *         Description of __bang_cycle_add Operation
 *
 * \endrst
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of first source vector.
 * @param[in] seg The address of second source vector.
 * @param[in] src_elem_count The elements number of ``<src>`` vector.
 * @param[in] seg_elem_count The elements number of ``<seg>`` vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<src_elem_count> * sizeof(type)`` and ``<seg_elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src_elem_count>`` must be divisible by ``<seg_elem_count>``;
 * - ``<src_elem_count>`` and ``<seg_elem_count>`` must be greater than zero;
 * - ``<src>``, ``<seg>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>``, ``<seg>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_binary_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *    #include <bang.h>
 *
 *    #define N1 256
 *    #define N2 65280
 *
 *    __mlu_entry__ void kernel(half* c, half* a, half* b) {
 *      __nram__ half a_tmp[N1];
 *      __nram__ half b_tmp[N2];
 *      __nram__ half c_tmp[N2];
 *      __memcpy(a_tmp, a, N1 * sizeof(half), GDRAM2NRAM);
 *      __memcpy(b_tmp, b, N2 * sizeof(half), GDRAM2NRAM);
 *      __bang_cycle_add(c_tmp, b_tmp, a_tmp, N2, N1);
 *      __memcpy(c, c_tmp, N2 * sizeof(half), NRAM2GDRAM);
 *    }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_cycle_add(float* dst,
                                                          float* src,
                                                          float* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_cycle_add_tz(half* dst,
                                                             half* src,
                                                             half* seg,
                                                             int src_elem_count,
                                                             int seg_elem_count);
//Group:Stream Operation Functions
/**
 * @brief Adds two input vectors segment by segment in round-to-zero mode.
 *
 * @details This function is calculated in the same way as ::__bang_cycle_add function.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of first source vector.
 * @param[in] seg The address of second source vector.
 * @param[in] src_elem_count The elements number of ``<src>`` vector.
 * @param[in] seg_elem_count The elements number of ``<seg>`` vector.
 * @return ``void``.
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_2xx`` and higher;
 * - ``<src_elem_count> * sizeof(type)`` and ``<seg_elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_2xx``;
 * - ``<src_elem_count>`` must be divisible by ``<seg_elem_count>``;
 * - ``<src_elem_count>`` and ``<seg_elem_count>`` must be greater than zero;
 * - ``<src>``, ``<seg>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>``, ``<seg>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_binary_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *    #include <bang.h>
 *
 *    #define N1 256
 *    #define N2 65280
 *
 *    __mlu_entry__ void kernel(half* c, half* a, half* b) {
 *      __nram__ half a_tmp[N1];
 *      __nram__ half b_tmp[N2];
 *      __nram__ half c_tmp[N2];
 *      __memcpy(a_tmp, a, N1 * sizeof(half), GDRAM2NRAM);
 *      __memcpy(b_tmp, b, N2 * sizeof(half), GDRAM2NRAM);
 *      __bang_cycle_add_tz(c_tmp, b_tmp, a_tmp, N2, N1);
 *      __memcpy(c, c_tmp, N2 * sizeof(half), NRAM2GDRAM);
 *    }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_cycle_add_tz(float* dst,
                                                             float* src,
                                                             float* seg,
                                                             int src_elem_count,
                                                             int seg_elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_cycle_sub(half* dst,
                                                          half* src,
                                                          half* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_cycle_sub(bfloat16_t* dst,
                                                          bfloat16_t* src,
                                                          bfloat16_t* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count);
//Group:Stream Operation Functions
/**
 * @brief Subtracts two input vectors segment by segment.
 *
 * @details This function divides ``<src>`` into N parts ( ``N = <src_elem_count> / <seg_elem_count>`` ), subtracts each element in each part of ``<src>`` and the corresponding element in ``<seg>``, and assigns the result to ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of first source vector.
 * @param[in] seg The address of second source vector.
 * @param[in] src_elem_count The elements number of ``<src>`` vector.
 * @param[in] seg_elem_count The elements number of ``<seg>`` vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<src_elem_count> * sizeof(type)`` and ``<seg_elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src_elem_count>`` must be divisible by ``<seg_elem_count>``;
 * - ``<src_elem_count>`` and ``<seg_elem_count>`` must be greater than zero;
 * - ``<src>``, ``<seg>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>``, ``<seg>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_binary_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_cycle_sub(float* dst,
                                                          float* src,
                                                          float* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count);

//Group:Stream Comparison Functions
static __mlu_func__ __mlu_builtin__ void __bang_maxequal(half* dst,
                                                         half* src0,
                                                         half* src1,
                                                         int elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_maxequal(bfloat16_t* dst,
                                                         bfloat16_t* src0,
                                                         bfloat16_t* src1,
                                                         int elem_count);
//Group:Stream Comparison Functions
/**
 * @brief Finds maximum value of each two corresponding elements in the two vectors.
 *
 * @details
 *
 * @param[out] dst The address of destination vector
 * @param[in] src0 The address of first source vector
 * @param[in] src1 The address of second source vector
 * @param[in] elem_count The elements number of source vector
 * @return ``void``.
 * @remark
 * \rst
 * - ``<elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_2xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<src0>``, ``<src1>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src0>``, ``<src1>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src0>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_operation_functions_with_elementwise` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_maxequal(float* dst,
                                                         float* src0,
                                                         float* src1,
                                                         int elem_count);

//Group:Stream Comparison Functions
static __mlu_func__ __mlu_builtin__ void __bang_minequal(half* dst,
                                                         half* src0,
                                                         half* src1,
                                                         int elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_minequal(bfloat16_t* dst,
                                                         bfloat16_t* src0,
                                                         bfloat16_t* src1,
                                                         int elem_count);
//Group:Stream Comparison Functions
/**
 * @brief Finds minimum value of each two corresponding elements in the two vectors.
 *
 * @details
 *
 * @param[out] dst The address of destination vector
 * @param[in] src0 The address of first source vector
 * @param[in] src1 The address of second source vector
 * @param[in] elem_count The elements number of source vector
 * @return ``void``.
 * @remark
 * \rst
 * - ``<elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_2xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<src0>``, ``<src1>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src0>``, ``<src1>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src0>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_operation_functions_with_elementwise` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * @code
 *
 *    #include <bang.h>
 *
 *    #define DATA_SIZE 64
 *
 *    __mlu_entry__ void kernel(half* c, half* a, half* b) {
 *      __nram__ half a_tmp[DATA_SIZE];
 *      __nram__ half c_tmp[DATA_SIZE];
 *      __nram__ half b_tmp[DATA_SIZE];
 *      __memcpy(a_tmp, a, DATA_SIZE * sizeof(half), GDRAM2NRAM);
 *      __memcpy(b_tmp, b, DATA_SIZE * sizeof(half), GDRAM2NRAM);
 *      __bang_minequal(c_tmp, a_tmp, b_tmp, DATA_SIZE);
 *      __memcpy(c, c_tmp, DATA_SIZE * sizeof(half), NRAM2GDRAM);
 *    }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_minequal(float* dst,
                                                         float* src0,
                                                         float* src1,
                                                         int elem_count);

//Group:Stream Comparison Functions
static __mlu_func__ __mlu_builtin__ void __bang_cycle_maxequal(half* dst,
                                                               half* src,
                                                               half* seg,
                                                               int src_elem_count,
                                                               int seg_elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_cycle_maxequal(bfloat16_t* dst,
                                                               bfloat16_t* src,
                                                               bfloat16_t* seg,
                                                               int src_elem_count,
                                                               int seg_elem_count);
//Group:Stream Comparison Functions
/**
 * @brief Divides ``<src>`` into ``<src_elem_count>`` / ``<seg_elem_count>`` parts. Each element in each part applies maxequal operation (select the maximum value) with the corresponding element in ``<seg>``. The result is assigned to ``<dst>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of first source vector.
 * @param[in] seg The address of second source vector.
 * @param[in] src_elem_count The elements number of ``<src>`` vector.
 * @param[in] seg_elem_count The elements number of ``<seg>`` vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<src_elem_count> * sizeof(type)`` and ``<seg_elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_2xx``;
 * - ``<src_elem_count>`` and ``<seg_elem_count>`` must be greater than zero;
 * - ``<src_elem_count>`` must be divisible by ``<seg_elem_count>``;
 * - ``<src>``, ``<seg>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>``, ``<seg>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_operation_functions_with_elementwise` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * @code
 *
 *    #include <bang.h>
 *
 *    #define N1 128
 *    #define N2 32640
 *
 *    __mlu_entry__ void kernel(float *c, float *a, float *b) {
 *      __nram__ float a_tmp[N1];
 *      __nram__ float b_tmp[N2];
 *      __nram__ float c_tmp[N2];
 *      __memcpy(a_tmp, a, N1 * sizeof(float), GDRAM2NRAM);
 *      __memcpy(b_tmp, b, N2 * sizeof(float), GDRAM2NRAM);
 *      __bang_cycle_maxequal(c_tmp, b_tmp, a_tmp, N2, N1);
 *      __memcpy(c, c_tmp, N2 * sizeof(float), NRAM2GDRAM);
 *    }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_cycle_maxequal(float* dst,
                                                               float* src,
                                                               float* seg,
                                                               int src_elem_count,
                                                               int seg_elem_count);

//Group:Stream Comparison Functions
static __mlu_func__ __mlu_builtin__ void __bang_cycle_minequal(half* dst,
                                                               half* src,
                                                               half* seg,
                                                               int src_elem_count,
                                                               int seg_elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_cycle_minequal(bfloat16_t* dst,
                                                               bfloat16_t* src,
                                                               bfloat16_t* seg,
                                                               int src_elem_count,
                                                               int seg_elem_count);
//Group:Stream Comparison Functions
/**
 * @brief Divides ``<src>`` into ``<src_elem_count>`` / ``<seg_elem_count>`` parts. Each element in each part applies minequal operation (select the minimum value) with the corresponding element in ``<seg>``. The result is assigned to ``<dst>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of first source vector.
 * @param[in] seg The address of second source vector.
 * @param[in] src_elem_count The elements number of ``<src>`` vector.
 * @param[in] seg_elem_count The elements number of ``<seg>`` vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<src_elem_count> * sizeof(type)`` and ``<seg_elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_2xx``;
 * - ``<src_elem_count>`` must be divisible by ``<seg_elem_count>``;
 * - ``<src_elem_count>`` and ``<seg_elem_count>`` must be greater than zero;
 * - ``<src>``, ``<seg>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>``, ``<seg>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_operation_functions_with_elementwise` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_cycle_minequal(float* dst,
                                                               float* src,
                                                               float* seg,
                                                               int src_elem_count,
                                                               int seg_elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_cycle_mul(half* dst,
                                                          half* src,
                                                          half* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_cycle_mul(bfloat16_t* dst,
                                                          bfloat16_t* src,
                                                          bfloat16_t* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count);
//Group:Stream Operation Functions
/**
 * @brief Multiplies two input vectors segment by segment.
 *
 * @details This function divides ``<src>`` into N parts ( ``N = <src_elem_count> / <seg_elem_count>`` ), multiplies each element in each part of ``<src>`` and the corresponding element in ``<seg>``, and assigns the result to ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of first source vector.
 * @param[in] seg The address of second source vector.
 * @param[in] src_elem_count The elements number of ``<src>`` vector.
 * @param[in] seg_elem_count The elements number of ``<seg>`` vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<src_elem_count> * sizeof(type)`` and ``<seg_elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src_elem_count>`` must be divisible by ``<seg_elem_count>``;
 * - ``<src_elem_count>`` and ``<seg_elem_count>`` must be greater than zero;
 * - ``<src>``, ``<seg>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>``, ``<seg>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_binary_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_cycle_mul(float* dst,
                                                          float* src,
                                                          float* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count);

//Group:Stream Comparison Functions
static __mlu_func__ __mlu_builtin__ void __bang_cycle_eq(half* dst,
                                                         half* src,
                                                         half* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count);
//Group:Stream Comparison Functions
/**
 * @brief Divides ``<src>`` into ``<src_elem_count>`` / ``<seg_elem_count>`` parts, then judges whether each element in each part and the corresponding element in ``<seg>`` are equal. The result is assigned to ``<dst>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of first source vector.
 * @param[in] seg The address of second source vector.
 * @param[in] src_elem_count The elements number of ``<src>`` vector.
 * @param[in] seg_elem_count The elements number of ``<seg>`` vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<src_elem_count> * sizeof(type)`` and ``<seg_elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src_elem_count>`` must be divisible by ``<seg_elem_count>``;
 * - ``<src_elem_count>`` and ``<seg_elem_count>`` must be greater than zero;
 * - ``<src>``, ``<seg>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>``, ``<seg>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *    #include <bang.h>
 *
 *    #define N1 128
 *    #define N2 32640
 *
 *    __mlu_entry__ void kernel(float* c, float* a, float* b) {
 *      __nram__ float a_tmp[N1];
 *      __nram__ float b_tmp[N2];
 *      __nram__ float c_tmp[N2];
 *      __memcpy(a_tmp, a, N1 * sizeof(float), GDRAM2NRAM);
 *      __memcpy(b_tmp, b, N2 * sizeof(float), GDRAM2NRAM);
 *      __bang_cycle_eq(c_tmp, b_tmp, a_tmp, N2, N1);
 *      __memcpy(c, c_tmp, N2 * sizeof(float), NRAM2GDRAM);
 *    }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_cycle_eq(float* dst,
                                                         float* src,
                                                         float* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_cycle_eq(bfloat16_t* dst,
                                                         bfloat16_t* src,
                                                         bfloat16_t* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count);
//Group:Stream Comparison Functions
static __mlu_func__ __mlu_builtin__ void __bang_cycle_ne(half* dst,
                                                         half* src,
                                                         half* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count);
//Group:Stream Comparison Functions
/**
 * @brief Divides ``<src>`` into ``<src_elem_count>`` / ``<seg_elem_count>`` parts, then judges whether each element in each part and the corresponding element in ``<seg>`` are NOT equal. The result is assigned to ``<dst>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of first source vector.
 * @param[in] seg The address of second source vector.
 * @param[in] src_elem_count The elements number of ``<src>`` vector.
 * @param[in] seg_elem_count The elements number of ``<seg>`` vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<src_elem_count> * sizeof(type)`` and ``<seg_elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src_elem_count>`` must be divisible by ``<seg_elem_count>``;
 * - ``<src_elem_count>`` and ``<seg_elem_count>`` must be greater than zero;
 * - ``<src>``, ``<seg>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>``, ``<seg>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_cycle_ne(float* dst,
                                                         float* src,
                                                         float* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_cycle_ne(bfloat16_t* dst,
                                                         bfloat16_t* src,
                                                         bfloat16_t* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count);
//Group:Stream Comparison Functions
static __mlu_func__ __mlu_builtin__ void __bang_cycle_gt(half* dst,
                                                         half* src,
                                                         half* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count);
//Group:Stream Comparison Functions
/**
 * @brief Divides ``<src>`` into ``<src_elem_count>`` / ``<seg_elem_count>`` parts, then judges whether each element in each part is greater than the corresponding element in ``<seg>``. The result is assigned to ``<dst>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of first source vector.
 * @param[in] seg The address of second source vector.
 * @param[in] src_elem_count The elements number of ``<src>`` vector.
 * @param[in] seg_elem_count The elements number of ``<seg>`` vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<src_elem_count> * sizeof(type)`` and ``<seg_elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src_elem_count>`` must be divisible by ``<seg_elem_count>``;
 * - ``<src_elem_count>`` and ``<seg_elem_count>`` must be greater than zero;
 * - ``<src>``, ``<seg>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>``, ``<seg>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_cycle_gt(float* dst,
                                                         float* src,
                                                         float* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_cycle_gt(bfloat16_t* dst,
                                                         bfloat16_t* src,
                                                         bfloat16_t* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count);
//Group:Stream Comparison Functions
static __mlu_func__ __mlu_builtin__ void __bang_cycle_ge(half* dst,
                                                         half* src,
                                                         half* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count);
//Group:Stream Comparison Functions
/**
 * @brief Divides ``<src>`` into ``<src_elem_count>`` / ``<seg_elem_count>`` parts, then judges whether each element in each part is greater than or equal to the corresponding element in ``<seg>``. The result is assigned to ``<dst>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of first source vector.
 * @param[in] seg The address of second source vector.
 * @param[in] src_elem_count The elements number of ``<src>`` vector.
 * @param[in] seg_elem_count The elements number of ``<seg>`` vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<src_elem_count> * sizeof(type)`` and ``<seg_elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src_elem_count>`` must be divisible by ``<seg_elem_count>``;
 * - ``<src_elem_count>`` and ``<seg_elem_count>`` must be greater than zero;
 * - ``<src>``, ``<seg>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>``, ``<seg>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_cycle_ge(float* dst,
                                                         float* src,
                                                         float* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_cycle_ge(bfloat16_t* dst,
                                                         bfloat16_t* src,
                                                         bfloat16_t* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count);
//Group:Stream Comparison Functions
static __mlu_func__ __mlu_builtin__ void __bang_cycle_lt(half* dst,
                                                         half* src,
                                                         half* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count);

//Group:Stream Comparison Functions
/**
 * @brief Divides ``<src>`` into ``<src_elem_count>`` / ``<seg_elem_count>`` parts, then judges whether each element in each part is less than the corresponding element in ``<seg>``. The result is assigned to ``<dst>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of first source vector.
 * @param[in] seg The address of second source vector.
 * @param[in] src_elem_count The elements number of ``<src>`` vector.
 * @param[in] seg_elem_count The elements number of ``<seg>`` vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<src_elem_count> * sizeof(type)`` and ``<seg_elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src_elem_count>`` must be divisible by ``<seg_elem_count>``;
 * - ``<src_elem_count>`` and ``<seg_elem_count>`` must be greater than zero;
 * - ``<src>``, ``<seg>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>``, ``<seg>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_cycle_lt(float* dst,
                                                         float* src,
                                                         float* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_cycle_lt(bfloat16_t* dst,
                                                         bfloat16_t* src,
                                                         bfloat16_t* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count);
//Group:Stream Comparison Functions
static __mlu_func__ __mlu_builtin__ void __bang_cycle_le(half* dst,
                                                         half* src,
                                                         half* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count);

//Group:Stream Comparison Functions
/**
 * @brief Divides ``<src>`` into ``<src_elem_count>`` / ``<seg_elem_count>`` parts, then judges whether each element in each part is less than or equal to the corresponding element in ``<seg>``. The result is assigned to ``<dst>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of first source vector.
 * @param[in] seg The address of second source vector.
 * @param[in] src_elem_count The elements number of ``<src>`` vector.
 * @param[in] seg_elem_count The elements number of ``<seg>`` vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<src_elem_count> * sizeof(type)`` and ``<seg_elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src_elem_count>`` must be divisible by ``<seg_elem_count>``;
 * - ``<src_elem_count>`` and ``<seg_elem_count>`` must be greater than zero;
 * - ``<src>``, ``<seg>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>``, ``<seg>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_cycle_le(float* dst,
                                                         float* src,
                                                         float* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_cycle_le(bfloat16_t* dst,
                                                         bfloat16_t* src,
                                                         bfloat16_t* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count);

//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_cycle_and(half* dst,
                                                          half* src,
                                                          half* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_cycle_and(int* dst,
                                                          int* src,
                                                          int* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_cycle_and(short* dst,
                                                          short* src,
                                                          short* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_cycle_and(char* dst,
                                                          char* src,
                                                          char* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count);

static __mlu_func__ __mlu_builtin__ void __bang_cycle_and(bfloat16_t* dst,
                                                          bfloat16_t* src,
                                                          bfloat16_t* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count);
//Group:Stream Logic and Bit Operation Functions
/**
 * @brief Divides ``<src>`` into ``<src_elem_count>`` / ``<seg_elem_count>`` parts. Each element in each part AND the corresponding element in ``<seg>``. The result is assigned to ``<dst>``. If both the elements of ``<src0>`` and ``<src1>`` are non-zero, the result is 1. Otherwise, the result is 0. The type of result is the same as that of ``<src0>`` and ``<src1>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of first source vector.
 * @param[in] seg The address of second source vector.
 * @param[in] src_elem_count The elements number of ``<src>`` vector.
 * @param[in] seg_elem_count The elements number of ``<seg>`` vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``float`` is supported on ``(m)tp_2xx`` and higher;
 * - ``int``, ``short`` and ``char`` are supported on ``(m)tp_3xx`` and higher;
 * - ``<src_elem_count> * sizeof(type)`` and ``<seg_elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src_elem_count>`` must be divisible by ``<seg_elem_count>``;
 * - ``<src_elem_count>`` and ``<seg_elem_count>`` must be greater than zero;
 * - ``<src>``, ``<seg>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>``, ``<seg>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_binary_logic_and_bit_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *    #include <bang.h>
 *
 *    #define N1 128
 *    #define N2 32640
 *
 *    __mlu_entry__ void kernel(float *c, float *a, float *b) {
 *      __nram__ float a_tmp[N1];
 *      __nram__ float b_tmp[N2];
 *      __nram__ float c_tmp[N2];
 *      __memcpy(a_tmp, a, N1 * sizeof(float), GDRAM2NRAM);
 *      __memcpy(b_tmp, b, N2 * sizeof(float), GDRAM2NRAM);
 *      __bang_cycle_and(c_tmp, b_tmp, a_tmp, N2, N1);
 *      __memcpy(c, c_tmp, N2 * sizeof(float), NRAM2GDRAM);
 *    }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_cycle_and(float* dst,
                                                          float* src,
                                                          float* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count);

//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_cycle_or(half* dst,
                                                         half* src,
                                                         half* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_cycle_or(int* dst,
                                                         int* src,
                                                         int* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_cycle_or(short* dst,
                                                         short* src,
                                                         short* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_cycle_or(char* dst,
                                                         char* src,
                                                         char* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_cycle_or(bfloat16_t* dst,
                                                         bfloat16_t* src,
                                                         bfloat16_t* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count);

//Group:Stream Logic and Bit Operation Functions
/**
 * @brief Divides ``<src>`` into ``<src_elem_count>`` / ``<seg_elem_count>`` parts. Each element in each part OR the corresponding element in ``<seg>``. The result is assigned to ``<dst>``. If both the elements of ``<src0>`` and ``<src1>`` are zero, the result is 0. Otherwise, the result is 1. The type of result is the same as that of ``<src0>`` and ``<src1>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of first source vector.
 * @param[in] seg The address of second source vector.
 * @param[in] src_elem_count The elements number of ``<src>`` vector.
 * @param[in] seg_elem_count The elements number of ``<seg>`` vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``float`` is supported on ``(m)tp_2xx`` and higher;
 * - ``int``, ``short`` and ``char`` are supported on ``(m)tp_3xx`` and higher;
 * - ``<src_elem_count> * sizeof(type)`` and ``<seg_elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src_elem_count>`` must be divisible by ``<seg_elem_count>``;
 * - ``<src_elem_count>`` and ``<seg_elem_count>`` must be greater than zero;
 * - ``<src>``, ``<seg>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>``, ``<seg>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_binary_logic_and_bit_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_cycle_or(float* dst,
                                                         float* src,
                                                         float* seg,
                                                         int src_elem_count,
                                                         int seg_elem_count);

//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_cycle_xor(half* dst,
                                                          half* src,
                                                          half* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_cycle_xor(int* dst,
                                                          int* src,
                                                          int* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_cycle_xor(short* dst,
                                                          short* src,
                                                          short* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_cycle_xor(char* dst,
                                                          char* src,
                                                          char* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_cycle_xor(bfloat16_t* dst,
                                                          bfloat16_t* src,
                                                          bfloat16_t* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count);
//Group:Stream Logic and Bit Operation Functions
/**
 * @brief Divides ``<src>`` into ``<src_elem_count>`` / ``<seg_elem_count>`` parts. Each element in each part XOR the corresponding element in ``<seg>``. The result is assigned to ``<dst>``. If both the elements of ``<src0>`` and ``<src1>`` are zero or non-zero, the result is 0. Otherwise, the result is 1. The type of result is the same as that of ``<src0>`` and ``<src1>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of first source vector.
 * @param[in] seg The address of second source vector.
 * @param[in] src_elem_count The elements number of ``<src>`` vector.
 * @param[in] seg_elem_count The elements number of ``<seg>`` vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``float`` is supported on ``(m)tp_2xx`` and higher;
 * - ``int``, ``short`` and ``char`` are supported on ``(m)tp_3xx`` and higher;
 * - ``<src_elem_count> * sizeof(type)`` and ``<seg_elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src_elem_count>`` must be divisible by ``<seg_elem_count>``;
 * - ``<src_elem_count>`` and ``<seg_elem_count>`` must be greater than zero;
 * - ``<src>``, ``<seg>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>``, ``<seg>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_binary_logic_and_bit_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_cycle_xor(float* dst,
                                                          float* src,
                                                          float* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count);

//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_cycle_bxor(int* dst,
                                                           int* src,
                                                           int* seg,
                                                           int src_elem_count,
                                                           int seg_elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_cycle_bxor(short* dst,
                                                           short* src,
                                                           short* seg,
                                                           int src_elem_count,
                                                           int seg_elem_count);
//Group:Stream Logic and Bit Operation Functions
/**
 * @brief Divides ``<src>`` into ``<src_elem_count>`` / ``<seg_elem_count>`` parts. Each element in each part applies bit-wise XOR operation with the corresponding element in ``<seg>``. The result is assigned to ``<dst>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of first source vector.
 * @param[in] seg The address of second source vector.
 * @param[in] src_elem_count The elements number of ``<src>`` vector.
 * @param[in] seg_elem_count The elements number of ``<seg>`` vector.
 * @return ``void``.
 * @remark
 * - ``int`` and ``short`` are supported on ``(m)tp_3xx`` and higher;
 * - ``<src_elem_count> * sizeof(char)`` and ``<seg_elem_count> * sizeof(char)`` must be divisible by 128 on ``(m)tp_2xx``;
 * - ``<src_elem_count>`` must be divisible by ``<seg_elem_count>``;
 * - ``<src_elem_count>`` and ``<seg_elem_count>`` must be greater than zero;
 * - ``<src>``, ``<seg>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>``, ``<seg>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src>`` can be homologous operands.
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_cycle_bxor(char* dst,
                                                           char* src,
                                                           char* seg,
                                                           int src_elem_count,
                                                           int seg_elem_count);

//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_cycle_band(int* dst,
                                                           int* src,
                                                           int* seg,
                                                           int src_elem_count,
                                                           int seg_elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_cycle_band(short* dst,
                                                           short* src,
                                                           short* seg,
                                                           int src_elem_count,
                                                           int seg_elem_count);
//Group:Stream Logic and Bit Operation Functions
/**
 * @brief Divides ``<src>`` into ``<src_elem_count>`` / ``<seg_elem_count>`` parts. Each element in each part applies bit-wise AND operation with the corresponding element in ``<seg>``. The result is assigned to ``<dst>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of first source vector.
 * @param[in] seg The address of second source vector.
 * @param[in] src_elem_count The elements number of ``<src>`` vector.
 * @param[in] seg_elem_count The elements number of ``<seg>`` vector.
 * @return ``void``.
 * @remark
 * - ``int`` and ``short`` are supported on ``(m)tp_3xx`` and higher;
 * - ``<src_elem_count> * sizeof(char)`` and ``<seg_elem_count> * sizeof(char)`` must be divisible by 128 on ``(m)tp_2xx``;
 * - ``<src_elem_count>`` must be divisible by ``<seg_elem_count>``;
 * - ``<src_elem_count>`` and ``<seg_elem_count>`` must be greater than zero;
 * - ``<src>``, ``<seg>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>``, ``<seg>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src>`` can be homologous operands.
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_cycle_band(char* dst,
                                                           char* src,
                                                           char* seg,
                                                           int src_elem_count,
                                                           int seg_elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_cycle_bor(int* dst,
                                                          int* src,
                                                          int* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_cycle_bor(short* dst,
                                                          short* src,
                                                          short* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count);
//Group:Stream Logic and Bit Operation Functions
/**
 * @brief Divides ``<src>`` into ``<src_elem_count>`` / ``<seg_elem_count>`` parts. Each element in each part applies bit-wise OR operation with the corresponding element in ``<seg>``. The result is assigned to ``<dst>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of first source vector.
 * @param[in] seg The address of second source vector.
 * @param[in] src_elem_count The elements number of ``<src>`` vector.
 * @param[in] seg_elem_count The elements number of ``<seg>`` vector.
 * @return ``void``.
 * @remark
 * - ``int`` and ``short`` are supported on ``(m)tp_3xx`` and higher;
 * - ``<src_elem_count> * sizeof(char)`` and ``<seg_elem_count> * sizeof(char)`` must be divisible by 128 on ``(m)tp_2xx``;
 * - ``<src_elem_count>`` must be divisible by ``<seg_elem_count>``;
 * - ``<src_elem_count>`` and ``<seg_elem_count>`` must be greater than zero;
 * - ``<src>``, ``<seg>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>``, ``<seg>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src>`` can be homologous operands.
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *     - MLU Compute Arch Version: ``cncc --bang-mlu-arch >= (m)tp_2xx``.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_cycle_bor(char* dst,
                                                          char* src,
                                                          char* seg,
                                                          int src_elem_count,
                                                          int seg_elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_select(half* dst,
                                                       half* src,
                                                       half* index,
                                                       int elem_count);

//Group:Stream Operation Functions
/**
 * @brief Selects elements in one vector according to the corresponding values in another vector. The elements (half or float) in ``<src>`` will be selected if corresponding elements in ``<index>`` are not equal to zero. The result is composed of two parts. The first part is the number of selected elements, and the second part is the selected elements. The selected elements will be stored continuously.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of first source vector.
 * @param[in] index The address of second source vector.
 * @param[in] elem_count The elements number of source vector.
 * @return ``void``.
 * @remark
 * - ``<elem_count> * sizeof(type)`` must be a multiple of 128 bytes on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - The ``<src>``, ``<index>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>``, ``<index>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>`` is composed of two parts: the first 128 bytes stores the number of selected elements; the rest store the selected elements;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - The type of the number of selected elements is ``unsigned int``. The remaining 124 bytes of the first part of ``<dst>`` will be set to zero on ``(m)tp_1xx`` and ``(m)tp_2xx``, and it will not be changed on ``(m)tp_3xx``;
 * - If the total number of bytes of the selected elements is not a multiple of 128, it will be aligned to 128 bytes, and the part less than 128 bytes will be set to zero;
 * - The total number of bytes of ``<dst>`` is at least 256.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_select(float* dst,
                                                       float* src,
                                                       float* index,
                                                       int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_select_bitindex(half* dst,
                                                                half* src,
                                                                void* bitindex,
                                                                int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Selects elements in ``<src>`` if the corresponding bit values in ``<bitindex>`` are not equal to zero. The result is saved to ``<dst>``, which composes of two parts. The first part is the number of selected elements, and the second part is the selected elements. The selected elements will be stored continuously.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of first source vector.
 * @param[in] bitindex The address of second source vector.
 * @param[in] elem_count The elements number of source vector.
 * @return ``void``.
 * @remark
 * - ``<elem_count>`` must be divisible by 1024 on ``(m)tp_1xx`` and ``(m)tp_2xx``, and divisible by 8 on ``mtp_372`` and ``tp_322``;
 * - ``<elem_count>`` must be greater than zero.
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - The ``<src>``, ``<bitindex>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>``, ``<bitindex>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>`` is composed of two parts: the first 128 bytes stores the number of selected elements; the rest store the selected elements;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - The type of the number of selected elements is ``unsigned int``. The remaining part of the first part of ``<dst>`` will be set to zero on ``(m)tp_1xx`` and ``(m)tp_2xx``, and it will not be changed on ``(m)tp_3xx``;
 * - If the total number of bytes of the selected elements is not a multiple of 128, it will be aligned to 128 bytes, and the part less than 128 bytes will be set to zero;
 * - The total number of bytes of ``<dst>`` is at least 256.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_select_bitindex(float* dst,
                                                                float* src,
                                                                void* bitindex,
                                                                int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_collect(half* dst,
                                                        half* src,
                                                        half* mask,
                                                        int elem_count);

//Group:Stream Operation Functions
/**
 * @brief Selects number in one vector according to the corresponding values in another vector. The elements (half or float) in ``<src>`` will be selected if corresponding elements in ``<mask>`` are not equal to zero. The result is the selected elements.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of first source vector.
 * @param[in] mask The address of second source vector.
 * @param[in] elem_count The elements number of source vector.
 * @return ``void``.
 * @remark
 * - ``<elem_count> * sizeof(type)`` must be a multiple of 128 bytes on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - The ``<src>``, ``<mask>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>``, ``<mask>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - The selected elements will be stored continuously;
 * - The total number of bytes of ``<dst>`` is at least 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_collect(float* dst,
                                                        float* src,
                                                        float* mask,
                                                        int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_collect_bitindex(half* dst,
                                                                 half* src,
                                                                 void* bitmask,
                                                                 int elem_count);

//Group:Stream Operation Functions
/**
 * @brief Selects the corresponding elements in ``<src>`` according to ``<bitmask>``. The elements in ``<src>`` will be saved to ``<dst>``, if corresponding bit in ``<bitmask>`` is 1. All selected elements will be stored continuously in ``<dst>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of first source vector.
 * @param[in] bitmask The address of second source vector.
 * @param[in] elem_count The elements number of source vector.
 * @return ``void``.
 * @remark
 * - ``<elem_count>`` must be divisible by 1024 on ``(m)tp_1xx`` and ``(m)tp_2xx``, and divisible by 8 on ``mtp_372`` and ``tp_322``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - The ``<src>``, ``<bitmask>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>``, ``<bitmask>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - The total number of bytes of ``<dst>`` is at least 128 for ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - For ``(m)tp_1xx`` and ``(m)tp_2xx``, if the size of all selected elements is less than 128 bytes, the remaining part is set to zero.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_collect_bitindex(float* dst,
                                                                 float* src,
                                                                 void* bitmask,
                                                                 int elem_count);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_maskmove(half* dst,
                                                         half* src,
                                                         half* mask,
                                                         int elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_maskmove(bfloat16_t* dst,
                                                         bfloat16_t* src,
                                                         bfloat16_t* mask,
                                                         int elem_count);

//Group:Stream Operation Functions
/**
 * @brief Selects bytes in ``<src>``, whose element count is ``<elem_count>``, according to the bit value of the vector ``<mask>``, and stores the result in ``<dst>``. The bytes in ``<src>`` will be selected if corresponding bit values in ``<mask>`` are not equal to zero.
 *
 * @details If the bit value of mask is 1, stores the corresponding byte of ``<src>`` to ``<dst>``; otherwise, keeps the corresponding byte in ``<dst>`` unchanged.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] mask The address of mask vector.
 * @param[in] elem_count The length of source vector.
 * @return ``void``.
 * @remark
 * - This interface is supported on ``(m)tp_2xx`` and higher;
 * - ``<elem_count> * sizeof(type)`` must be a multiple of 128 bytes on ``(m)tp_2xx``;
 * - ``<src>``, ``<mask>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>``, ``<mask>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - ``<elem_count>`` must be greater than zero.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_maskmove(float* dst,
                                                         float* src,
                                                         float* mask,
                                                         int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_maskmove_bitindex(half* dst,
                                                                  half* src,
                                                                  void* bitmask,
                                                                  int elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_maskmove_bitindex(bfloat16_t* dst,
                                                                  bfloat16_t* src,
                                                                  bfloat16_t* bitmask,
                                                                  int elem_count);

//Group:Stream Operation Functions
/**
 * @brief Selects the corresponding elements in ``<src>`` according to ``<bitmask>``. The elements in ``<src>`` will be saved to ``<dst>``, if corresponding bit in ``<bitmask>`` is 1. All selected elements in ``<dst>`` will be stored continuously.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of first source vector.
 * @param[in] bitmask The address of second source vector.
 * @param[in] elem_count The elements number of source vector.
 * @return ``void``.
 * @remark
 * - This interface is supported on ``(m)tp_2xx`` and higher;
 * - This interface is deprecated, use ::__bang_collect_bitindex instead;
 * - The ``<src>``, ``<bitmask>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>``, ``<bitmask>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - The total number of bytes of ``<dst>`` is at least 128 on ``(m)tp_2xx``;
 * - ``<elem_count>`` must be divisible by 1024 on ``(m)tp_2xx``, and divisible by 8 on ``mtp_372`` and ``tp_322``;
 * - ``<elem_count>`` must be greater than zero.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_maskmove_bitindex(float* dst,
                                                                  float* src,
                                                                  void* bitmask,
                                                                  int elem_count);

//Group:Stream Comparison Functions
static __mlu_func__ __mlu_builtin__ void __bang_max(half* dst,
                                                    half* src,
                                                    int elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_max(bfloat16_t* dst,
                                                    bfloat16_t* src,
                                                    int elem_count);
//Group:Stream Comparison Functions
/**
 * @brief Finds the maximum in a given vector. The result is composed of two parts. The first part is the maximum value, the second part is the index of the maximum value in ``<src>`` vector.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count The elements number of source vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<elem_count>`` must be greater than zero.
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The ``__nram__`` space to which the vector operand ``<dst>`` points must be at least 128 bytes on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src>`` can not be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_comparison_operation_functions_without_elementwise` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *    #include <bang.h>
 *
 *    #define DATA_SIZE 128
 *
 *    __mlu_entry__ void kernel(float *c, float *a) {
 *      __nram__ float a_tmp[DATA_SIZE];
 *      __nram__ float c_tmp[DATA_SIZE];
 *      __memcpy(a_tmp, a, DATA_SIZE * sizeof(float), GDRAM2NRAM);
 *      __bang_max(c_tmp, a_tmp, DATA_SIZE);
 *      __memcpy(c, c_tmp, DATA_SIZE * sizeof(float), NRAM2GDRAM);
 *    }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_max(float* dst,
                                                    float* src,
                                                    int elem_count);

//Group:Stream Comparison Functions
static __mlu_func__ __mlu_builtin__ void __bang_argmax(half* dst,
                                                       half* src,
                                                       int elem_count);

static __mlu_func__ __mlu_builtin__ void __bang_argmax(bfloat16_t* dst,
                                                       bfloat16_t* src,
                                                       int elem_count);
//Group:Stream Comparison Functions
/**
 * @brief Finds the maximum value and its corresponding index.
 *
 * @details Finds the maximum value and its corresponding index in ``<src>`` vector. The result is composed of two parts. The first part is the maximum value, and the second part is the index of the first maximum value position in ``<src>`` vector.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count The elements number of source vector.
 * @return ``void``.
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<dst>`` is composed of two parts. The first part is the maximum value, and the second part is the index of the first maximum value position;
 * - The storage details of ``<dst>`` are as follows:
 * - If the data type is ``half``, the ``__nram__`` space to which the vector operand ``<dst>`` points must be at least ``10`` bytes. The first ``16-bit`` is the maximum value, the next ``22-bit`` is the index of the first maximum value position, and the remaining ``42-bit`` is zero;
 * - If the data type is ``float``, the ``__nram__`` space to which the vector operand ``<dst>`` points must be at least ``12`` bytes. The first ``32-bit`` is the maximum value, the next ``26-bit`` is the index of the first maximum value position, and the remaining ``38-bit`` is zero.
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_comparison_operation_functions_without_elementwise` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *    #include <bang.h>
 *
 *    #define DATA_NUM 90
 *
 *    __mlu_entry__ void kernel_max(float* dst, float* src) {
 *      __nram__ float dst_nram[DATA_NUM];
 *      __nram__ float src_nram[DATA_NUM];
 *      __memcpy(src_nram, src, DATA_NUM * sizeof(float), GDRAM2NRAM);
 *      __bang_argmax(dst_nram, src_nram, DATA_NUM);
 *      __memcpy(dst, dst_nram, DATA_NUM * sizeof(float), NRAM2GDRAM);
 *    }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_argmax(float* dst,
                                                       float* src,
                                                       int elem_count);

//Group:Stream Comparison Functions
static __mlu_func__ __mlu_builtin__ void __bang_min(half* dst,
                                                    half* src,
                                                    int elem_count);

static __mlu_func__ __mlu_builtin__ void __bang_min(bfloat16_t* dst,
                                                    bfloat16_t* src,
                                                    int elem_count);
//Group:Stream Comparison Functions
/**
 * @brief Finds the minimum in a given vector.
 *
 * @details Finds the minimum value in ``<src>`` and stores the result in ``<dst>``. The result consists of two parts, the first part is the minimum value, and the second part is the index of the minimum value.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count The elements number of source vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The ``__nram__`` space to which the vector operand ``<dst>`` points must be at least 128 bytes on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src>`` can not be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_comparison_operation_functions_without_elementwise` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_min(float* dst,
                                                    float* src,
                                                    int elem_count);

//Group:Stream Comparison Functions
static __mlu_func__ __mlu_builtin__ void __bang_argmin(half* dst,
                                                       half* src,
                                                       int elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_argmin(bfloat16_t* dst,
                                                       bfloat16_t* src,
                                                       int elem_count);
//Group:Stream Comparison Functions
/**
 * @brief Finds the minimum value and its corresponding index.
 *
 * @details Finds the minimum value and its corresponding index in ``<src>`` vector. The result is composed of two parts. The first part is the minimum value, and the second part is the index of the first minimum value position in ``<src>`` vector.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count The elements number of source vector.
 * @return ``void``.
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<dst>`` is composed of two parts. The first part is the minimum value, and the second part is the index of the first minimum value position;
 * - The storage details of ``<dst>`` are as follows:
 * - If the data type is ``half``, the ``__nram__`` space to which the vector operand ``<dst>`` points must be at least ``10`` bytes. The first 16 bits are the minimum value, the next 22 bits are the index of the first minimum value position, and the remaining 42 bits are zero;
 * - If the data type is ``float``, the ``__nram__`` space to which the vector operand ``<dst>`` points must be at least ``12`` bytes. The first 32 bits are the minimum value, the next 26 bits are the index of the first minimum value position, and the remaining 38 bits are zero.
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_comparison_operation_functions_without_elementwise` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *    #include <bang.h>
 *
 *    #define DATA_NUM 90
 *
 *    __mlu_entry__ void kernel_min(float* dst, float* src) {
 *      __nram__ float dst_nram[DATA_NUM];
 *      __nram__ float src_nram[DATA_NUM];
 *      __memcpy(src_nram, src, DATA_NUM * sizeof(float), GDRAM2NRAM);
 *      __bang_argmin(dst_nram, src_nram, DATA_NUM);
 *      __memcpy(dst, dst_nram, DATA_NUM * sizeof(float), NRAM2GDRAM);
 *    }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_argmin(float* dst,
                                                       float* src,
                                                       int elem_count);

//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_not(half* dst,
                                                    half* src,
                                                    int elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_not(int* dst,
                                                    int* src,
                                                    int elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_not(short* dst,
                                                    short* src,
                                                    int elem_count);
//Group:Stream Logic and Bit Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_not(char* dst,
                                                    char* src,
                                                    int elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_not(bfloat16_t* dst,
                                                    bfloat16_t* src,
                                                    int elem_count);
//Group:Stream Logic and Bit Operation Functions
/**
 * @brief Applies element-wisely NOT operation on a vector. For each element in ``<src>``, if it equals to zero, then stores 1 at the corresponding position in ``<dst>``; otherwise, stores 0 at the position in ``<dst>``. The type of result is the same as that of ``<src>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count The elements number of source vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``float`` is supported on ``(m)tp_2xx`` and higher;
 * - ``int``, ``short`` and ``char`` are supported on ``(m)tp_3xx`` and higher;
 * - ``<elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_unary_logic_and_bit_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_not(float* dst,
                                                    float* src,
                                                    int elem_count);

//Group:Stream Operation Functions
/**
 * @brief Generates a vector of uniformly distributed random number of short type.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] elem_count The elements number of destination vector.
 * @return ``void``.
 * @remark
 * - This interface is supported on ``(m)tp_2xx`` and higher;
 * - ``<elem_count>`` must be greater than zero and divisible by 64;
 * - ``<dst>`` must point to ``__nram__`` space;
 * - The address of must be 64‑byte aligned on ``(m)tp_2xx``.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *    #include <bang.h>
 *
 *    #define DATA_SIZE 64
 *
 *    __mlu_entry__ void kernel(short *output) {
 *      __nram__ short result[DATA_SIZE];
 *      __bang_rand(result, DATA_SIZE);
 *      __memcpy(output, result, DATA_SIZE * sizeof(short), NRAM2GDRAM);
 *    }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_rand(short* dst,
                                                     int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_count(unsigned int* dst,
                                                      half* src,
                                                      int elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_count(unsigned int* dst,
                                                      bfloat16_t* src,
                                                      int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Counts the number of non-zero elements in the input vector.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count The elements number of source vector.
 * @return ``void``.
 * @remark
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64‑byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The size of ``<dst>`` is at least 128 bytes on ``(m)tp_1xx`` and ``(m)tp_2xx``, and at least 4 bytes on ``(m)tp_3xx``;
 * - The number of non-zero elements is stored in the first 4 bytes of ``<dst>``. The remaining 124 bytes of ``<dst>`` on ``(m)tp_1xx`` and ``(m)tp_2xx`` will be set to 0. The remaining part of ``<dst>`` will not be changed on ``(m)tp_3xx``;
 * - ``<dst>`` and ``<src>`` can be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *    #include <bang.h>
 *
 *    #define DATA_SIZE 64
 *
 *    __mlu_entry__ void kernel(unsigned int* dst, float* src, int elem_count) {
 *      __bang_count(dst, src, elem_count);
 *      unsigned int counter = ((unsigned int*)dst)[0];
 *    }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_count(unsigned int* dst,
                                                      float* src,
                                                      int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_count_bitindex(unsigned int* dst,
                                                               half* src,
                                                               int elem_count);

static __mlu_func__ __mlu_builtin__ void __bang_count_bitindex(unsigned int* dst,
                                                               bfloat16_t* src,
                                                               int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Counts the number of non-zero bit in the input vector.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count The elements number of source vector.
 * @return ``void``.
 * @remark
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count> * (3 * sizeof(type) * 8 - 32)`` must be divisible by 64;
 * - ``<elem_count> * sizeof(type)`` must be divisible by 64;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64‑byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The size of ``<dst>`` is at least 128 bytes on ``(m)tp_1xx`` and ``(m)tp_2xx``, and at least 4 bytes on ``(m)tp_3xx``;
 * - The number of non-zero bits is stored in the first 4 bytes of ``<dst>``. The remaining 124 bytes of ``<dst>`` on ``(m)tp_1xx`` and ``(m)tp_2xx`` will be set to 0. The remaining part of ``<dst>`` will not be changed on ``(m)tp_3xx``;
 * - ``<dst>`` and ``<src>`` can be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *    #include <bang.h>
 *
 *    #define DATA_SIZE 64
 *
 *    __mlu_entry__ void kernel(unsigned int* dst, float* src, int elem_count) {
 *      __bang_count_bitindex(dst, src, elem_count);
 *      unsigned int counter = ((unsigned int*)dst)[0];
 *    }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_count_bitindex(unsigned int* dst,
                                                               float* src,
                                                               int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_square(half* dst,
                                                       half* src,
                                                       int elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_square(bfloat16_t* dst,
                                                       bfloat16_t* src,
                                                       int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Applies square activation operation on ``<src>`` element-wisely, and stores the result in ``<dst>``. \f$<dst> = <src>^2\f$.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count The elements number of source vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_unary_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define DATA_SIZE 64
 *
 *   __mlu_entry__ void kernel(half* c, half* a) {
 *     __nram__ half a_tmp[DATA_SIZE];
 *     __nram__ half c_tmp[DATA_SIZE];
 *     __memcpy(a_tmp, a, DATA_SIZE * sizeof(half), GDRAM2NRAM);
 *     __bang_square(c_tmp, a_tmp, DATA_SIZE);
 *     __memcpy(c, c_tmp, DATA_SIZE * sizeof(half), NRAM2GDRAM);
 *   }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_square(float* dst,
                                                       float* src,
                                                       int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_findfirst1(unsigned int* dst,
                                                           half* src,
                                                           int elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_findfirst1(unsigned int* dst,
                                                           bfloat16_t* src,
                                                           int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Finds the first non-zero data in the values of ``<src>``, and stores the index of the first non-zero data in the first element of ``<dst>``. If ``<src>`` is all zero, stores 0xffff-ffff-ffff-ffff.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count The elements number of source vector.
 * @return ``void``.
 * @remark
 * - This interface is supported on ``(m)tp_2xx`` and higher;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count> * sizeof (type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The total number of bytes of ``<dst>`` is at least 128 on ``(m)tp_2xx``, and at least 4 on ``(m)tp_3xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of and must be 64‑byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src>`` can be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define DATA_SIZE 64
 *
 *   __mlu_entry__ void kernel(half* c, half* a) {
 *     __nram__ half a_tmp[DATA_SIZE];
 *     __nram__ half c_tmp[DATA_SIZE];
 *     __memcpy(a_tmp, a, DATA_SIZE * sizeof(half), GDRAM2NRAM);
 *     __bang_findfirst1((uint32_t*)c_tmp, a_tmp, DATA_SIZE);
 *     __memcpy(c, c_tmp, DATA_SIZE * sizeof(half), NRAM2GDRAM);
 *   }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_findfirst1(unsigned int* dst,
                                                           float* src,
                                                           int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_findlast1(unsigned int* dst,
                                                          half* src,
                                                          int elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_findlast1(unsigned int* dst,
                                                          bfloat16_t* src,
                                                          int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Finds the last non-zero data in the values of ``<src>``, and stores the index of the last non-zero data in ``<dst>``. If ``<src>`` is all zero, stores 0xffff-ffff-ffff-ffff.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count The elements number of source vector.
 * @return ``void``.
 * @remark
 * - This interface is supported on ``(m)tp_2xx`` and higher;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count> * sizeof (type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The total number of bytes of ``<dst>`` is at least 128 on ``(m)tp_2xx``, and at least 4 on ``(m)tp_3xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of and must be 64‑byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src>`` can be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_findlast1(unsigned int* dst,
                                                          float* src,
                                                          int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_reduce_sum(half* dst,
                                                           half* src,
                                                           int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Takes every 128-byte data from  ``<src>`` to add them up and stores the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count Number of elements in source vector.
 * @return ``void``.
 * @remark
 * \rst
 * - This interface is supported on ``(m)tp_2xx`` and higher;
 * - The first element of every 128 bytes in destination operand ``<dst>`` is the sum of every 128-byte data, the other elements in destination operand ``<dst>`` of every 128 bytes will be set to zero on ``(m)tp_2xx``, and they will not be changed on ``(m)tp_3xx``;
 * - This instruction takes every 128 bytes to calculate each time. When vector type is float, the function will take the 32 elements to calculate. When vector type is half, the function will take the 64 elements to calculate;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_2xx``;
 * - The total number of bytes of ``<dst>`` is at least 128;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_binary_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_reduce_sum(float* dst,
                                                           float* src,
                                                           int elem_count);

static __mlu_func__ __mlu_builtin__ half __bang_sum(half* src,
                                                    int elem_count);
static __mlu_func__ __mlu_builtin__ bfloat16_t __bang_sum(bfloat16_t* src,
                                                          int elem_count);
static __mlu_func__ __mlu_builtin__ float __bang_sum(float* src,
                                                     int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_relu(half* dst,
                                                     half* src,
                                                     int elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_relu(bfloat16_t* dst,
                                                     bfloat16_t* src,
                                                     int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Performs stream relu operation.
 *
 * @details This instruction performs relu operation on each element in vector ``<src>`` and saves the result to vector ``<dst>`` in ``__nram__`` space.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count Number of elements in source.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<elem_count>`` must be greater than zero;
 * - ``<dst>`` and ``<src>`` must be in ``__nram__`` space;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_unary_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *   - BANG Version: ``__BANG_ARCH__ >= 322`` ;
 *   - CNCC Version: ``cncc --version >= 3.0.0`` ;
 *   - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30`` ;
 *   - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322`` .
 *
 * @par Example
 * @code
 *
 *    #include <bang.h>
 *
 *    #define DATA_NUM 64
 *
 *    __mlu_entry__ void kernel(half *dst_h, half *src_h) {
 *      __nram__ half nram_dst_h[DATA_NUM];
 *      __nram__ half nram_src_h[DATA_NUM];
 *      __memcpy(nram_src_h, src_h, DATA_NUM * sizeof(half), GDRAM2NRAM);
 *      __bang_relu(nram_dst_h, nram_src_h, DATA_NUM);
 *      __memcpy(dst_h, nram_dst_h, DATA_NUM * sizeof(half), NRAM2GDRAM);
 *    }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_relu(float* dst,
                                                     float* src,
                                                     int elem_count);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_relun(half* dst,
                                                      half* src,
                                                      int elem_count,
                                                      half nvalue);
static __mlu_func__ __mlu_builtin__ void __bang_relun(bfloat16_t* dst,
                                                      bfloat16_t* src,
                                                      int elem_count,
                                                      bfloat16_t nvalue);
//Group:Stream Operation Functions
/**
 * @brief Performs stream relun operation.
 *
 * @details The instruction performs relun operation on each element in ``<src>``. If the element in ``<src>`` is less than 0, corresponding element in ``<dst>`` will be ``0``. If the element is greater than ``<nvalue>``, corresponding element in ``<dst>`` will be ``<nvalue>``. Otherwise, the element in ``<dst>`` will be itself.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count Number of elements in source.
 * @param[in] nvalue The N value of instruction.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<elem_count>`` must be greater than zero;
 * - ``<dst>`` and ``<src>`` must be in ``__nram__`` space;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - `<nvalue>` must be positive, and can not be :math:`INF` or :math:`NaN`;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_unary_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *   - BANG Version: ``__BANG_ARCH__ >= 322`` ;
 *   - CNCC Version: ``cncc --version >= 3.0.0`` ;
 *   - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30`` ;
 *   - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322`` .
 *
 * @par Example
 * @code
 *
 *    #include <bang.h>
 *
 *    #define DATA_NUM 64
 *
 *    __mlu_entry__ void kernel(half *dst_h, half *src_h, half const_h) {
 *      __nram__ half nram_dst_h[DATA_NUM];
 *      __nram__ half nram_src_h[DATA_NUM];
 *      __memcpy(nram_src_h, src_h, DATA_NUM * sizeof(half), GDRAM2NRAM);
 *      __bang_relun(nram_dst_h, nram_src_h, DATA_NUM, const_h);
 *      __memcpy(dst_h, nram_dst_h, DATA_NUM * sizeof(half), NRAM2GDRAM);
 *    }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_relun(float* dst,
                                                      float* src,
                                                      int elem_count,
                                                      float nvalue);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_write_zero(signed char* dst,
                                                           int elem_count);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_write_zero(unsigned char* dst,
                                                           int elem_count);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_write_zero(short* dst,
                                                           int elem_count);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_write_zero(unsigned short* dst,
                                                           int elem_count);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_write_zero(int* dst,
                                                           int elem_count);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_write_zero(unsigned int* dst,
                                                           int elem_count);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_write_zero(half* dst,
                                                           int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Writes zeros in the memory space.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] elem_count The elements number of destination vector.
 * @return ``void``.
 * @remark
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<dst>`` must be 64‑byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_write_zero(float* dst,
                                                           int elem_count);

//Group:Stream Operation Functions
/**
 * @brief Applies lookup-table operation on ``<src>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] table The address of table vector.
 * @param[in] elem_count Number of elements in source vector.
 * @param[in] table_length Number of elements in table vector.
 * @return ``void``.
 * @remark
 * - This interface is supported on ``(m)tp_220``, ``(m)tp_3xx`` and higher;
 * - ``<src>``, ``<table>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>``, ``<table>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_220``;
 * - The data type of ``<dst>`` and ``<table>`` can be any type with the same size as that of ``<src>``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count>`` must be divisible by 64 on ``(m)tp_220``;
 * - ``<dst>``, ``<table>`` and ``<src>`` can not be homologous operands;
 * - ``<table_length>`` must be an immediate integer and divisible by 64.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_lut_s16(int16* dst,
                                                        int16* src,
                                                        int16* table,
                                                        int elem_count,
                                                        int table_length);

//Group:Stream Operation Functions
/**
 * @brief Applies lookup-table operation on ``<src>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] table The address of table vector.
 * @param[in] elem_count Number of elements in source vector.
 * @param[in] table_length Number of elements in table vector.
 * @return ``void``.
 * @remark
 * - This interface is supported on ``(m)tp_220``, ``(m)tp_3xx`` and higher;
 * - ``<src>``, ``<table>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>``, ``<table>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_220``;
 * - The data type of ``<dst>`` and ``<table>`` can be any type with the same size as that of ``<src>``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count>`` must be divisible by 64 on ``(m)tp_220``;
 * - ``<dst>``, ``<table>`` and ``<src>`` can not be homologous operands;
 * - ``<table_length>`` must be an immediate integer and divisible by 64.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_lut_s32(int* dst,
                                                        int* src,
                                                        int* table,
                                                        int elem_count,
                                                        int table_length);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_active_pow2(half* dst,
                                                            half* src,
                                                            int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Applies active (pow2) operation on ``<src>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count Number of elements in source vector.
 * @return ``void``.
 * @remark
 * - This interface is supported on ``(m)tp_2xx`` and higher;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count> * sizeof(type)`` must be 128-byte aligned on ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - When the data type of the element of ``<src>`` is ``half`` , the element values are integers in the range ``[-24.0, 15.0]`` , such as ``-24.0, -23.0, ... 0.0, 1.0, 2.0, ... 15.0`` ; when the data type of the element of ``<src>`` is ``float``, the element values are integers in the range ``[-31.0, 31.0]``, such as ``-31.0, -30.0, ... 0.0, 1.0, 2.0, ... 31.0``;
 * - Average relative error: 0;
 * - ``<dst>`` and ``<src>`` can be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_active_pow2(float* dst,
                                                            float* src,
                                                            int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_active_relu(half* dst,
                                                            half* src,
                                                            int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Applies active (relu) operation on ``<src>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count Number of elements in source vector.
 * @return ``void``.
 * @remark
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count> * sizeof(type)`` must be 128-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The range of ``<src>`` operand is \f$[-65504, 65504]\f$ when type is ``half``, and \f$[-3.4 * 10^{38}, 3.4 * 10^{38}]\f$ when type is ``float``;
 * - Average relative error: 0;
 * - ``<dst>`` and ``<src>`` can be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_active_relu(float* dst,
                                                            float* src,
                                                            int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_active_gelu(half* dst,
                                                            half* src,
                                                            int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Applies active (gelu) operation on ``<src>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count Number of elements in source vector.
 * @return ``void``.
 * @remark
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count> * sizeof(type)`` must be 128-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - When the data type of the elements of ``<src>`` is ``float``, the element value is in the range [-3.4e38, 3.4e38]; when the data type of the elements of ``<src>`` is ``half``, the element value is in the range [-65504, 65504];
 * - When the element value of ``<src>`` is less than -3.875, the result is -5.96e-8;
 * - Average relative error: within 0.003;
 * - ``<dst>`` and ``<src>`` can be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_active_gelu(float* dst,
                                                            float* src,
                                                            int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_active_gelup(half* dst,
                                                             half* src,
                                                             int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Applies active (gelup) operation on ``<src>``, which has higher precision than active(gelu) does.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count Number of elements in source vector.
 * @return ``void``.
 * @remark
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count> * sizeof(type)`` must be 128-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - When the data type of the elements of ``<src>`` is ``float``, the element values of ``<src>`` are in the range [-3.4e38, 3.4e38]; when the data type of the elements of ``<src>`` is ``half``, the element value is in the range [-65504, 65504];
 * - The result is -5.96e-8, when the element value of ``<src>`` is less than -3.875;
 * - When the data type of the elements of ``<src>`` is ``float``, the average relative error rate is within 0.003; when the data type of the elements of ``<src>`` is ``half``, the average relative error rate is within 0.00411. Despite having higher average relative error than normal gelu operation, it has higher precision on critical interval;
 * - ``<dst>`` and ``<src>`` can be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_active_gelup(float* dst,
                                                             float* src,
                                                             int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_active_tanh(half* dst,
                                                            half* src,
                                                            int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Applies active (tanh) operation on ``<src>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count Number of elements in source vector.
 * @return ``void``.
 * @remark
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count> * sizeof(type)`` must be 128-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - When the data type of the elements of ``<src>`` is ``float``, the element value is in the range [-3.4e38, 3.4e38]; when the data type of the elements of ``<src>`` is ``half``, the element value is in the range [-65504, 65504];
 * - Average relative error: within 0.01;
 * - ``<dst>`` and ``<src>`` can be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_active_tanh(float* dst,
                                                            float* src,
                                                            int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_active_abs(half* dst,
                                                           half* src,
                                                           int elem_count);
//Group:Stream Operation Functions
/**
 * @brief This function computes the absolute value of each element in vector ``<src>`` and saves the result to vector ``<dst>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count Number of elements in source vector.
 * @return ``void``.
 * @remark
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count> * sizeof(type)`` must be 128-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` must be in ``__nram__``;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The range of ``<src>`` operand is \f$[-65504, 65504]\f$ when type is ``half``, and \f$[-3.4 * 10^{38}, 3.4 * 10^{38}]\f$ when type is ``float``;
 * - Average relative error: 0;
 * - ``<dst>`` and ``<src>`` can be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_active_abs(float* dst,
                                                           float* src,
                                                           int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_active_sigmoid(half* dst,
                                                               half* src,
                                                               int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Applies active (sigmoid) operation on ``<src>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count Number of elements in source vector.
 * @return ``void``.
 * @remark
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count> * sizeof(type)`` must be 128-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The range of ``<src>`` operand is \f$[-65504, 65504]\f$ when type is ``half``, and \f$[-3.4 * 10^{38}, 3.4 * 10^{38}]\f$ when type is ``float``;
 * - The result is 0, when the element value of ``<src>`` is less than -7.75; the result is 1, when the element value of ``<src>`` is greater than 7.75;
 * - Average relative error: within 0.01;
 * - ``<dst>`` and ``<src>`` can be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_active_sigmoid(float* dst,
                                                               float* src,
                                                               int elem_count);

static __mlu_func__ __mlu_builtin__ void __bang_active_sigmoid_hp(half* dst,
                                                                  half* src,
                                                                  int elem_count);
static __mlu_func__ __mlu_builtin__ void __bang_active_sigmoid_hp(float* dst,
                                                                  float* src,
                                                                  int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_taylor4_sin(half* dst,
                                                            half* src,
                                                            half* aux1,
                                                            half* aux2,
                                                            int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Applies active with taylor4 (sine) operation on ``<src>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] aux1 The auxiliary ``__nram__`` space 1.
 * @param[in] aux2 The auxiliary ``__nram__`` space 2.
 * @param[in] elem_count Number of elements in source vector.
 * @return ``void``.
 * @remark
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>``, ``<aux1>``, ``<aux2>`` and ``<dst>`` must be 64‑byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The element value of ``<src>`` is in range [-2π, 2π] radian;
 * - When the data type of the elements of ``<src>`` is ``float``, the average relative error rate is within 1e-7; when the data type of the elements of ``<src>`` is ``half``, the average relative error rate is within 0.01;
 * - ``<aux1>`` and ``<aux2>`` must have the same size as ``<src>``;
 * - ``<dst>`` and ``<src>`` can not be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_taylor4_sin(float* dst,
                                                            float* src,
                                                            float* aux1,
                                                            float* aux2,
                                                            int elem_count);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_taylor3_sin(half* dst,
                                                            half* src,
                                                            half* aux1,
                                                            half* aux2,
                                                            int elem_count);

//Group:Stream Operation Functions
/**
 * @brief Applies active with taylor3 (sine) operation on ``<src>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] aux1 The auxiliary ``__nram__`` space 1.
 * @param[in] aux2 The auxiliary ``__nram__`` space 2.
 * @param[in] elem_count Number of elements in source vector.
 * @return ``void``.
 * @remark
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>``, ``<aux1>``, ``<aux2>`` and ``<dst>`` must be 64‑byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The element value of ``<src>`` is in the range [-2π, 2π] radian;
 * - When the data type of the elements of ``<src>`` is ``float``, the average relative error rate is within 1e-6; when the data type of the elements of ``<src>`` is ``half``, the average relative error rate is within 0.01;
 * - ``<aux1>`` and ``<aux2>`` must have the same size as ``<src>``;
 * - ``<dst>`` and ``<src>`` can not be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_taylor3_sin(float* dst,
                                                            float* src,
                                                            float* aux1,
                                                            float* aux2,
                                                            int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_taylor4_cos(half* dst,
                                                            half* src,
                                                            half* aux1,
                                                            half* aux2,
                                                            int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Applies active with taylor4 (cos) operation on ``<src>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] aux1 The auxiliary ``__nram__`` space 1.
 * @param[in] aux2 The auxiliary ``__nram__`` space 2.
 * @param[in] elem_count Number of elements in source vector.
 * @return ``void``.
 * @remark
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>``, ``<aux1>``, ``<aux2>`` and ``<dst>`` must be 64‑byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The element value of ``<src>`` is in the range [-2π, 2π] radian;
 * - When the data type of the elements of ``<src>`` is ``float``, the average relative error rate is within 1e-7; when the data type of the elements of ``<src>`` is ``half``, the average relative error rate is within 0.01;
 * - ``<aux1>`` and ``<aux2>`` must have the same size as ``<src>``;
 * - ``<dst>`` and ``<src>`` can not be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_taylor4_cos(float* dst,
                                                            float* src,
                                                            float* aux1,
                                                            float* aux2,
                                                            int elem_count);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_taylor3_cos(half* dst,
                                                            half* src,
                                                            half* aux1,
                                                            half* aux2,
                                                            int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Applies active with taylor3 (cos) operation on ``<src>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] aux1 The auxiliary ``__nram__`` space 1.
 * @param[in] aux2 The auxiliary ``__nram__`` space 2.
 * @param[in] elem_count Number of elements in source vector.
 * @return ``void``.
 * @remark
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>``, ``<aux1>``, ``<aux2>`` and ``<dst>`` must be 64‑byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The element value of ``<src>`` is in the range [-2π, 2π] radian;
 * - When the data type of the elements of ``<src>`` is ``float``, the average relative error rate is within 1e-6; when the data type of the elements of ``<src>`` is ``half``, the average relative error rate is within 0.01;
 * - ``<aux1>`` and ``<aux2>`` must have the same size as ``<src>``;
 * - ``<dst>`` and ``<src>`` can not be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_taylor3_cos(float* dst,
                                                            float* src,
                                                            float* aux1,
                                                            float* aux2,
                                                            int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_taylor4_sigmoid(half* dst,
                                                                half* src,
                                                                half* aux1,
                                                                half* aux2,
                                                                int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Applies active with taylor4 (sigmoid) operation on ``<src>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] aux1 The auxiliary ``__nram__`` space 1.
 * @param[in] aux2 The auxiliary ``__nram__`` space 2.
 * @param[in] elem_count Number of elements in source vector.
 * @return ``void``.
 * @remark
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>``, ``<aux1>``, ``<aux2>`` and ``<dst>`` must be 64‑byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The element value of ``<src>`` is in the range (-7.75, 7.75);
 * - When the data type of the elements of ``<src>`` is ``float``, the average relative error rate is within 1e-7; when the data type of the elements of ``<src>`` is ``half``, the average relative error rate is within 0.01;
 * - ``<aux1>`` and ``<aux2>`` must have the same size as ``<src>``;
 * - ``<dst>`` and ``<src>`` can not be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_taylor4_sigmoid(float* dst,
                                                                float* src,
                                                                float* aux1,
                                                                float* aux2,
                                                                int elem_count);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_taylor3_sigmoid(half* dst,
                                                                half* src,
                                                                half* aux1,
                                                                half* aux2,
                                                                int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Applies active with taylor3 (sigmoid) operation on ``<src>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] aux1 The auxiliary ``__nram__`` space 1.
 * @param[in] aux2 The auxiliary ``__nram__`` space 2.
 * @param[in] elem_count Number of elements in source vector.
 * @return ``void``.
 * @remark
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>``, ``<aux1>``, ``<aux2>`` and ``<dst>`` must be 64‑byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The element value of ``<src>`` is in the range (-7.75, 7.75);
 * - When the data type of the elements of ``<src>`` is ``float``, the average relative error rate is within 1e-6; when the data type of the elements of ``<src>`` is ``half``, the average relative error rate is within 0.01;
 * - ``<aux1>`` and ``<aux2>`` must have the same size as ``<src>``;
 * - ``<dst>`` and ``<src>`` can not be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_taylor3_sigmoid(float* dst,
                                                                float* src,
                                                                float* aux1,
                                                                float* aux2,
                                                                int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_taylor4_softplus(half* dst,
                                                                 half* src,
                                                                 half* aux1,
                                                                 half* aux2,
                                                                 int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Applies active with taylor4 (softplus) operation on ``<src>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] aux1 The auxiliary ``__nram__`` space 1.
 * @param[in] aux2 The auxiliary ``__nram__`` space 2.
 * @param[in] elem_count Number of elements in source vector.
 * @return ``void``.
 * @remark
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>``, ``<aux1>``, ``<aux2>`` and ``<dst>`` must be 64‑byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The element value of ``<src>`` is in range (-7.75, 7.75);
 * - When the data type of the elements of ``<src>`` is ``float``, the average relative error rate is within 1e-7; when the data type of the elements of ``<src>`` is ``half``, the average relative error rate is within 0.01;
 * - ``<aux1>`` and ``<aux2>`` must have the same size as ``<src>``;
 * - ``<dst>`` and ``<src>`` can not be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_taylor4_softplus(float* dst,
                                                                 float* src,
                                                                 float* aux1,
                                                                 float* aux2,
                                                                 int elem_count);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_taylor3_softplus(half* dst,
                                                                 half* src,
                                                                 half* aux1,
                                                                 half* aux2,
                                                                 int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Applies active with taylor3 (softplus) operation on ``<src>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] aux1 The auxiliary ``__nram__`` space 1.
 * @param[in] aux2 The auxiliary ``__nram__`` space 2.
 * @param[in] elem_count Number of elements in source vector.
 * @return ``void``.
 * @remark
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>``, ``<aux1>``, ``<aux2>`` and ``<dst>`` must be 64‑byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The element value of ``<src>`` is in range (-7.75, 7.75);
 * - When the data type of the elements of ``<src>`` is ``float``, the average relative error rate is within 1e-6; when the data type of the elements of ``<src>`` is ``half``, the average relative error rate is within 0.01;
 * - ``<aux1>`` and ``<aux2>`` must have the same size as ``<src>``;
 * - ``<dst>`` and ``<src>`` can not be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_taylor3_softplus(float* dst,
                                                                 float* src,
                                                                 float* aux1,
                                                                 float* aux2,
                                                                 int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_taylor4_tanh(half* dst,
                                                             half* src,
                                                             half* aux1,
                                                             half* aux2,
                                                             int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Applies active with taylor4 (tanh) operation on ``<src>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] aux1 The auxiliary ``__nram__`` space 1.
 * @param[in] aux2 The auxiliary ``__nram__`` space 2.
 * @param[in] elem_count Number of elements in source vector.
 * @return ``void``.
 * @remark
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>``, ``<aux1>``, ``<aux2>`` and ``<dst>`` must be 64‑byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The element value of ``<src>`` is in the range (-7.75, 7.75);
 * - When the data type of the elements of ``<src>`` is ``float``, the average relative error rate is within 1e-7; when the data type of the elements of ``<src>`` is ``half``, the average relative error rate is within 0.01;
 * - ``<aux1>`` and ``<aux2>`` must have the same size as ``<src>``;
 * - ``<dst>`` and ``<src>`` can not be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_taylor4_tanh(float* dst,
                                                             float* src,
                                                             float* aux1,
                                                             float* aux2,
                                                             int elem_count);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_taylor3_tanh(half* dst,
                                                             half* src,
                                                             half* aux1,
                                                             half* aux2,
                                                             int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Applies active with taylor3 (tanh) operation on ``<src>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] aux1 The auxiliary ``__nram__`` space 1.
 * @param[in] aux2 The auxiliary ``__nram__`` space 2.
 * @param[in] elem_count Number of elements in source vector.
 * @return ``void``.
 * @remark
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count> * sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>``, ``<aux1>``, ``<aux2>`` and ``<dst>`` must be 64‑byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The element value of ``<src>`` is in the range (-7.75, 7.75);
 * - When the data type of the elements of ``<src>`` is ``float``, the average relative error rate is within 1e-6; when the data type of the elements of ``<src>`` is ``half``, the average relative error rate is within 0.01;
 * - ``<aux1>`` and ``<aux2>`` must have the same size as ``<src>``;
 * - ``<dst>`` and ``<src>`` can not be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_taylor3_tanh(float* dst,
                                                             float* src,
                                                             float* aux1,
                                                             float* aux2,
                                                             int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_active_exp(half* dst,
                                                           half* src,
                                                           int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Applies active (exponent) operation on source operand ``<src>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count Number of elements in source vector.
 * @return ``void``.
 * @remark
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count> * sizeof(type)`` must be 128-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - When the data type of the elements of ``<src>`` is ``float``, the element value is in the range [-3.4e38, 10.25]; when the data type of the elements of ``<src>`` is ``half``, the element value is in the range [-65504, 10.25];
 * - The result is 5.96e-8, when the element value of ``<src>`` is less than -7.75;
 * - Average relative error: within 0.01;
 * - ``<dst>`` and ``<src>`` can be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_active_exp(float* dst,
                                                           float* src,
                                                           int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_active_exphp(half* dst,
                                                             half* src,
                                                             int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Applies high precision active (exponent) operation on source operand ``<src>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count Number of elements in source vector.
 * @return ``void``.
 * @remark
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count> * sizeof(type)`` must be 128-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - When the data type of the elements of ``<src>`` is ``float``, the element value is in the range [-3.4e38, 16]; when the data type of the elements of ``<src>`` is ``half``, the element value is in the range [-65504, 10.25];
 * - When the element value of ``<src>`` is less than -15 for the data type of ``float``, the result is 3e-7; when the element value of ``<src>`` is less than -7.75 for the data type of ``half``, the result is 5.96e-8;
 * - When the data type of the elements of ``<src>`` is ``float``, the average relative error is within 0.003; when the data type of the elements of ``<src>`` is ``half``, the average relative error is within 0.007;
 * - ``<dst>`` and ``<src>`` can be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_active_exphp(float* dst,
                                                             float* src,
                                                             int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_active_exp_less_0(half* dst,
                                                                  half* src,
                                                                  int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Applies active (exponent) operation on source operand ``<src>`` when the value of ``<src>`` is less than 0.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count Number of elements in source vector.
 * @return ``void``.
 * @remark
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count> * sizeof(type)`` must be 128-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - When the data type of the elements of ``<src>`` is ``float``, the element value is in the range [-3.4e38, 0]; when the data type of the elements of ``<src>`` is ``half``, the element value is in the range [-65504, 0];
 * - The result is 5.96e-8, when the element value of ``<src>`` is less than -15.5;
 * - When the data type of the elements of ``<src>`` is ``float``, the average relative error is within 0.003; when the data type of the elements of ``<src>`` is ``half``, the average relative error is within 0.01;
 * - ``<dst>`` and ``<src>`` can be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_active_exp_less_0(float* dst,
                                                                  float* src,
                                                                  int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_active_sqrt(half* dst,
                                                            half* src,
                                                            int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Applies active (sqrt) operation on ``<src>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count Number of elements in source vector.
 * @return ``void``.
 * @remark
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count> * sizeof(type)`` must be 128-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The element value of ``<src>`` is in the range [0, 63487];
 * - Average relative error: within 0.01;
 * - ``<dst>`` and ``<src>`` can be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_active_sqrt(float* dst,
                                                            float* src,
                                                            int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_active_sqrthp(half* dst,
                                                              half* src,
                                                              int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Applies high precision active (exponent) operation on source operand ``<src>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count Number of elements in source vector.
 * @return ``void``.
 * @remark
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count> * sizeof(type)`` must be 128-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - When the data type of the elements of ``<src>`` is ``float``, the element value is in the range [0, 677268]; when the data type of the elements of ``<src>`` is ``half``, the element value is in the range [0, 65504];
 * - Average relative error: within 0.003;
 * - ``<dst>`` and ``<src>`` can be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_active_sqrthp(float* dst,
                                                              float* src,
                                                              int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_active_rsqrt(half* dst,
                                                             half* src,
                                                             int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Applies active (rsqrt) operation on ``<src>``,  \f$<dst> = 1 \div sqrt{<src>}\f$.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count Number of elements in source vector.
 * @return ``void``.
 * @remark
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count> * sizeof(type)`` must be 128-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The element value of ``<src>`` is in the range [0.005, 63487];
 * - Average relative error: within 0.01;
 * - ``<dst>`` and ``<src>`` can be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_active_rsqrt(float* dst,
                                                             float* src,
                                                             int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_active_rsqrthp(half* dst,
                                                               half* src,
                                                               int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Applies high precision active (rsqrt) operation on source operand ``<src>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count Number of elements in source vector.
 * @return ``void``.
 * @remark
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count> * sizeof(type)`` must be 128-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - When the data type of the elements of ``<src>`` is ``float``, the element value is in the range [0.000367, 1e6]; when the data type of the elements of ``<src>`` is ``half``, the element value is in the range [0.000367, 65504];
 * - Average relative error: within 0.0005;
 * - ``<dst>`` and ``<src>`` can be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_active_rsqrthp(float* dst,
                                                               float* src,
                                                               int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_active_recip(half* dst,
                                                             half* src,
                                                             int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Applies active (reciprocal) operation on ``<src>``.
 *
 * @details
 * \rst
 *      .. figure:: ../img/11.4.*
 *
 *         Reciprocal Process
 * \endrst
 *
 * \rst
 *      .. Hint::
 *         | Recip means reciprocal.
 * \endrst
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count Number of elements in source vector.
 * @return ``void``.
 * @remark
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count> * sizeof(type)`` must be 128-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The element values of ``<src>`` are in the range [0.00391, 63487];
 * - When the data type of the elements of ``<src>`` is ``float``, the average relative error is within 0.003; when the data type of the elements of ``<src>`` is ``half``, the average relative error is within 0.01;
 * - ``<dst>`` and ``<src>`` can be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define LEN 64
 *
 *   __mlu_entry__ void kernel(half* y, half* x) {
 *     __nram__ half ny[LEN];
 *     __nram__ half nx[LEN];
 *     __memcpy(ny, y, LEN * sizeof(half), GDRAM2NRAM);
 *     __memcpy(nx, x, LEN * sizeof(half), GDRAM2NRAM);
 *     __bang_active_recip(ny, nx, LEN);
 *     __memcpy(y, ny, LEN * sizeof(half), NRAM2GDRAM);
 *   }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_active_recip(float* dst,
                                                             float* src,
                                                             int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_active_reciphp(half* dst,
                                                               half* src,
                                                               int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Applies high precision active (reciprocal) operation on source operand ``<src>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count Number of elements in source vector.
 * @return ``void``.
 * @remark
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count> * sizeof(type)`` must be 128-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - When the data type of the elements of ``<src>`` is ``float``, the element value is in the range [0.00391, 2e6]; when the data type of the elements of ``<src>`` is ``half``, the element value is in the range [0.00391, 65504];
 * - Average relative error: within 0.0004;
 * - ``<dst>`` and ``<src>`` can be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_active_reciphp(float* dst,
                                                               float* src,
                                                               int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_active_recip_greater_1(half* dst,
                                                                       half* src,
                                                                       int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Applies active (reciprocal) operation on ``<src>`` when the value of ``<src>`` is greater than 1.
 *
 * @details
 * \rst
 *      .. Hint::
 *         | Recip means reciprocal.
 * \endrst
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count Number of elements in source vector.
 * @return ``void``.
 * @remark
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count> * sizeof(type)`` must be 128-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The element values of ``<src>`` are in the range [1, 63487];
 * - When the data type of the elements of ``<src>`` is ``float``, the average relative error is within 0.003; when the data type of the elements of ``<src>`` is ``half``, the average relative error is within 0.01;
 * - ``<dst>`` and ``<src>`` can be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_active_recip_greater_1(float* dst,
                                                                       float* src,
                                                                       int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_active_sin(half* dst,
                                                           half* src,
                                                           int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Applies active (sine) operation on ``<src>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count Number of elements in source vector.
 * @return ``void``.
 * @remark
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count> * sizeof(type)`` must be 128-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The element value of ``<src>`` is in the range [-2π, 2π] radian;
 * - Average relative error: within 0.01;
 * - ``<dst>`` and ``<src>`` can be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_active_sin(float* dst,
                                                           float* src,
                                                           int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_active_cos(half* dst,
                                                           half* src,
                                                           int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Applies active (cosine) operation on ``<src>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count Number of elements in source vector.
 * @return ``void``.
 * @remark
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count> * sizeof(type)`` must be 128-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The element value of ``<src>`` is in the range [-2π, 2π] radian;
 * - Average relative error: within 0.01;
 * - ``<dst>`` and ``<src>`` can be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_active_cos(float* dst,
                                                           float* src,
                                                           int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_active_log(half* dst,
                                                           half* src,
                                                           int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Applies active (log base e) operation on ``<src>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count Number of elements in source vector.
 * @return ``void``.
 * @remark
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count> * sizeof(type)`` must be 128-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The element value of ``<src>`` is in the range [6.1e-5, 63484];
 * - Average relative error: within 0.01;
 * - ``<dst>`` and ``<src>`` can be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_active_log(float* dst,
                                                           float* src,
                                                           int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_active_loghp(half* dst,
                                                             half* src,
                                                             int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Applies high precision active (log base e) operation on source operand ``<src>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count Number of elements in source vector.
 * @return ``void``.
 * @remark
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count> * sizeof(type)`` must be 128-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - When the data type of the elements of ``<src>`` is ``float``, the element value is in the range [7.2e-9, 507903]; when the data type of the elements of ``<src>`` is ``half``, the element value is in the range [6.1e-5, 65504];
 * - When the data type of the elements of ``<src>`` is ``float``, the average relative error is within 0.001; when the data type of the elements of ``<src>`` is ``half``, the average relative error is within 0.002;
 * - ``<dst>`` and ``<src>`` can be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_active_loghp(float* dst,
                                                             float* src,
                                                             int elem_count);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_active_sign(half* dst,
                                                            half* src,
                                                            int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Applies active (sign) operation on ``<src>``. If \f$<src> \ge 0.0\f$, then, stores 1.0 in ``<dst>``; otherwise, stores -1.0 in ``<dst>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count Number of elements in source vector.
 * @return ``void``.
 * @remark
 * - This interface is supported on ``(m)tp_2xx`` and higher;
 * - ``<elem_count>`` must be greater than zero;
 * - ``<elem_count> * sizeof(type)`` must be 128-byte aligned on ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - When the data type of the elements of ``<src>`` is ``float``, the element value is in the range [-3.4e38, 3.4e38]; when the data type of the elements of ``<src>`` is ``half``, the element value is in the range [-65504, 65504];
 * - When the element value of ``<src>`` is -0 or +0, the corresponding result is 1;
 * - Average relative error: 0;
 * - ``<dst>`` and ``<src>`` can be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_active_sign(float* dst,
                                                            float* src,
                                                            int elem_count);

static __mlu_func__ __mlu_builtin__ void __bang_active_f16(half* dst,
                                                           half* src,
                                                           half* active_table,
                                                           half* const_table,
                                                           int elem_count,
                                                           int every_acttab_elem_count,
                                                           int seg_num);

static __mlu_func__ __mlu_builtin__ void __bang_active_f32(float* dst,
                                                           float* src,
                                                           float* active_table,
                                                           float* const_table,
                                                           int elem_count,
                                                           int every_acttab_elem_count,
                                                           int seg_num);

//Group:Surpass Operation Functions
/**
 * @brief Calculates the sine of ``<src>``.
 *
 * @details This function computes the sine of each element in ``<src>`` and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count Number of elements in source and destination.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<elem_count>`` must be a positive integer;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_unary_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *   - BANG Version: ``__BANG_ARCH__ >= 322`` ;
 *   - CNCC Version: ``cncc --version >= 3.0.0`` ;
 *   - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30`` ;
 *   - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322`` .
 *
 * @par Example
 * @code
 *
 *    #include <bang.h>
 *
 *    #define DATA_NUM 128
 *
 *    __mlu_entry__ void kernel(float *output, float *src) {
 *      __nram__ float _src[DATA_NUM];
 *      __nram__ float _output[DATA_NUM];
 *      __memcpy(_src, src, DATA_NUM * sizeof(float), GDRAM2NRAM);
 *      __bang_sin(_output, _src, DATA_NUM);
 *      __memcpy(output, _output, DATA_NUM * sizeof(float), NRAM2GDRAM);
 *    }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_sin(float* dst,
                                                    float* src,
                                                    int elem_count);

//Group:Surpass Operation Functions
/**
 * @brief Calculates the cosine of ``<src>``.
 *
 * @details This function computes the cosine of each element in ``<src>`` and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count Number of elements in source and destination.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<elem_count>`` must be a positive integer;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_unary_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *   - BANG Version: ``__BANG_ARCH__ >= 322`` ;
 *   - CNCC Version: ``cncc --version >= 3.0.0`` ;
 *   - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30`` ;
 *   - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322`` .
 *
 * @par Example
 * - See the example of ::__bang_sin for more details.
 */
static __mlu_func__ __mlu_builtin__ void __bang_cos(float* dst,
                                                    float* src,
                                                    int elem_count);

//Group:Surpass Operation Functions
/**
 * @brief Calculates the binary logarithm of ``<src>``.
 *
 * @details This function computes the binary logarithm of each element in ``<src>`` and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count Number of elements in source and destination.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<elem_count>`` must be a positive integer;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_unary_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *   - BANG Version: ``__BANG_ARCH__ >= 322`` ;
 *   - CNCC Version: ``cncc --version >= 3.0.0`` ;
 *   - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30`` ;
 *   - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322`` .
 *
 * @par Example
 * - See the example of ::__bang_sin for more details.
 */
static __mlu_func__ __mlu_builtin__ void __bang_log(float* dst,
                                                    float* src,
                                                    int elem_count);

//Group:Surpass Operation Functions
/**
 * @brief Calculates the value of 2 to the power of ``<src>``.
 *
 * @details This function computes the value of 2 to the power of ``<src>`` and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count Number of elements in source and destination.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<elem_count>`` must be a positive integer;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_unary_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *   - BANG Version: ``__BANG_ARCH__ >= 322`` ;
 *   - CNCC Version: ``cncc --version >= 3.0.0`` ;
 *   - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30`` ;
 *   - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322`` .
 *
 * @par Example
 * - See the example of ::__bang_sin for more details.
 */
static __mlu_func__ __mlu_builtin__ void __bang_pow2(float* dst,
                                                     float* src,
                                                     int elem_count);

//Group:Surpass Operation Functions
/**
 * @brief Calculates the square root of ``<src>``.
 *
 * @details This function computes the square root of each element in ``<src>`` and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count Number of elements in source and destination.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<elem_count>`` must be a positive integer;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_unary_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *   - BANG Version: ``__BANG_ARCH__ >= 322`` ;
 *   - CNCC Version: ``cncc --version >= 3.0.0`` ;
 *   - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30`` ;
 *   - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322`` .
 *
 * @par Example
 * - See the example of ::__bang_sin for more details.
 */
static __mlu_func__ __mlu_builtin__ void __bang_sqrt(float* dst,
                                                     float* src,
                                                     int elem_count);

//Group:Surpass Operation Functions
/**
 * @brief Calculates the reciprocal of ``<src>``.
 *
 * @details This function computes the reciprocal of each element in ``<src>`` and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count Number of elements in source and destination.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<elem_count>`` must be a positive integer;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_unary_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *   - BANG Version: ``__BANG_ARCH__ >= 322`` ;
 *   - CNCC Version: ``cncc --version >= 3.0.0`` ;
 *   - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30`` ;
 *   - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322`` .
 *
 * @par Example
 * - See the example of ::__bang_sin for more details.
 */
static __mlu_func__ __mlu_builtin__ void __bang_recip(float* dst,
                                                      float* src,
                                                      int elem_count);

//Group:Surpass Operation Functions
/**
 * @brief Calculates the reciprocal of the square root of ``<src>``.
 *
 * @details This function computes the reciprocal of square root of each element in ``<src>`` and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of source vector.
 * @param[in] elem_count Number of elements in source and destination.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<elem_count>`` must be a positive integer;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<dst>`` and ``<src>`` can be homologous operands;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_unary_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *   - BANG Version: ``__BANG_ARCH__ >= 322`` ;
 *   - CNCC Version: ``cncc --version >= 3.0.0`` ;
 *   - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30`` ;
 *   - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322`` .
 *
 * @par Example
 * - See the example of ::__bang_sin for more details.
 */
static __mlu_func__ __mlu_builtin__ void __bang_rsqrt(float* dst,
                                                      float* src,
                                                      int elem_count);

//Group:Surpass Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_rem(short* dst,
                                                    short* src0,
                                                    short* src1,
                                                    int elem_count);
//Group:Surpass Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_rem(int* dst,
                                                    int* src0,
                                                    int* src1,
                                                    int elem_count);
//Group:Surpass Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_rem(unsigned short* dst,
                                                    unsigned short* src0,
                                                    unsigned short* src1,
                                                    int elem_count);
//Group:Surpass Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_rem(unsigned int* dst,
                                                    unsigned int* src0,
                                                    unsigned int* src1,
                                                    int elem_count);
//Group:Surpass Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_rem(short* dst,
                                                    short* src0,
                                                    short src1,
                                                    int elem_count);
//Group:Surpass Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_rem(int* dst,
                                                    int* src0,
                                                    int src1,
                                                    int elem_count);
//Group:Surpass Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_rem(unsigned short* dst,
                                                    unsigned short* src0,
                                                    unsigned short src1,
                                                    int elem_count);
//Group:Surpass Operation Functions
/**
 * @brief Calculates the remainder of ``<src>``.
 *
 * @details This function computes the remainder of each element in ``<src>`` and saves the result in ``<dst>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src0 The address of first source vector.
 * @param[in] src1 The address of second source vector, or the value of second source scalar.
 * @param[in] elem_count Number of elements in source and destination.
 * @return ``void``.
 * @remark
 * - ``<elem_count>`` must be a positive integer;
 * - ``<dst>`` and ``<src0>`` must point to ``__nram__`` space;
 * - ``<src1>`` must point to ``__nram__`` space if it is the address of second source vector;
 * - The value of ``<src1>`` can not be equal to zero;
 * - ``<dst>``, ``<src0>`` and ``<src1>`` (vector address) can be homologous operands.
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *   - BANG Version: ``__BANG_ARCH__ >= 322`` && ``__BANG_ARCH__ != 372``;
 *   - CNCC Version: ``cncc --version >= 3.0.0`` ;
 *   - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30`` && ``--bang-mlu-arch != mtp_372``;
 *   - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322`` && ``--bang-mlu-arch != mtp_372``.
 *
 * @par Example
 * @code
 *
 *    #include <bang.h>
 *
 *    #define DATA_NUM 128
 *
 *    __mlu_entry__ void kernel(int *output, int *src) {
 *      __nram__ int _src[DATA_NUM];
 *      __nram__ int _output[DATA_NUM];
 *      __memcpy(_src, src, DATA_NUM * sizeof(int), GDRAM2NRAM);
 *      __bang_rem(_output, _src, 10, DATA_NUM);
 *      __memcpy(output, _output, DATA_NUM * sizeof(int), NRAM2GDRAM);
 *    }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_rem(unsigned int* dst,
                                                    unsigned int* src0,
                                                    unsigned int src1,
                                                    int elem_count);
//Group:Stream Comparison Functions
/**
 * @brief Finds maximum value of each two corresponding elements in two vectorsbetween which the distance is ``<distance>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src The address of first source vector.
 * @param[in] distance The distance between the two source vector.
 * @param[in] size The elements number of destination vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<elem_count> * sizeof (type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src>`` can not be homologous operands;
 * - ``<size>`` must be greater than zero;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_operation_functions_with_elementwise` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 *
 */
static __mlu_func__ __mlu_builtin__ void __bang_maximum(half* dst,
                                                        half* src,
                                                        int distance,
                                                        int size);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_pad(half* dst,
                                                    half* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_height,
                                                    int pad_width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_pad(half* dst,
                                                    half* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_top,
                                                    int pad_bottom,
                                                    int pad_left,
                                                    int pad_right);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_pad(short* dst,
                                                    short* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_height,
                                                    int pad_width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_pad(short* dst,
                                                    short* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_top,
                                                    int pad_bottom,
                                                    int pad_left,
                                                    int pad_right);
static __mlu_func__ __mlu_builtin__ void __bang_pad(unsigned short* dst,
                                                    unsigned short* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_height,
                                                    int pad_width);
static __mlu_func__ __mlu_builtin__ void __bang_pad(unsigned short* dst,
                                                    unsigned short* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_top,
                                                    int pad_bottom,
                                                    int pad_left,
                                                    int pad_right);
static __mlu_func__ __mlu_builtin__ void __bang_pad(int8* dst,
                                                    int8* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_height,
                                                    int pad_width);
static __mlu_func__ __mlu_builtin__ void __bang_pad(int8* dst,
                                                    int8* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_top,
                                                    int pad_bottom,
                                                    int pad_left,
                                                    int pad_right);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_pad(char* dst,
                                                    char* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_height,
                                                    int pad_width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_pad(char* dst,
                                                    char* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_top,
                                                    int pad_bottom,
                                                    int pad_left,
                                                    int pad_right);
static __mlu_func__ __mlu_builtin__ void __bang_pad(unsigned char* dst,
                                                    unsigned char* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_height,
                                                    int pad_width);
static __mlu_func__ __mlu_builtin__ void __bang_pad(unsigned char* dst,
                                                    unsigned char* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_top,
                                                    int pad_bottom,
                                                    int pad_left,
                                                    int pad_right);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_pad(float* dst,
                                                    float* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_height,
                                                    int pad_width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_pad(float* dst,
                                                    float* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_top,
                                                    int pad_bottom,
                                                    int pad_left,
                                                    int pad_right);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_pad(int* dst,
                                                    int* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_height,
                                                    int pad_width);
static __mlu_func__ __mlu_builtin__ void __bang_pad(unsigned int* dst,
                                                    unsigned int* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_top,
                                                    int pad_bottom,
                                                    int pad_left,
                                                    int pad_right);
static __mlu_func__ __mlu_builtin__ void __bang_pad(unsigned int* dst,
                                                    unsigned int* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_height,
                                                    int pad_width);
static __mlu_func__ __mlu_builtin__ void __bang_pad(half* dst,
                                                    half* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_height,
                                                    int pad_width,
                                                    half pad_value);
static __mlu_func__ __mlu_builtin__ void __bang_pad(half* dst,
                                                    half* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_top,
                                                    int pad_bottom,
                                                    int pad_left,
                                                    int pad_right,
                                                    half pad_value);
static __mlu_func__ __mlu_builtin__ void __bang_pad(short* dst,
                                                    short* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_height,
                                                    int pad_width,
                                                    short pad_value);
static __mlu_func__ __mlu_builtin__ void __bang_pad(short* dst,
                                                    short* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_top,
                                                    int pad_bottom,
                                                    int pad_left,
                                                    int pad_right,
                                                    short pad_value);
static __mlu_func__ __mlu_builtin__ void __bang_pad(char* dst,
                                                    char* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_height,
                                                    int pad_width,
                                                    char pad_value);
static __mlu_func__ __mlu_builtin__ void __bang_pad(char* dst,
                                                    char* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_top,
                                                    int pad_bottom,
                                                    int pad_left,
                                                    int pad_right,
                                                    char pad_value);
static __mlu_func__ __mlu_builtin__ void __bang_pad(float* dst,
                                                    float* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_height,
                                                    int pad_width,
                                                    float pad_value);
static __mlu_func__ __mlu_builtin__ void __bang_pad(float* dst,
                                                    float* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_top,
                                                    int pad_bottom,
                                                    int pad_left,
                                                    int pad_right,
                                                    float pad_value);
static __mlu_func__ __mlu_builtin__ void __bang_pad(int* dst,
                                                    int* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_height,
                                                    int pad_width,
                                                    int pad_value);
static __mlu_func__ __mlu_builtin__ void __bang_pad(int* dst,
                                                    int* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_top,
                                                    int pad_bottom,
                                                    int pad_left,
                                                    int pad_right,
                                                    int pad_value);
static __mlu_func__ __mlu_builtin__ void __bang_pad(bfloat16_t* dst,
                                                    bfloat16_t* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_height,
                                                    int pad_width,
                                                    bfloat16_t pad_value);
static __mlu_func__ __mlu_builtin__ void __bang_pad(bfloat16_t* dst,
                                                    bfloat16_t* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_top,
                                                    int pad_bottom,
                                                    int pad_left,
                                                    int pad_right,
                                                    bfloat16_t pad_value);

//Group:Stream Operation Functions
/**
 * @brief Applies zero-padding operation on ``<src>``.
 *
 * @details
 *
 * @param[out] dst The destination vector, whose data layout is HWC.
 * @param[in] src The source vector, whose data layout is HWC.
 * @param[in] channel Number of channels.
 * @param[in] height The height of ``<src>``.
 * @param[in] width The width of ``<src>``.
 * @param[in] pad_top Number of rows whose elements is all zero on the top of pad.
 * @param[in] pad_bottom Number of rows whose elements is all zero on the bottom of pad.
 * @param[in] pad_left Number of columns whose elements is all zero on the left of pad.
 * @param[in] pad_right Number of columns whose elements is all zero on the right of pad.
 * @param[in] pad_width ``<pad_left> + <pad_right>``.
 * @param[in] pad_height ``<pad_top> + <pad_bottom>``.
 * @return ``void``.
 * @remark
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<channel> * <width> * sizeof(type)`` must be 128-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``(<pad_width> + <pad_width>) * <channel> * sizeof(type)`` must be 128-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``(<pad_left> + <pad_right>) * <channel> * sizeof(type)`` must be 128-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``(<pad_height> * (<pad_width> + <pad_width> + <width>) + <pad_width>) * <channel> * sizeof(type)`` must be 128-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``(<pad_top> * (<pad_left> + <pad_right> + <width>) + <pad_left>) * <channel> * sizeof(type)`` must be 128-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``(<pad_bottom> * (<pad_left> + <pad_right> + <width>) + <pad_right>) * <channel> * sizeof(type)`` must be 128-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<height>`` must be greater than 0;
 * - If ``<height> == 1``, ``(<pad_left> + <pad_right>) * <channel> * sizeof(type)`` and ``(<pad_width> + <pad_width>) * <channel> * sizeof(type)`` must less than 64 bytes on ``(m)tp_3xx``;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src>`` can not be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *    #include<bang.h>
 *
 *    #define PAD_H 1
 *    #define PAD_W 2
 *    #define INPUT_H 4
 *    #define INPUT_W 4
 *    #define CHANNEL 64
 *
 *    __mlu_entry__ void kernel(half *out, half *in) {
 *      __nram__ half nx[CHANNEL * INPUT_H * INPUT_W];
 *      __nram__ half ny[CHANNEL * (INPUT_H + 2 * PAD_H) * (INPUT_W + 2 * PAD_W)];
 *      __memcpy(nx, in, CHANNEL * INPUT_H * INPUT_W * sizeof(half), GDRAM2NRAM);
 *      __bang_pad(ny, nx, CHANNEL, INPUT_H, INPUT_W, PAD_H, PAD_W);
 *      __memcpy(out, ny, CHANNEL * (INPUT_H + 2 * PAD_H) * (INPUT_W + 2 * PAD_W) * sizeof(half), NRAM2GDRAM);
 *    }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_pad(int* dst,
                                                    int* src,
                                                    int channel,
                                                    int height,
                                                    int width,
                                                    int pad_top,
                                                    int pad_bottom,
                                                    int pad_left,
                                                    int pad_right);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_transpose(half* dst,
                                                          half* src,
                                                          int height,
                                                          int width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_transpose(short* dst,
                                                          short* src,
                                                          int height,
                                                          int width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_transpose(unsigned short* dst,
                                                          unsigned short* src,
                                                          int height,
                                                          int width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_transpose(int8* dst,
                                                          int8* src,
                                                          int height,
                                                          int width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_transpose(char* dst,
                                                          char* src,
                                                          int height,
                                                          int width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_transpose(unsigned char* dst,
                                                          unsigned char* src,
                                                          int height,
                                                          int width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_transpose(float* dst,
                                                          float* src,
                                                          int height,
                                                          int width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_transpose(int* dst,
                                                          int* src,
                                                          int height,
                                                          int width);

//Group:Stream Operation Functions
/**
 * @brief Transposes operand ``src[height][width]``, a matrix, to ``dst[width][height]``.
 *
 * @details
 *
 * @param[out] dst The address of destination matrix, and the matrix has WH data layout.
 * @param[in] src The address of source matrix, and the matrix has HW data layout.
 * @param[in] height The height of ``<src>``.
 * @param[in] width The width of ``<src>``.
 * @return ``void``.
 * @remark
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<height> * sizeof(type)`` and ``<width> * sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src>`` can not be homologous operands;
 * - ``<height>`` and ``<width>`` must be greater than zero.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *    #include <bang.h>
 *
 *    #define WIDTH 128
 *    #define HEIGHT 64
 *    #define LEN (HEIGHT * WIDTH)
 *
 *    __mlu_entry__ void kernel(short* dst, short* src) {
 *      __nram__ short ny[LEN];
 *      __nram__ short nx[LEN];
 *     __memcpy(nx, src, LEN * sizeof(short), GDRAM2NRAM);
 *     __bang_transpose(ny, nx, HEIGHT, WIDTH);
 *     __memcpy(dst, ny, LEN * sizeof(short), NRAM2GDRAM);
 *   }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_transpose(unsigned int* dst,
                                                          unsigned int* src,
                                                          int height,
                                                          int width);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_rotate90(int8* dst,
                                                         int8* src,
                                                         int height,
                                                         int width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_rotate90(char* dst,
                                                         char* src,
                                                         int height,
                                                         int width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_rotate90(unsigned char* dst,
                                                         unsigned char* src,
                                                         int height,
                                                         int width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_rotate90(half* dst,
                                                         half* src,
                                                         int height,
                                                         int width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_rotate90(short* dst,
                                                         short* src,
                                                         int height,
                                                         int width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_rotate90(unsigned short* dst,
                                                         unsigned short* src,
                                                         int height,
                                                         int width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_rotate90(float* dst,
                                                         float* src,
                                                         int height,
                                                         int width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_rotate90(int* dst,
                                                         int* src,
                                                         int height,
                                                         int width);

//Group:Stream Operation Functions
/**
 * @brief Rotates ``<src>`` , a matrix, whose size is ``<height>`` * ``<width>`` , by 90 degrees in clockwise direction, and stores the result in ``<dst>`` .
 *
 * @details
 *
 * @param[out] dst The address of destination matrix.
 * @param[in] src The address of source matrix.
 * @param[in] height The height of ``<src>``.
 * @param[in] width The width of ``<src>``.
 * @return ``void``.
 * @remark
 * - This interface only supported on ``(m)tp_2xx`` and higher;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<height> * sizeof(type)`` and ``<width>`` * sizeof(type) must be divisible by 128 bytes on ``(m)tp_2xx``;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src>`` can not be homologous operands;
 * - ``<height>`` and ``<width>`` must be greater than zero.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   #define WIDTH 128
 *   #define HEIGHT 64
 *   #define LEN (HEIGHT * WIDTH)
 *
 *   __mlu_entry__ void kernel(unsigned char* dst, unsigned char* src) {
 *     __nram__ unsigned char ny[LEN];
 *     __nram__ unsigned char nx[LEN];
 *     __memcpy(nx, src, LEN * sizeof(unsigned char), GDRAM2NRAM);
 *     __bang_rotate90(ny, nx, HEIGHT, WIDTH);
 *     __memcpy(dst, ny, LEN * sizeof(unsigned char), NRAM2GDRAM);
 *   }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_rotate90(unsigned int* dst,
                                                         unsigned int* src,
                                                         int height,
                                                         int width);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_rotate180(int8* dst,
                                                          int8* src,
                                                          int height,
                                                          int width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_rotate180(char* dst,
                                                          char* src,
                                                          int height,
                                                          int width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_rotate180(unsigned char* dst,
                                                          unsigned char* src,
                                                          int height,
                                                          int width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_rotate180(half* dst,
                                                          half* src,
                                                          int height,
                                                          int width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_rotate180(short* dst,
                                                          short* src,
                                                          int height,
                                                          int width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_rotate180(unsigned short* dst,
                                                          unsigned short* src,
                                                          int height,
                                                          int width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_rotate180(float* dst,
                                                          float* src,
                                                          int height,
                                                          int width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_rotate180(int* dst,
                                                          int* src,
                                                          int height,
                                                          int width);

//Group:Stream Operation Functions
/**
 * @brief Rotates ``<src>`` , a matrix, whose size is ``<height>`` * ``<width>`` , by 180 degrees in clockwise direction, and stores the result in ``<dst>`` .
 *
 * @details
 *
 * @param[out] dst The address of destination matrix.
 * @param[in] src The address of source matrix.
 * @param[in] height The height of ``<src>``.
 * @param[in] width The width of ``<src>``.
 * @return ``void``.
 * @remark
 * - This interface only supported on ``(m)tp_2xx`` and higher;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<height>`` * sizeof(type) and ``<width>`` * sizeof(type) must be divisible by 128 bytes on ``(m)tp_2xx``;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src>`` can not be homologous operands;
 * - ``<height>`` and ``<width>`` must be greater than zero.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_rotate180(unsigned int* dst,
                                                          unsigned int* src,
                                                          int height,
                                                          int width);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_rotate270(int8* dst,
                                                          int8* src,
                                                          int height,
                                                          int width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_rotate270(char* dst,
                                                          char* src,
                                                          int height,
                                                          int width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_rotate270(unsigned char* dst,
                                                          unsigned char* src,
                                                          int height,
                                                          int width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_rotate270(half* dst,
                                                          half* src,
                                                          int height,
                                                          int width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_rotate270(short* dst,
                                                          short* src,
                                                          int height,
                                                          int width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_rotate270(unsigned short* dst,
                                                          unsigned short* src,
                                                          int height,
                                                          int width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_rotate270(float* dst,
                                                          float* src,
                                                          int height,
                                                          int width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_rotate270(int* dst,
                                                          int* src,
                                                          int height,
                                                          int width);

//Group:Stream Operation Functions
/**
 * @brief Rotates ``<src>`` , a matrix, whose size is ``<height>`` * ``<width>`` , by 270 degrees in clockwise direction, and stores the result in ``<dst>`` .
 *
 * @details
 *
 * @param[out] dst The address of destination matrix.
 * @param[in] src The address of source matrix.
 * @param[in] height The height of ``<src>``.
 * @param[in] width The width of ``<src>``.
 * @return ``void``.
 * @remark
 * - This interface only supported on ``(m)tp_2xx`` and higher;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<height>`` * sizeof(type) and ``<width>`` * sizeof(type) must be divisible by 128 bytes on ``(m)tp_2xx``;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src>`` can not be homologous operands;
 * - ``<height>`` and ``<width>`` must be greater than zero.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_rotate270(unsigned int* dst,
                                                          unsigned int* src,
                                                          int height,
                                                          int width);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_mirror(int8* dst,
                                                       int8* src,
                                                       int height,
                                                       int width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_mirror(char* dst,
                                                       char* src,
                                                       int height,
                                                       int width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_mirror(unsigned char* dst,
                                                       unsigned char* src,
                                                       int height,
                                                       int width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_mirror(unsigned short* dst,
                                                       unsigned short* src,
                                                       int height,
                                                       int width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_mirror(short* dst,
                                                       short* src,
                                                       int height,
                                                       int width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_mirror(half* dst,
                                                       half* src,
                                                       int height,
                                                       int width);

//Group:Stream Operation Functions
/**
 * @brief Flips ``<src>``, a matrix whose size is ``<height>`` * ``<width>``, in the left/right direction, and stores the result in ``<dst>``.
 *
 * @details
 *
 * @param[out] dst The address of destination matrix.
 * @param[in] src The address of source matrix.
 * @param[in] height The width of ``<src>``.
 * @param[in] width The height of ``<src>``.
 * @return ``void``.
 * @remark
 * - This interface only supported on ``(m)tp_2xx`` and higher;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<width>`` * sizeof(type) must be divisible by 128 bytes on ``(m)tp_2xx``;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<dst>`` and ``<src>`` can not be homologous operands;
 * - ``<height>`` and ``<width>`` must be greater than zero.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *    #include <bang.h>
 *
 *    #define WIDTH 64
 *    #define HEIGHT 32
 *    #define LEN (WIDTH * HEIGHT)
 *
 *    __mlu_entry__ void kernel(short* dst, short* src) {
 *      __nram__ short ny[LEN];
 *      __nram__ short nx[LEN];
 *      __memcpy(nx, src, LEN * sizeof(short), GDRAM2NRAM);
 *      __bang_mirror(ny, nx, HEIGHT, WIDTH);
 *      __memcpy(dst, ny, sizeof(short) * LEN, NRAM2GDRAM);
 *    }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_mirror(unsigned int* dst,
                                                       unsigned int* src,
                                                       int height,
                                                       int width);

//Group:Stream Operation Functions
/**
 * @brief Applies 2D tiling operation on ``<src>``.
 *
 * @details
 *
 * @param[out] dst The address of output matrix.
 * @param[in] src The address of input matrix.
 * @param[in] n2 Tiling input iteration 2.
 * @param[in] s2 Tiling input stride 2.
 * @param[in] n1 Tiling input iteration 1.
 * @param[in] s1 Tiling input stride 1.
 * @param[in] n7 Tiling output iteration 2.
 * @param[in] s7 Tiling output stride 2.
 * @param[in] n6 Tiling output iteration 1.
 * @param[in] s6 Tiling output stride 1.
 * @return ``void``.
 * @remark
 * - This interface is supported on ``(m)tp_2xx`` and higher;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - \f$<n1> \times <n2> = <n6> \times <n7> = 64\f$;
 * - ``<n1>``, ``<n2>``, ``<n6>`` and ``<n7>`` must be an immediate integer;
 * - ``<s1>``, ``<s2>``, ``<s6>`` and ``<s7>`` must be greater than or equal to zero;
 * - Unit of ``<s1>``, ``<s2>``, ``<s6>``, ``<s7>`` is 64 bytes;
 * - ``<dst>`` and ``<src>`` can not be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_tiling_2d_b8(void* dst,
                                                             void* src,
                                                             int n2,
                                                             int s2,
                                                             int n1,
                                                             int s1,
                                                             int n7,
                                                             int s7,
                                                             int n6,
                                                             int s6);

//Group:Stream Operation Functions
/**
 * @brief Applies 2D tiling operation on ``<src>``.
 *
 * @details
 *
 * @param[out] dst The address of output matrix.
 * @param[in] src The address of input matrix.
 * @param[in] n2 Tiling input iteration 2.
 * @param[in] s2 Tiling input stride 2.
 * @param[in] n1 Tiling input iteration 1.
 * @param[in] s1 Tiling input stride 1.
 * @param[in] n7 Tiling output iteration 2.
 * @param[in] s7 Tiling output stride 2.
 * @param[in] n6 Tiling output iteration 1.
 * @param[in] s6 Tiling output stride 1.
 * @return ``void``.
 * @remark
 * - This interface is supported on ``(m)tp_2xx`` and higher;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - \f$<n1> \times <n2> = <n6> \times <n7> = 32\f$;
 * - ``<n1>``, ``<n2>``, ``<n6>`` and ``<n7>`` must be an immediate integer;
 * - ``<s1>``, ``<s2>``, ``<s6>`` and ``<s7>`` must be greater than or equal to zero;
 * - Unit of ``<s1>``, ``<s2>``, ``<s6>``, ``<s7>`` is 64 bytes;
 * - ``<dst>`` and ``<src>`` can not be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_tiling_2d_b16(void* dst,
                                                              void* src,
                                                              int n2,
                                                              int s2,
                                                              int n1,
                                                              int s1,
                                                              int n7,
                                                              int s7,
                                                              int n6,
                                                              int s6);

//Group:Stream Operation Functions
/**
 * @brief Applies 2D tiling operation on ``<src>``.
 *
 * @details
 *
 * @param[out] dst The address of output matrix.
 * @param[in] src The address of input matrix.
 * @param[in] n2 Tiling input iteration 2.
 * @param[in] s2 Tiling input stride 2.
 * @param[in] n1 Tiling input iteration 1.
 * @param[in] s1 Tiling input stride 1.
 * @param[in] n7 Tiling output iteration 2.
 * @param[in] s7 Tiling output stride 2.
 * @param[in] n6 Tiling output iteration 1.
 * @param[in] s6 Tiling output stride 1.
 * @return ``void``.
 * @remark
 * - This interface is supported on ``(m)tp_2xx`` and higher;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - \f$<n1> \times <n2> = <n6> \times <n7> = 16\f$;
 * - ``<n1>``, ``<n2>``, ``<n6>`` and ``<n7>`` must be an immediate integer;
 * - ``<s1>``, ``<s2>``, ``<s6>`` and ``<s7>`` must be greater than or equal to zero;
 * - Unit of ``<s1>``, ``<s2>``, ``<s6>``, ``<s7>`` is 64 bytes;
 * - ``<dst>`` and ``<src>`` can not be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_tiling_2d_b32(void* dst,
                                                              void* src,
                                                              int n2,
                                                              int s2,
                                                              int n1,
                                                              int s1,
                                                              int n7,
                                                              int s7,
                                                              int n6,
                                                              int s6);

//Group:Stream Operation Functions
/**
 * @brief Applies 2D tiling operation on ``<src>``.
 *
 * @details
 *
 * @param[out] dst The address of output matrix.
 * @param[in] src The address of input matrix.
 * @param[in] n2 Tiling input iteration 2.
 * @param[in] s2 Tiling input stride 2.
 * @param[in] n1 Tiling input iteration 1.
 * @param[in] s1 Tiling input stride 1.
 * @param[in] n7 Tiling output iteration 2.
 * @param[in] s7 Tiling output stride 2.
 * @param[in] n6 Tiling output iteration 1.
 * @param[in] s6 Tiling output stride 1.
 * @return ``void``.
 * @remark
 * - This interface is supported on ``(m)tp_2xx`` and higher;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - \f$<n1> \times <n2> = <n6> \times <n7> = 8\f$;
 * - ``<n1>``, ``<n2>``, ``<n6>`` and ``<n7>`` must be an immediate integer;
 * - ``<s1>``, ``<s2>``, ``<s6>`` and ``<s7>`` must be greater than or equal to zero;
 * - Unit of ``<s1>``, ``<s2>``, ``<s6>``, ``<s7>`` is 64 bytes;
 * - ``<dst>`` and ``<src>`` can not be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_tiling_2d_b64(void* dst,
                                                              void* src,
                                                              int n2,
                                                              int s2,
                                                              int n1,
                                                              int s1,
                                                              int n7,
                                                              int s7,
                                                              int n6,
                                                              int s6);

//Group:Stream Operation Functions
/**
 * @brief Applies 2D tiling operation on ``<src>``.
 *
 * @details
 *
 * @param[out] dst The address of output matrix.
 * @param[in] src The address of input matrix.
 * @param[in] n2 Tiling input iteration 2.
 * @param[in] s2 Tiling input stride 2.
 * @param[in] n1 Tiling input iteration 1.
 * @param[in] s1 Tiling input stride 1.
 * @param[in] n7 Tiling output iteration 2.
 * @param[in] s7 Tiling output stride 2.
 * @param[in] n6 Tiling output iteration 1.
 * @param[in] s6 Tiling output stride 1.
 * @return ``void``.
 * @remark
 * - This interface is supported on ``(m)tp_2xx`` and higher;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - \f$<n1> \times <n2> = <n6> \times <n7> = 4\f$;
 * - ``<n1>``, ``<n2>``, ``<n6>`` and ``<n7>`` must be an immediate integer;
 * - ``<s1>``, ``<s2>``, ``<s6>`` and ``<s7>`` must be greater than or equal to zero;
 * - Unit of ``<s1>``, ``<s2>``, ``<s6>``, ``<s7>`` is 64 bytes;
 * - ``<dst>`` and ``<src>`` can not be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_tiling_2d_b128(void* dst,
                                                               void* src,
                                                               int n2,
                                                               int s2,
                                                               int n1,
                                                               int s1,
                                                               int n7,
                                                               int s7,
                                                               int n6,
                                                               int s6);

//Group:Stream Operation Functions
/**
 * @brief Applies 2D tiling operation on ``<src>``.
 *
 * @details
 *
 * @param[out] dst The address of output matrix.
 * @param[in] src The address of input matrix.
 * @param[in] n2 Tiling input iteration 2.
 * @param[in] s2 Tiling input stride 2.
 * @param[in] n1 Tiling input iteration 1.
 * @param[in] s1 Tiling input stride 1.
 * @param[in] n7 Tiling output iteration 2.
 * @param[in] s7 Tiling output stride 2.
 * @param[in] n6 Tiling output iteration 1.
 * @param[in] s6 Tiling output stride 1.
 * @return ``void``.
 * @remark
 * - This interface is supported on ``(m)tp_2xx`` and higher;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - \f$<n1> \times <n2> = <n6> \times <n7> = 2\f$;
 * - ``<n1>``, ``<n2>``, ``<n6>`` and ``<n7>`` must be an immediate integer;
 * - ``<s1>``, ``<s2>``, ``<s6>`` and ``<s7>`` must be greater than or equal to zero;
 * - Unit of ``<s1>``, ``<s2>``, ``<s6>``, ``<s7>`` is 64 bytes;
 * - ``<dst>`` and ``<src>`` can not be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_tiling_2d_b256(void* dst,
                                                               void* src,
                                                               int n2,
                                                               int s2,
                                                               int n1,
                                                               int s1,
                                                               int n7,
                                                               int s7,
                                                               int n6,
                                                               int s6);

//Group:Stream Operation Functions
/**
 * @brief Applies 3D tiling operation on ``<src>``.
 *
 * @details
 *
 * @param[out] dst The address of output tensor.
 * @param[in] src The address of input tensor.
 * @param[in] n5 Tiling input outer iteration 5.
 * @param[in] s5 Tiling input outer stride 5.
 * @param[in] n4 Tiling input outer iteration 4.
 * @param[in] s4 Tiling input outer stride 4.
 * @param[in] n3 Tiling input outer iteration 3.
 * @param[in] s3 Tiling input outer stride 3.
 * @param[in] n10 Tiling output outer iteration 5.
 * @param[in] s10 Tiling input outer stride 5.
 * @param[in] n9 Tiling output outer iteration 4.
 * @param[in] s9 Tiling input outer stride 4.
 * @param[in] n8 Tiling output outer iteration 3.
 * @param[in] s8 Tiling input outer stride 3.
 * @param[in] op number of tiling unit.
 * @return ``void``.
 * @remark
 * - This interface is supported on ``(m)tp_2xx`` and higher;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<op>`` must be an immediate integer;
 * - ``<op>`` must be greater than zero and a multiple of 64;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - Unit of ``<s3>``, ``<s4>``, ``<s5>``,  ``<s8>``, ``<s9>`` and ``<s10>`` is 64 bytes;
 * - ``<s3>``, ``<s4>``, ``<s5>``,  ``<s8>``, ``<s9>`` and ``<s10>`` must be greater than or equal to zero;
 * - \f$<n3> \times <n4> \times <n5> == <n8> \times <n9> \times <n10>\f$;
 * - ``<dst>`` and ``<src>`` can not be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_tiling_3d_b1024(void* dst,
                                                                void* src,
                                                                int n5,
                                                                int s5,
                                                                int n4,
                                                                int s4,
                                                                int n3,
                                                                int s3,
                                                                int n10,
                                                                int s10,
                                                                int n9,
                                                                int s9,
                                                                int n8,
                                                                int s8,
                                                                int op);

static __mlu_func__ __mlu_builtin__ void __bang_trans_tiling_b8(void* dst,
                                                                void* src,
                                                                int n5,
                                                                int s5,
                                                                int n4,
                                                                int s4,
                                                                int n3,
                                                                int s3,
                                                                int n2,
                                                                int s2,
                                                                int n1,
                                                                int s1,
                                                                int n10,
                                                                int s10,
                                                                int n9,
                                                                int s9,
                                                                int n8,
                                                                int s8,
                                                                int n7,
                                                                int s7,
                                                                int n6,
                                                                int s6);

static __mlu_func__ __mlu_builtin__ void __bang_trans_tiling_b16(void* dst,
                                                                 void* src,
                                                                 int n5,
                                                                 int s5,
                                                                 int n4,
                                                                 int s4,
                                                                 int n3,
                                                                 int s3,
                                                                 int n2,
                                                                 int s2,
                                                                 int n1,
                                                                 int s1,
                                                                 int n10,
                                                                 int s10,
                                                                 int n9,
                                                                 int s9,
                                                                 int n8,
                                                                 int s8,
                                                                 int n7,
                                                                 int s7,
                                                                 int n6,
                                                                 int s6);

static __mlu_func__ __mlu_builtin__ void __bang_trans_tiling_b32(void* dst,
                                                                 void* src,
                                                                 int n5,
                                                                 int s5,
                                                                 int n4,
                                                                 int s4,
                                                                 int n3,
                                                                 int s3,
                                                                 int n2,
                                                                 int s2,
                                                                 int n1,
                                                                 int s1,
                                                                 int n10,
                                                                 int s10,
                                                                 int n9,
                                                                 int s9,
                                                                 int n8,
                                                                 int s8,
                                                                 int n7,
                                                                 int s7,
                                                                 int n6,
                                                                 int s6);

static __mlu_func__ __mlu_builtin__ void __bang_trans_tiling_b64(void* dst,
                                                                 void* src,
                                                                 int n5,
                                                                 int s5,
                                                                 int n4,
                                                                 int s4,
                                                                 int n3,
                                                                 int s3,
                                                                 int n2,
                                                                 int s2,
                                                                 int n1,
                                                                 int s1,
                                                                 int n10,
                                                                 int s10,
                                                                 int n9,
                                                                 int s9,
                                                                 int n8,
                                                                 int s8,
                                                                 int n7,
                                                                 int s7,
                                                                 int n6,
                                                                 int s6);

static __mlu_func__ __mlu_builtin__ void __bang_trans_tiling_b128(void* dst,
                                                                  void* src,
                                                                  int n5,
                                                                  int s5,
                                                                  int n4,
                                                                  int s4,
                                                                  int n3,
                                                                  int s3,
                                                                  int n2,
                                                                  int s2,
                                                                  int n1,
                                                                  int s1,
                                                                  int n10,
                                                                  int s10,
                                                                  int n9,
                                                                  int s9,
                                                                  int n8,
                                                                  int s8,
                                                                  int n7,
                                                                  int s7,
                                                                  int n6,
                                                                  int s6);

static __mlu_func__ __mlu_builtin__ void __bang_trans_tiling_b256(void* dst,
                                                                  void* src,
                                                                  int n5,
                                                                  int s5,
                                                                  int n4,
                                                                  int s4,
                                                                  int n3,
                                                                  int s3,
                                                                  int n2,
                                                                  int s2,
                                                                  int n1,
                                                                  int s1,
                                                                  int n10,
                                                                  int s10,
                                                                  int n9,
                                                                  int s9,
                                                                  int n8,
                                                                  int s8,
                                                                  int n7,
                                                                  int s7,
                                                                  int n6,
                                                                  int s6);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_reshape_filter(half* dst,
                                                               half* src,
                                                               int n,
                                                               int h,
                                                               int w,
                                                               int c);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_reshape_filter(short* dst,
                                                               short* src,
                                                               int n,
                                                               int h,
                                                               int w,
                                                               int c);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_reshape_filter(unsigned short* dst,
                                                               unsigned short* src,
                                                               int n,
                                                               int h,
                                                               int w,
                                                               int c);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_reshape_filter(int8* dst,
                                                               int8* src,
                                                               int n,
                                                               int h,
                                                               int w,
                                                               int c);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_reshape_filter(char* dst,
                                                               char* src,
                                                               int n,
                                                               int h,
                                                               int w,
                                                               int c);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_reshape_filter(unsigned char* dst,
                                                               unsigned char* src,
                                                               int n,
                                                               int h,
                                                               int w,
                                                               int c);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_reshape_filter(float* dst,
                                                               float* src,
                                                               int n,
                                                               int h,
                                                               int w,
                                                               int c);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_reshape_filter(int* dst,
                                                               int* src,
                                                               int n,
                                                               int h,
                                                               int w,
                                                               int c);

//Group:Stream Operation Functions
/**
 * @brief Reshapes the input kernel suit for MLP and CONV, ``<n>`` changed to ``<n>``/64 along ``<n>`` direction.
 *
 * @details
 *
 * @param[out] dst The address of output kernel.
 * @param[in] src The address of input kernel.
 * @param[in] n The batch number of input kernel.
 * @param[in] h The height of input kernel.
 * @param[in] w The width of input kernel.
 * @param[in] c The channel input of kernel.
 * @return ``void``.
 * @remark
 * - This interface is supported on ``(m)tp_2xx`` and higher;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<n>`` must be divisible by 64;
 * - \f$<h> \times <w> \times <c> \times sizeof(type)\f$ must be divisible by 128;
 * - ``<dst>`` and ``<src>`` can not be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_reshape_filter(unsigned int* dst,
                                                               unsigned int* src,
                                                               int n,
                                                               int h,
                                                               int w,
                                                               int c);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_reshape_nhwc2nchw(half* dst,
                                                                  half* src,
                                                                  int n,
                                                                  int h,
                                                                  int w,
                                                                  int c);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_reshape_nhwc2nchw(short* dst,
                                                                  short* src,
                                                                  int n,
                                                                  int h,
                                                                  int w,
                                                                  int c);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_reshape_nhwc2nchw(unsigned short* dst,
                                                                  unsigned short* src,
                                                                  int n,
                                                                  int h,
                                                                  int w,
                                                                  int c);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_reshape_nhwc2nchw(int8* dst,
                                                                  int8* src,
                                                                  int n,
                                                                  int h,
                                                                  int w,
                                                                  int c);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_reshape_nhwc2nchw(char* dst,
                                                                  char* src,
                                                                  int n,
                                                                  int h,
                                                                  int w,
                                                                  int c);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_reshape_nhwc2nchw(unsigned char* dst,
                                                                  unsigned char* src,
                                                                  int n,
                                                                  int h,
                                                                  int w,
                                                                  int c);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_reshape_nhwc2nchw(float* dst,
                                                                  float* src,
                                                                  int n,
                                                                  int h,
                                                                  int w,
                                                                  int c);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_reshape_nhwc2nchw(int* dst,
                                                                  int* src,
                                                                  int n,
                                                                  int h,
                                                                  int w,
                                                                  int c);
//Group:Stream Operation Functions
/**
 * @brief Reshapes the data layout of the kernel from NHWC to NCHW.
 *
 * @details
 *
 * @param[out] dst The address of output kernel.
 * @param[in] src The address of input kernel.
 * @param[in] n The batch number of input kernel.
 * @param[in] h The height of input kernel.
 * @param[in] w The width of input kernel.
 * @param[in] c The channel input of kernel.
 * @return ``void``.
 * @remark
 * - This interface is supported on ``(m)tp_2xx`` and higher;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - \f$<h> \times <w> \times sizeof(type)\f$ must be divisible by 64;
 * - \f$<c> \times sizeof(type)\f$ must be divisible by 64;
 * - ``<dst>`` and ``<src>`` can not be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_reshape_nhwc2nchw(unsigned int* dst,
                                                                  unsigned int* src,
                                                                  int n,
                                                                  int h,
                                                                  int w,
                                                                  int c);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_reshape_nchw2nhwc(half* dst,
                                                                  half* src,
                                                                  int n,
                                                                  int h,
                                                                  int w,
                                                                  int c);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_reshape_nchw2nhwc(short* dst,
                                                                  short* src,
                                                                  int n,
                                                                  int h,
                                                                  int w,
                                                                  int c);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_reshape_nchw2nhwc(unsigned short* dst,
                                                                  unsigned short* src,
                                                                  int n,
                                                                  int h,
                                                                  int w,
                                                                  int c);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_reshape_nchw2nhwc(int8* dst,
                                                                  int8* src,
                                                                  int n,
                                                                  int h,
                                                                  int w,
                                                                  int c);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_reshape_nchw2nhwc(char* dst,
                                                                  char* src,
                                                                  int n,
                                                                  int h,
                                                                  int w,
                                                                  int c);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_reshape_nchw2nhwc(unsigned char* dst,
                                                                  unsigned char* src,
                                                                  int n,
                                                                  int h,
                                                                  int w,
                                                                  int c);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_reshape_nchw2nhwc(float* dst,
                                                                  float* src,
                                                                  int n,
                                                                  int h,
                                                                  int w,
                                                                  int c);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_reshape_nchw2nhwc(int* dst,
                                                                  int* src,
                                                                  int n,
                                                                  int h,
                                                                  int w,
                                                                  int c);

//Group:Stream Operation Functions
/**
 * @brief Reshapes the data layout of the kernel from NCHW to NHWC.
 *
 * @details
 *
 * @param[out] dst The address of output kernel.
 * @param[in] src The address of input kernel.
 * @param[in] n The batch number of input kernel.
 * @param[in] h The height of input kernel.
 * @param[in] w The width of input kernel.
 * @param[in] c The channel input of kernel.
 * @return ``void``.
 * @remark
 * - This interface is supported on ``(m)tp_2xx`` and higher;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - \f$<h> \times <w> \times sizeof(type)\f$ must be divisible by 64;
 * - \f$<c> \times sizeof(type)\f$ must be divisible by 64;
 * - ``<dst>`` and ``<src>`` can not be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_reshape_nchw2nhwc(unsigned int* dst,
                                                                  unsigned int* src,
                                                                  int n,
                                                                  int h,
                                                                  int w,
                                                                  int c);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_sumpool(half* dst,
                                                        half* src,
                                                        int channel,
                                                        int height,
                                                        int width,
                                                        int kernel_height,
                                                        int kernel_width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_sumpool(half* dst,
                                                        half* src,
                                                        int channel,
                                                        int height,
                                                        int width,
                                                        int kernel_height,
                                                        int kernel_width,
                                                        int stride_width,
                                                        int stride_height);
static __mlu_func__ __mlu_builtin__ void __bang_sumpool(bfloat16_t* dst,
                                                        bfloat16_t* src,
                                                        int channel,
                                                        int height,
                                                        int width,
                                                        int kernel_height,
                                                        int kernel_width,
                                                        int stride_width,
                                                        int stride_height);
//Group:Stream Operation Functions
/**
 * @brief Applies sumpooling forward operation on ``<src>`` [``<height>``, ``<width>``, ``<channel>``], a three-dimensional tensor, with sliding window [``<kernel_height>``, ``<kernel_width>``] and stride [``<stride_width>``, ``<stride_height>``], and saves the sum in each window.
 *
 * @details
 *
 * @param[out] dst The address of destination tensor whose data layout is HWC.
 * @param[in] src The address of source tensor whose data layout is HWC.
 * @param[in] channel Input channel.
 * @param[in] height The height of input feature map.
 * @param[in] width The width of input feature map.
 * @param[in] kernel_height The height of kernel.
 * @param[in] kernel_width The width of kernel.
 * @param[in] stride_width Stride of W direction.
 * @param[in] stride_height Stride of H direction.
 * @return ``void``.
 * @remark
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<channel>`` * ``sizeof(type)`` must be divisible by 128;
 * - When window is slided in certain direction (H or W direction), if the left elements number doesn't match the window size, these elements will be discarded;
 * - The result is a three-dimensional tensor with HWC data layout;
 * - ``<dst>`` and ``<src>`` can not be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *    #include <bang.h>
 *
 *    #define CHANNELS 64
 *    #define IN_HEIGHT 9
 *    #define IN_WIDTH 9
 *    #define KERNEL_HEIGHT 3
 *    #define KERNEL_WIDTH 3
 *    #define STRIDE_X 1
 *    #define STRIDE_Y 1
 *    #define INPUT_COUNT ((CHANNELS) * (IN_WIDTH) * (IN_HEIGHT))
 *    #define OUTPUT_COUNT                                           \
 *      ((CHANNELS) * ((IN_HEIGHT - KERNEL_HEIGHT) / STRIDE_Y + 1) * \
 *      ((IN_WIDTH - KERNEL_WIDTH) / STRIDE_X + 1))
 *
 *    __mlu_entry__ void PoolSumKernel(half* output, half* input) {
 *      __nram__ half a_tmp[INPUT_COUNT];
 *      __nram__ half b_tmp[OUTPUT_COUNT];
 *      __memcpy(a_tmp, input, INPUT_COUNT * sizeof(half), GDRAM2NRAM);
 *      __bang_sumpool(b_tmp, a_tmp, CHANNELS, IN_HEIGHT, IN_WIDTH,
 *                     KERNEL_HEIGHT, KERNEL_WIDTH, STRIDE_X, STRIDE_Y);
 *      __memcpy(output, b_tmp, OUTPUT_COUNT * sizeof(half), NRAM2GDRAM);
 *    }
 *
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_sumpool(float* dst,
                                                        float* src,
                                                        int channel,
                                                        int height,
                                                        int width,
                                                        int kernel_height,
                                                        int kernel_width,
                                                        int stride_width,
                                                        int stride_height);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_unpool(half* dst,
                                                       half* src,
                                                       int channel,
                                                       int height,
                                                       int width,
                                                       int kernel_height,
                                                       int kernel_width,
                                                       int stride_width,
                                                       int stride_height,
                                                       int index);
static __mlu_func__ __mlu_builtin__ void __bang_unpool(bfloat16_t* dst,
                                                       bfloat16_t* src,
                                                       int channel,
                                                       int height,
                                                       int width,
                                                       int kernel_height,
                                                       int kernel_width,
                                                       int stride_width,
                                                       int stride_height,
                                                       int index);
//Group:Stream Operation Functions
/**
 * @brief Applies unpooling backward operation on ``<src>``, a tensor. Every element of ``<src>`` tensor corresponds to a kernel window on ``<dst>`` tensor operand. The elements of ``<src>`` tensor is written into ``<index>``'th position in that kernel window on ``<dst>`` tensor, and other positions in the kernel window are written zero.
 *
 * @details
 * \rst
 *
 * The Figure :ref:`fig11.3` shows an example with the following parameters, ``height = 5``, ``width = 5``, ``kernel_height = 2``, ``kernel_width = 2``, ``stride_height = 3``, ``stride_width = 3``, ``input_height = 2``, ``input_width = 2``, and ``index = 1``.
 *
 *      .. _fig11.3:
 *      .. figure:: ../img/11.3.*
 *
 *         Process of Unpool Operation
 *
 * \endrst
 *
 * @param[out] dst The address of destination tensor.
 * @param[in] src The address of source tensor.
 * @param[in] channel Input channel.
 * @param[in] height The height of output feature map.
 * @param[in] width The width of output feature map.
 * @param[in] kernel_height The height of kernel.
 * @param[in] kernel_width The width of kernel.
 * @param[in] stride_width W direction of stride.
 * @param[in] stride_height H direction of stride.
 * @param[in] index Index within kernel window.
 * @return ``void``.
 * @remark
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - ``<channel>`` must be divisible by 64 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The shape of ``<dst>`` tensor [``<height>``, ``<width>``, ``out_channel``] and ``<src>`` tensor [``input_height``, ``input_width``, ``<channel>``] has following restrictions: \f$<height> = (input\_height – 1) * <stride\_height> + <kernel\_height>\f$, \f$<width> = (input\_width – 1) * <stride\_width> + <kernel\_width>\f$, \f$out\_channel = <channel>\f$;
 * - The ``<index>``'th position in kernel window means ikh'th row and ikw'th column in kernel window, where (ikh * ``<kernel_width>`` + ikw = ``<index>``);
 * - If ``<stride_width>`` > ``<kernel_width>`` or ``<stride_height>`` > ``<kernel_height>``, the elements in ``<dst>`` that do not belong to any kernel window remain unchanged;
 * - ``<dst>`` and ``<src>`` can not be homologous operands.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *    #include <bang.h>
 *
 *    #define CHANNELS 128
 *    #define HEIGHT 6
 *    #define WIDTH 4
 *    #define KERNEL_HEIGHT 3
 *    #define KERNEL_WIDTH 2
 *    #define STRIDE_X 2
 *    #define STRIDE_Y 3
 *    #define INDEX_IN_KERNEL 2
 *    #define H_SMALL ((HEIGHT-KERNEL_HEIGHT)/STRIDE_Y+1)
 *    #define W_SMALL ((WIDTH-KERNEL_WIDTH)/STRIDE_X+1)
 *    #define TOP_DATA_COUNT ((CHANNELS) * (WIDTH) * (HEIGHT))
 *    #define BOTTOM_DATA_COUNT ((CHANNELS) * H_SMALL * W_SMALL)
 *
 *    __mlu_entry__ void UnPoolKernel(half* top_data, int16_t* bottom_data,
 *                                    int channels, int height, int width,
 *                                    int kh, int kw, int sx, int sy,
 *                                    int index_in_kernel) {
 *      __nram__ half a_tmp[BOTTOM_DATA_COUNT];
 *      __nram__ half b_tmp[TOP_DATA_COUNT];
 *      __memcpy(a_tmp, bottom_data, BOTTOM_DATA_COUNT * sizeof(half), GDRAM2NRAM);
 *      __memcpy(b_tmp, top_data, TOP_DATA_COUNT * sizeof(half), GDRAM2NRAM);
 *      __bang_unpool(b_tmp, a_tmp, CHANNELS, HEIGHT, WIDTH, KERNEL_HEIGHT,
 *                    KERNEL_WIDTH, sx, sy, index_in_kernel);
 *      __memcpy(top_data, b_tmp, TOP_DATA_COUNT * sizeof(half), NRAM2GDRAM);
 *    }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_unpool(float* dst,
                                                       float* src,
                                                       int channel,
                                                       int height,
                                                       int width,
                                                       int kernel_height,
                                                       int kernel_width,
                                                       int stride_width,
                                                       int stride_height,
                                                       int index);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_maxpool(half* dst,
                                                        half* src,
                                                        int channel,
                                                        int height,
                                                        int width,
                                                        int kernel_height,
                                                        int kernel_width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_maxpool(half* dst,
                                                        half* src,
                                                        int channel,
                                                        int height,
                                                        int width,
                                                        int kernel_height,
                                                        int kernel_width,
                                                        int stride_width,
                                                        int stride_height);
static __mlu_func__ __mlu_builtin__ void __bang_maxpool(bfloat16_t* dst,
                                                        bfloat16_t* src,
                                                        int channel,
                                                        int height,
                                                        int width,
                                                        int kernel_height,
                                                        int kernel_width,
                                                        int stride_width,
                                                        int stride_height);
//Group:Stream Operation Functions
/**
 * @brief Applies maxpooling forward operation on ``<src>`` [``<height>``, ``<width>``, ``<channel>``], a three-dimensional tensor with sliding window [``<kernel_height>``, ``<kernel_width>``] and stride [``<stride_width>``, ``<stride_height>``], and selects the index of the maximum value in each window.
 *
 * @details
 *
 * @param[out] dst The address of destination tensor. And the tensor data layout is HWC.
 * @param[in] src The address of source tensor. And the tensor data layout is HWC.
 * @param[in] channel Input channel.
 * @param[in] height The height of input feature map.
 * @param[in] width The width of input feature map.
 * @param[in] kernel_height The height of sliding window.
 * @param[in] kernel_width The width of sliding window.
 * @param[in] stride_width Stride of sliding window in W direction.
 * @param[in] stride_height Stride of sliding window in H direction.
 * @return ``void``.
 * @remark
 * \rst
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<channel>`` * ``sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - When window is slided in certain direction (H or W direction), if the left elements number doesn't match the window size, these elements will be discarded;
 * - ``<dst>`` and ``<src>`` can not be homologous operands;
 * - In the interface without stride, ``<stride_width>`` equals ``<kernel_width>`` and ``<stride_height>`` equals ``<kernel_height>``;
 * - See the table :ref:`floating_point_calculation_of_stream_comparison_operation_functions_without_elementwise` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *    #include <bang.h>
 *
 *    #define CHANNELS 64
 *    #define HEIGHT 4
 *    #define WIDTH 4
 *    #define KERNEL_HEIGHT 2
 *    #define KERNEL_WIDTH 2
 *    #define BOTTOM_DATA_COUNT ((CHANNELS) * (WIDTH) * (HEIGHT))
 *    #define TOP_DATA_COUNT \
 *      ((CHANNELS) * (HEIGHT / KERNEL_HEIGHT) * (WIDTH / KERNEL_WIDTH))
 *
 *    __mlu_entry__ void maxPoolingKernel(half* bottom_data, half* top_data,
 *                                        int channels, int height, int width,
 *                                        int pooled_height, int pooled_width) {
 *      __nram__ half a_tmp[BOTTOM_DATA_COUNT];
 *      __nram__ half b_tmp[TOP_DATA_COUNT];
 *      __memcpy(a_tmp, bottom_data, BOTTOM_DATA_COUNT * sizeof(half), GDRAM2NRAM);
 *      __bang_maxpool(b_tmp, a_tmp, CHANNELS, HEIGHT, WIDTH, KERNEL_HEIGHT, KERNEL_WIDTH);
 *      __memcpy(top_data, b_tmp, TOP_DATA_COUNT * sizeof(half), NRAM2GDRAM);
 *    }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_maxpool(float* dst,
                                                        float* src,
                                                        int channel,
                                                        int height,
                                                        int width,
                                                        int kernel_height,
                                                        int kernel_width,
                                                        int stride_width,
                                                        int stride_height);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_maxpool_index(unsigned short* dst,
                                                              half* src,
                                                              int channel,
                                                              int height,
                                                              int width,
                                                              int kernel_height,
                                                              int kernel_width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_maxpool_index(unsigned short* dst,
                                                              half* src,
                                                              int channel,
                                                              int height,
                                                              int width,
                                                              int kernel_height,
                                                              int kernel_width,
                                                              int stride_width,
                                                              int stride_height);
static __mlu_func__ __mlu_builtin__ void __bang_maxpool_index(unsigned short* dst,
                                                              bfloat16_t* src,
                                                              int channel,
                                                              int height,
                                                              int width,
                                                              int kernel_height,
                                                              int kernel_width,
                                                              int stride_width,
                                                              int stride_height);
//Group:Stream Operation Functions
/**
 * @brief Applies maxpooling forward operation with index on ``<src>`` [``<height>``, ``<width>``, ``<channel>``], a three-dimensional tensor, with sliding window [``<kernel_height>``, ``<kernel_width>``] and stride [``<stride_width>``, ``<stride_height>``], and selects the index of the maximum value in each window.
 *
 * @details
 *
 * @param[out] dst The address of destination tensor whose data layout is HWC.
 * @param[in] src The address of source tensor whose data layout is HWC.
 * @param[in] channel Input channel.
 * @param[in] height The height of input feature map.
 * @param[in] width The width of input feature map.
 * @param[in] kernel_height The height of kernel.
 * @param[in] kernel_width The width of kernel.
 * @param[in] stride_width Stride of sliding window in W direction.
 * @param[in] stride_height Stride of sliding window in H direction.
 * @return ``void``.
 * @remark
 * \rst
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<channel>`` * ``sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - When window is slided in certain direction (H or W direction), if the left elements number doesn't match the window size, these elements will be discarded;
 * - The result is a three-dimensional tensor with HWC data layout;
 * - ``<dst>`` and ``<src>`` can not be homologous operands;
 * - In the interface without stride, ``<stride_width>`` equals ``<kernel_width>`` and ``<stride_height>`` equals ``<kernel_height>``;
 * - When the data type of ``<src>`` is ``half``, the data type of ``<dst>`` is ``unsigned short``. When the data type of ``<src>`` is ``float``, the data type of ``<dst>`` is ``unsigned int``;
 * - See the table :ref:`floating_point_calculation_of_stream_comparison_operation_functions_without_elementwise` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *    #include <bang.h>
 *
 *    #define CHANNELS 64
 *    #define HEIGHT 9
 *    #define WIDTH 12
 *    #define KERNEL_HEIGHT 5
 *    #define KERNEL_WIDTH 4
 *
 *    #define BOTTOM_DATA_COUNT ((CHANNELS) * (WIDTH) * (HEIGHT))
 *    #define TOP_DATA_COUNT \
 *      ((CHANNELS) * (HEIGHT / KERNEL_HEIGHT) * (WIDTH / KERNEL_WIDTH))
 *
 *    __mlu_entry__ void MaxPoolIndexKernel(half* bottom_data, int16_t* top_data,
 *                                          int channels, int height, int width,
 *                                          int pooled_height, int pooled_width) {
 *      __nram__ half a_tmp[BOTTOM_DATA_COUNT];
 *      __nram__ uint16_t b_tmp[TOP_DATA_COUNT];
 *      __memcpy(a_tmp, bottom_data, BOTTOM_DATA_COUNT * sizeof(half), GDRAM2NRAM);
 *      __bang_maxpool_index(b_tmp, a_tmp, CHANNELS, HEIGHT, WIDTH,
 *                           KERNEL_HEIGHT, KERNEL_WIDTH);
 *      __memcpy(top_data, b_tmp, TOP_DATA_COUNT * sizeof(int16_t), NRAM2GDRAM);
 *    }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_maxpool_index(unsigned int* dst,
                                                              float* src,
                                                              int channel,
                                                              int height,
                                                              int width,
                                                              int kernel_height,
                                                              int kernel_width,
                                                              int stride_width,
                                                              int stride_height);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_maxpool_value_index(half* dst,
                                                                    half* src,
                                                                    int channel,
                                                                    int height,
                                                                    int width,
                                                                    int kernel_height,
                                                                    int kernel_width,
                                                                    int stride_width,
                                                                    int stride_height,
                                                                    int value_index_stride,
                                                                    int in_dh,
                                                                    int in_dw,
                                                                    int out_dh,
                                                                    int out_dw);
static __mlu_func__ __mlu_builtin__ void __bang_maxpool_value_index(bfloat16_t* dst,
                                                                    bfloat16_t* src,
                                                                    int channel,
                                                                    int height,
                                                                    int width,
                                                                    int kernel_height,
                                                                    int kernel_width,
                                                                    int stride_width,
                                                                    int stride_height,
                                                                    int value_index_stride,
                                                                    int in_dh,
                                                                    int in_dw,
                                                                    int out_dh,
                                                                    int out_dw);
//Group:Stream Operation Functions
/**
 * @brief Performs maxpooling forward operation to get the maximum value and corresponding index value.
 *
 * @details
 * - Performs maximum pooling operation with the kernel ``[kernel_height, kernel_width]`` and the stride ``[stride_width, stride_height]`` on the tensor ``<src>[channel, height, width]`` in ``__nram__`` space;
 * - Stores the maximum value and the corresponding index to ``<dst>``.
 *
 * @param[out] dst The address of destination tensor.
 * @param[in] src The address of source tensor.
 * @param[in] channel The input channel.
 * @param[in] height The height of input source.
 * @param[in] width The width of input source.
 * @param[in] kernel_height The height of kernel.
 * @param[in] kernel_width The width of kernel.
 * @param[in] stride_width The stride in W direction.
 * @param[in] stride_height The stride in H direction.
 * @param[in] value_index_stride The offset from the beginning of data value to index value in bytes.
 * @param[in] in_dh Dilation in H direction of input.
 * @param[in] in_dw Dilation in W direction of input.
 * @param[in] out_dh Dilation in H direction of output.
 * @param[in] out_dw Dilation in W direction of output.
 *
 * @return ``void``.
 *
 * @remark
 * - ``<dst>`` and ``<src>`` must be in ``__nram__`` space;
 * - For the output tensor ``<dst>[output_channel, output_height, output_width]``, ``[output_channel] = <channel>``, and ``[output_height, output_width]`` are obtained by deducing from ``[height, width]``, ``[kernel_height, kernel_width]`` and ``[stride_width, stride_height]``;
 * - ``[output_height]`` and ``[output_width]`` of ``<dst>``  must be greater than 0;
 * - When the kernel moves to the edge of input ``<width>`` and the kernel overflows, it will automatically adapt to the size of ``<kernel_width>``, so as to ensure that useless input is not included;
 * - When data type of ``<dst>`` and ``<src>`` are half type, \f$(kernel\_height \times kernel\_width) < 2^{16}\f$;
 * - For the value part of ``<dst>``, when ``<value_index_stride> > 0``, the address operands ``<dst>`` and ``<src>`` can be homologous operands;
 * - ``<channel>``, ``<kernel_height>``, and ``<kernel_width>`` must be greater than 0;
 * - When the data type of ``<src>`` is ``half``, the data type of ``value`` in ``<dst>`` is ``half`` and the data type of ``index`` in ``<dst>`` is ``unsigned short``. When the data type of ``<src>`` is ``float``, the data type of ``value`` in ``<dst>`` is ``float`` and the data type of ``index`` in ``<dst>`` is ``unsigned int``;
 *
 * @par
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_comparison_operation_functions_without_elementwise` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *   - BANG Version: ``__BANG_ARCH__ >= 322`` ;
 *   - CNCC Version: ``cncc --version >= 3.0.0`` ;
 *   - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30`` ;
 *   - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322`` .
 *
 * @par Example
 * @code
 *
 *    #include <bang.h>
 *
 *    #define DATA_NUM 64
 *
 *    __mlu_entry__ void kernel(half *dst, half *src, float *dst_f,
 *                              float *src_f, int channel,
 *                              int height, int width,
 *                              int kernel_height, int kernel_width,
 *                              int stride_width, int stride_height,
 *                              int value_index_stride,
 *                              int in_dh, int in_dw,
 *                              int out_dh, int out_dw) {
 *      __nram__ half svc_dst[DATA_NUM];
 *      __nram__ half svc_src[DATA_NUM];
 *      int datasize = DATA_NUM * sizeof(half);
 *      __memcpy(svc_src, src, datasize, GDRAM2NRAM);
 *      __bang_maxpool_value_index(svc_dst, svc_src, channel, height,
 *                                 width, kernel_height, kernel_width,
 *                                 stride_width, stride_height,
 *                                 value_index_stride,
 *                                 in_dh, in_dw, out_dh, out_dw);
 *      __memcpy(dst, svc_dst, datasize, NRAM2GDRAM);
 *    }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_maxpool_value_index(float* dst,
                                                                    float* src,
                                                                    int channel,
                                                                    int height,
                                                                    int width,
                                                                    int kernel_height,
                                                                    int kernel_width,
                                                                    int stride_width,
                                                                    int stride_height,
                                                                    int value_index_stride,
                                                                    int in_dh,
                                                                    int in_dw,
                                                                    int out_dh,
                                                                    int out_dw);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_minpool(half* dst,
                                                        half* src,
                                                        int channel,
                                                        int height,
                                                        int width,
                                                        int kernel_height,
                                                        int kernel_width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_minpool(half* dst,
                                                        half* src,
                                                        int channel,
                                                        int height,
                                                        int width,
                                                        int kernel_height,
                                                        int kernel_width,
                                                        int stride_width,
                                                        int stride_height);
static __mlu_func__ __mlu_builtin__ void __bang_minpool(bfloat16_t* dst,
                                                        bfloat16_t* src,
                                                        int channel,
                                                        int height,
                                                        int width,
                                                        int kernel_height,
                                                        int kernel_width,
                                                        int stride_width,
                                                        int stride_height);
//Group:Stream Operation Functions
/**
 * @brief Applies minpooling forward operation on ``<src>``[``<height>``, ``<width>``, ``<channel>``], a three-dimensional tensor, with sliding window [``<kernel_height>``, ``<kernel_width>``] and stride [``<stride_width>``, ``<stride_height>``], and selects the minimum value in each window.
 *
 * @details
 *
 * @param[out] dst The address of destination tensor whose data layout is HWC.
 * @param[in] src The address of source tensor whose data layout is HWC.
 * @param[in] channel Input channel.
 * @param[in] height The height of input feature map.
 * @param[in] width The width of input feature map.
 * @param[in] kernel_height The height of sliding window.
 * @param[in] kernel_width The width of sliding window.
 * @param[in] stride_width Stride of sliding window in W direction.
 * @param[in] stride_height Stride of sliding window in H direction.
 * @return ``void``.
 * @remark
 * \rst
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<channel>`` * ``sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - When window is slided in certain direction (H or W direction), if the left elements number doesn't match the window size, these elements will be discarded;
 * - ``<dst>`` and ``<src>`` can not be homologous operands;
 * - In the interface without stride, ``<stride_width>`` equals ``<kernel_width>`` and ``<stride_height>`` equals ``<kernel_height>``;
 * - See the table :ref:`floating_point_calculation_of_stream_comparison_operation_functions_without_elementwise` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_minpool(float* dst,
                                                        float* src,
                                                        int channel,
                                                        int height,
                                                        int width,
                                                        int kernel_height,
                                                        int kernel_width,
                                                        int stride_width,
                                                        int stride_height);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_minpool_index(unsigned short* dst,
                                                              half* src,
                                                              int channel,
                                                              int height,
                                                              int width,
                                                              int kernel_height,
                                                              int kernel_width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_minpool_index(unsigned short* dst,
                                                              half* src,
                                                              int channel,
                                                              int height,
                                                              int width,
                                                              int kernel_height,
                                                              int kernel_width,
                                                              int stride_width,
                                                              int stride_height);
static __mlu_func__ __mlu_builtin__ void __bang_minpool_index(unsigned short* dst,
                                                              bfloat16_t* src,
                                                              int channel,
                                                              int height,
                                                              int width,
                                                              int kernel_height,
                                                              int kernel_width,
                                                              int stride_width,
                                                              int stride_height);
//Group:Stream Operation Functions
/**
 * @brief Applies minpooling forward operation with index on ``<src>`` [``<height>``, ``<width>``, ``<channel>``], a three-dimensional tensor, with sliding window [``<kernel_height>``, ``<kernel_width>``] and stride [``<stride_width>``, ``<stride_height>``], and selects the index with the minimum value in each window.
 *
 * @details
 *
 * @param[out] dst The address of destination tensor whose data layout is HWC.
 * @param[in] src The address of source tensor whose data layout is HWC.
 * @param[in] channel Input channel.
 * @param[in] height The height of input feature map.
 * @param[in] width The width of input feature map.
 * @param[in] kernel_height The height of sliding window.
 * @param[in] kernel_width The width of sliding window.
 * @param[in] stride_width Stride of sliding window in W direction.
 * @param[in] stride_height Stride of sliding window in H direction.
 * @return ``void``.
 * @remark
 * \rst
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<channel>`` * ``sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - When window is slided in certain direction (H or W direction), if the left elements number doesn't match the window size, these elements will be discarded;
 * - The result is a three-dimensional tensor with HWC data layout;
 * - ``<dst>`` and ``<src>`` can not be homologous operands;
 * - In the interface without stride, ``<stride_width>`` equals ``<kernel_width>`` and ``<stride_height>`` equals ``<kernel_height>``;
 * - When the data type of ``<src>`` is ``half``, the data type of ``<dst>`` is ``unsigned short``. When the data type of ``<src>`` is ``float``, the data type of ``<dst>`` is ``unsigned int``;
 * - See the table :ref:`floating_point_calculation_of_stream_comparison_operation_functions_without_elementwise` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_minpool_index(unsigned int* dst,
                                                              float* src,
                                                              int channel,
                                                              int height,
                                                              int width,
                                                              int kernel_height,
                                                              int kernel_width,
                                                              int stride_width,
                                                              int stride_height);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_minpool_value_index(half* dst,
                                                                    half* src,
                                                                    int channel,
                                                                    int height,
                                                                    int width,
                                                                    int kernel_height,
                                                                    int kernel_width,
                                                                    int stride_width,
                                                                    int stride_height,
                                                                    int value_index_stride,
                                                                    int in_dh,
                                                                    int in_dw,
                                                                    int out_dh,
                                                                    int out_dw);
static __mlu_func__ __mlu_builtin__ void __bang_minpool_value_index(bfloat16_t* dst,
                                                                    bfloat16_t* src,
                                                                    int channel,
                                                                    int height,
                                                                    int width,
                                                                    int kernel_height,
                                                                    int kernel_width,
                                                                    int stride_width,
                                                                    int stride_height,
                                                                    int value_index_stride,
                                                                    int in_dh,
                                                                    int in_dw,
                                                                    int out_dh,
                                                                    int out_dw);
//Group:Stream Operation Functions
/**
 * @brief Performs minpooling forward operation of tensor to get the minimum value and corresponding index value.
 *
 * @details
 * - Performs minimum pooling operation with the kernel [``<kernel_height>``, ``<kernel_width>``] and the stride [``<stride_width>``, ``<stride_height>``] on the tensor ``<src>``[``<channel>``, ``<height>``, ``<width>``] in ``__nram__`` space;
 * - Stores the minimum value and the corresponding index to ``<dst>``.
 *
 * @param[out] dst The address of destination tensor.
 * @param[in] src The address of source tensor.
 * @param[in] channel The input channel.
 * @param[in] height The height of input source.
 * @param[in] width The width of input source.
 * @param[in] kernel_height The height of kernel.
 * @param[in] kernel_width The width of kernel.
 * @param[in] stride_width The stride in W direction.
 * @param[in] stride_height The stride in H direction.
 * @param[in] value_index_stride The offset from the beginning of data value to index value in bytes.
 * @param[in] in_dh Dilation in H direction of input.
 * @param[in] in_dw Dilation in W direction of input.
 * @param[in] out_dh Dilation in H direction of output.
 * @param[in] out_dw Dilation in W direction of output.
 *
 * @return ``void``.
 *
 * @remark
 * - ``<dst>`` and ``<src>`` must be in ``__nram__`` space;
 * - For the output tensor ``<dst>[output_channel, output_height, output_width]``, ``[output_channel] = <channel>``, and ``[output_height, output_width]`` are obtained by deducing from ``[height, width]``, ``[kernel_height, kernel_width]`` and ``[stride_width, stride_height]``;
 * - ``[output_height]`` and ``[output_width]`` of ``<dst>``  must be greater than 0;
 * - When the kernel moves to the edge of input ``<width>`` and the kernel overflows, it will automatically adapt to the size of ``<kernel_width>``, so as to ensure that useless input is not included;
 * - When data type of ``<dst>`` and ``<src>`` are half type, \f$(kernel\_height \times kernel\_width) < 2^{16}\f$;
 * - For the value part of ``<dst>``, when ``<value_index_stride> > 0``, the address operands ``<dst>`` and ``<src>`` can be homologous operands;
 * - ``<channel>``, ``<kernel_height>``, and ``<kernel_width>`` must be greater than 0;
 * - When the data type of ``<src>`` is ``half``, the data type of ``value`` in ``<dst>`` is ``half`` and the data type of ``index`` in ``<dst>`` is ``unsigned short``. When the data type of ``<src>`` is ``float``, the data type of ``value`` in ``<dst>`` is ``float`` and the data type of ``index`` in ``<dst>`` is ``unsigned int``;
 *
 * @par
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_comparison_operation_functions_without_elementwise` for more details.
 * \endrst
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *   - BANG Version: ``__BANG_ARCH__ >= 322`` ;
 *   - CNCC Version: ``cncc --version >= 3.0.0`` ;
 *   - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30`` ;
 *   - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322`` .
 *
 * @par Example
 * @code
 *
 *    #include <bang.h>
 *
 *    #define DATA_NUM 64
 *
 *    __mlu_entry__ void kernel(half *dst, half *src, float *dst_f, float *src_f,
 *                              int channel, int height, int width, int kernel_height,
 *                              int kernel_width, int stride_width, int stride_height,
 *                              int value_index_stride, int in_dh, int in_dw,
 *                              int out_dh, int out_dw);
 *      int datasize = DATA_NUM * sizeof(half);
 *      __nram__ half svc_dst[DATA_NUM];
 *      __nram__ half svc_src[DATA_NUM];
 *      __memcpy(svc_src, src, datasize, GDRAM2NRAM);
 *      __bang_minpool_value_index(svc_dst, svc_src, channel, height, width,
 *                                 kernel_height, kernel_width, stride_width,
 *                                 stride_height, value_index_stride,
 *                                 in_dh, in_dw, out_dh, out_dw);
 *      __memcpy(dst, svc_dst, datasize, NRAM2GDRAM);
 *    }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_minpool_value_index(float* dst,
                                                                    float* src,
                                                                    int channel,
                                                                    int height,
                                                                    int width,
                                                                    int kernel_height,
                                                                    int kernel_width,
                                                                    int stride_width,
                                                                    int stride_height,
                                                                    int value_index_stride,
                                                                    int in_dh,
                                                                    int in_dw,
                                                                    int out_dh,
                                                                    int out_dw);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_avgpool(half* dst,
                                                        half* src,
                                                        int channel,
                                                        int height,
                                                        int width,
                                                        int kernel_height,
                                                        int kernel_width);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_avgpool(half* dst,
                                                        half* src,
                                                        int channel,
                                                        int height,
                                                        int width,
                                                        int kernel_height,
                                                        int kernel_width,
                                                        int stride_width,
                                                        int stride_height);
static __mlu_func__ __mlu_builtin__ void __bang_avgpool(bfloat16_t* dst,
                                                        bfloat16_t* src,
                                                        int channel,
                                                        int height,
                                                        int width,
                                                        int kernel_height,
                                                        int kernel_width,
                                                        int stride_width,
                                                        int stride_height);
//Group:Stream Operation Functions
/**
 * @brief Performs avgpooling forward propagation operation on ``<src>`` [``<height>``, ``<width>``, ``<channel>``], a three-dimensional tensor, with sliding window [``<kernel_height>``, ``<kernel_width>``] and stride [``<stride_width>``, ``<stride_height>``], and calculates the average value in each window.
 *
 * @details
 *
 * @param[out] dst The address of destination tensor whose data layout is HWC.
 * @param[in] src The address of source tensor whose data layout is HWC.
 * @param[in] channel Input channel.
 * @param[in] height The height of input feature map.
 * @param[in] width The width of input feature map.
 * @param[in] kernel_height The height of kernel.
 * @param[in] kernel_width The width of kernel.
 * @param[in] stride_width Stride of sliding window in W direction.
 * @param[in] stride_height Stride of sliding window in H direction.
 * @return ``void``.
 * @remark
 * \rst
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<channel>`` * ``sizeof(type)`` must be divisible by 128;
 * - When window is slided in certain direction (H or W direction), if the left elements number doesn't match the window size, these elements will be discarded;
 * - The result is a three-dimensional tensor with HWC data layout;
 * - ``<dst>`` and ``<src>`` can not be homologous operands;
 * - In the interface without stride, ``<stride_width>`` equals ``<kernel_width>`` and ``<stride_height>`` equals ``<kernel_height>``;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_binary_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *     #include <bang.h>
 *
 *     #define CHANNELS 64
 *     #define HEIGHT 9
 *     #define WIDTH 9
 *     #define KERNEL_HEIGHT 3
 *     #define KERNEL_WIDTH 3
 *     #define BOTTOM_DATA_COUNT ((CHANNELS) * (WIDTH) * (HEIGHT))
 *     #define TOP_DATA_COUNT \
 *       ((CHANNELS) * (HEIGHT / KERNEL_HEIGHT) * (WIDTH / KERNEL_WIDTH))
 *
 *     __mlu_entry__ void avgPoolingKernel(half* bottom_data, half* top_data,
 *                                         int channels, int height, int width,
 *                                         int pooled_height, int pooled_width) {
 *       __nram__ half a_tmp[BOTTOM_DATA_COUNT];
 *       __nram__ half b_tmp[TOP_DATA_COUNT];
 *       __memcpy(a_tmp, bottom_data, BOTTOM_DATA_COUNT * sizeof(half), GDRAM2NRAM);
 *       __bang_avgpool(b_tmp, a_tmp, CHANNELS, HEIGHT, WIDTH, KERNEL_HEIGHT, KERNEL_WIDTH);
 *       __memcpy(top_data, b_tmp, TOP_DATA_COUNT * sizeof(half), NRAM2GDRAM);
 *     }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_avgpool(float* dst,
                                                        float* src,
                                                        int channel,
                                                        int height,
                                                        int width,
                                                        int kernel_height,
                                                        int kernel_width,
                                                        int stride_width,
                                                        int stride_height);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_avgpool_bp(half* dst,
                                                           half* src,
                                                           int channel,
                                                           int height,
                                                           int width,
                                                           int kernel_height,
                                                           int kernel_width,
                                                           int stride_width,
                                                           int stride_height,
                                                           mluPoolBPOverlap overlap = OVERLAP_ACC);
static __mlu_func__ __mlu_builtin__ void __bang_avgpool_bp(bfloat16_t* dst,
                                                           bfloat16_t* src,
                                                           int channel,
                                                           int height,
                                                           int width,
                                                           int kernel_height,
                                                           int kernel_width,
                                                           int stride_width,
                                                           int stride_height,
                                                           mluPoolBPOverlap overlap = OVERLAP_ACC);
//Group:Stream Operation Functions
/**
 * @brief Performs avgpooling backward propagation operation on ``<src>`` [``<height>``, ``<width>``, ``<channel>``], a three-dimensional tensor, with sliding window [``<kernel_height>``, ``<kernel_width>``] and stride [``<stride_width>``, ``<stride_height>``], and calculates the average value in each window. ``<overlap>`` indicates the type of overlap options. ``<overlap>`` is assigned to an enumerated type called ``mluPoolBPOverlap`` that contains 2 enumerators listed in the table below.
 *
 *\rst
 * .. table::  Semantics of ``mluPoolBPOverlap``
 *    :widths: 5 12
 *
 *    +----------------------------+-------------------------------------------------+
 *    | ``mluPoolBPOverlap`` Type  |                   Semantic                      |
 *    +============================+=================================================+
 *    | ``OVERLAP_ACC``            | Accumulates the overlap parts of the output.    |
 *    +----------------------------+-------------------------------------------------+
 *    | ``OVERLAP_COVER``          | Covers the overlap parts of the output.         |
 *    +----------------------------+-------------------------------------------------+
 *\endrst
 *
 * @details
 *
 * @param[out] dst The address of destination tensor whose data layout is HWC.
 * @param[in] src The address of source tensor whose data layout is HWC.
 * @param[in] channel Input channel.
 * @param[in] height The height of output feature map.
 * @param[in] width The width of output feature map.
 * @param[in] kernel_height The height of kernel.
 * @param[in] kernel_width The width of kernel.
 * @param[in] stride_width Stride of sliding window in W direction.
 * @param[in] stride_height Stride of sliding window in H direction.
 * @param[in] overlap The type of overlap options.
 * @return ``void``.
 * @remark
 * \rst
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<channel>`` * ``sizeof(type)`` must be divisible by 128 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - When window is slided in certain direction (H or W direction), if the left elements number doesn't match the window size, these elements will be discarded;
 * - The result is a three-dimensional tensor with HWC data layout;
 * - ``<dst>`` and ``<src>`` can not be homologous operands;
 * - The default ``mluPoolBPOverlap`` option is ``OVERLAP_ACC``;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_binary_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *     #include <bang.h>
 *
 *     __mlu_entry__ void PoolAvgBpKernel(half* output, half* input,
 *                                        int channels, int out_height,
 *                                        int out_width, int kernel_height,
 *                                        int kernel_width, int stride_width,
 *                                        int stride_height) {
 *       __nram__ half a_tmp[INPUT_COUNT];
 *       __nram__ half b_tmp[OUTPUT_COUNT];
 *       __memcpy(b_tmp, output, OUTPUT_COUNT * sizeof(half), GDRAM2NRAM);
 *       __memcpy(a_tmp, input, INPUT_COUNT * sizeof(half), GDRAM2NRAM);
 *       __bang_avgpool_bp(b_tmp, a_tmp, channels, out_height, out_width,
 *                         kernel_height, kernel_width, stride_width,
 *                         stride_height);
 *       __memcpy(output, b_tmp, OUTPUT_COUNT * sizeof(half), NRAM2GDRAM);
 *    }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_avgpool_bp(float* dst,
                                                           float* src,
                                                           int channel,
                                                           int height,
                                                           int width,
                                                           int kernel_height,
                                                           int kernel_width,
                                                           int stride_width,
                                                           int stride_height,
                                                           mluPoolBPOverlap overlap = OVERLAP_ACC);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_maxpool_bp(half* dst,
                                                           half* src,
                                                           short* mask,
                                                           int channel,
                                                           int height,
                                                           int width,
                                                           int kernel_height,
                                                           int kernel_width,
                                                           int stride_width,
                                                           int stride_height,
                                                           mluPoolBPOverlap overlap = OVERLAP_ACC);
static __mlu_func__ __mlu_builtin__ void __bang_maxpool_bp(bfloat16_t* dst,
                                                           bfloat16_t* src,
                                                           unsigned short* mask,
                                                           int channel,
                                                           int height,
                                                           int width,
                                                           int kernel_height,
                                                           int kernel_width,
                                                           int stride_width,
                                                           int stride_height,
                                                           mluPoolBPOverlap overlap = OVERLAP_ACC);
//Group:Stream Operation Functions
/**
 * @brief Applies maxpooling backward propagation operation on ``<src>`` [``<height>``, ``<width>``, ``<channel>``], a three-dimensional tensor, with sliding window [``<kernel_height>``, ``<kernel_width>``] and stride [``<stride_width>``, ``<stride_height>``], and selects the index with the maximum value. ``<overlap>`` indicates the type of overlap options. ``<overlap>`` is assigned to an enumerated type called ``mluPoolBPOverlap`` that contains 2 enumerators listed in the table below.
 *
 *\rst
 * .. table::  Semantics of ``mluPoolBPOverlap``
 *    :widths: 5 12
 *
 *    +----------------------------+-------------------------------------------------+
 *    | ``mluPoolBPOverlap`` Type  |                   Semantic                      |
 *    +============================+=================================================+
 *    | ``OVERLAP_ACC``            | Accumulates the overlap parts of the output.    |
 *    +----------------------------+-------------------------------------------------+
 *    | ``OVERLAP_COVER``          | Covers the overlap parts of the output.         |
 *    +----------------------------+-------------------------------------------------+
 *
 *\endrst
 *
 * @param[out] dst The address of destination tensor whose data layout is HWC.
 * @param[in] src The address of source tensor whose data layout is HWC.
 * @param[in] mask The index of the maximum value inside a kernel, and the tensor data layout is HWC.
 * @param[in] channel Input channel.
 * @param[in] height The height of output feature map.
 * @param[in] width The width of output feature map.
 * @param[in] kernel_height The height of kernel.
 * @param[in] kernel_width The width of kernel.
 * @param[in] stride_width Stride of sliding window in W direction.
 * @param[in] stride_height Stride of sliding window in H direction.
 * @param[in] overlap The type of overlap options.
 * @return ``void``.
 * @remark
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<src>`` and ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<channel>`` * ``sizeof(type)`` must be divisible by 128 on ``(m)tp_2xx``;
 * - When window is slided in certain direction (H or W direction), if the left elements number doesn't match the window size, these elements will be discarded;
 * - The result is a three-dimensional tensor with HWC data layout;
 * - When the data type of ``<src>`` and ``<dst>`` are ``half``, the data type of ``<mask>`` must be ``short``. When the data type of ``<src>`` and ``<dst>`` are float, the data type of ``<mask>`` must be ``int``.
 * - This interface is not supported on ``(m)tp_2xx`` and higher;
 * - ``<dst>`` and ``<src>`` can not be homologous operands;
 * - The default ``mluPoolBPOverlap`` option is ``OVERLAP_ACC``.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *    #include <bang.h>
 *
 *    __mlu_entry__ void PoolMaxBpKernel(half* output, half* input, int16_t* mask,
 *                                       int channels, int out_height,
 *                                       int out_width, int kernel_height,
 *                                       int kernel_width, int stride_width,
 *                                       int stride_height) {
 *      __nram__ half a_tmp[INPUT_COUNT];
 *      __nram__ half b_tmp[OUTPUT_COUNT];
 *      __nram__ int16_t c_tmp[INPUT_COUNT];
 *
 *      __memcpy(b_tmp, output, OUTPUT_COUNT * sizeof(half), GDRAM2NRAM);
 *      __memcpy(a_tmp, input, INPUT_COUNT * sizeof(half), GDRAM2NRAM);
 *      __memcpy(c_tmp, mask, INPUT_COUNT * sizeof(int16_t), GDRAM2NRAM);
 *
 *      __bang_maxpool_bp(b_tmp, a_tmp, c_tmp, channels, out_height, out_width,
 *                        kernel_height, kernel_width, stride_width, stride_height);
 *
 *      __memcpy(output, b_tmp, OUTPUT_COUNT * sizeof(half), NRAM2GDRAM);
 *    }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_maxpool_bp(float* dst,
                                                           float* src,
                                                           int* mask,
                                                           int channel,
                                                           int height,
                                                           int width,
                                                           int kernel_height,
                                                           int kernel_width,
                                                           int stride_width,
                                                           int stride_height,
                                                           mluPoolBPOverlap overlap = OVERLAP_ACC);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_histogram(half* dst,
                                                          int8* src,
                                                          int8* kernel,
                                                          int size);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_histogram(float* dst,
                                                          int8* src,
                                                          int8* kernel,
                                                          int size);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_histogram(int16* dst,
                                                          int8* src,
                                                          int8* kernel,
                                                          int size);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_histogram(int* dst,
                                                          int8* src,
                                                          int8* kernel,
                                                          int size);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_histogram(half* dst,
                                                          int16* src,
                                                          int16* kernel,
                                                          int size);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_histogram(float* dst,
                                                          int16* src,
                                                          int16* kernel,
                                                          int size);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_histogram(int16* dst,
                                                          int16* src,
                                                          int16* kernel,
                                                          int size);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_histogram(int* dst,
                                                          int16* src,
                                                          int16* kernel,
                                                          int size);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_histogram(float* dst,
                                                          half* src,
                                                          half* kernel,
                                                          int size);
//Group:Stream Operation Functions
/**
 * @brief Generate a histogram of ``<src>`` according to kernel.
 *
 * @details
 *
 * @param[out] dst The address of destination vector
 * @param[in] src The address of source vector
 * @param[in] kernel The address of kernel vector
 * @param[in] size The elements number of source vector
 * @return ``void``.
 * @remark
 * - This interface is supported on ``tp_220``, ``(m)tp_3xx`` and higher;
 * - ``<dst>`` and ``<src>`` must point to ``__nram__`` space;
 * - ``<kernel>`` must point to ``__wram__`` space;
 * - The address of ``<dst>`` and ``<src>`` must be 64-byte aligned;
 * - The address of ``<kernel>`` must be 32-byte aligned;
 * - ``<elem_count> * sizeof(typeof<src>)`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - The element number of ``<dst>`` is 64;
 * - ``<elem_count>`` must be greater than 0;
 * - ``<dst>`` and ``<src>`` can not be homologous operands;
 *
 * @par
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_binary_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Compatibility between Various Architectures
 * @par
 * \rst
 *
 * .. table::  Histogram Data Types Supported on ``(m)tp_220``
 *    :widths: 25 20 20
 *
 *    +--------------+--------------+----------------+
 *    | Src Type     | Kernel Type  |  Dst Type      |
 *    +==============+==============+================+
 *    | int8         | int8         |  int32         |
 *    +--------------+--------------+----------------+
 *    | int16        | int16        |  int32         |
 *    +--------------+--------------+----------------+
 *
 * .. table::  Conv Data Types Supported on ``mtp_372``
 *    :widths: 25 20 20
 *
 *    +--------------+--------------+----------------+
 *    | Src Type     | Kernel Type  |  Dst Type      |
 *    +==============+==============+================+
 *    | int8         | int8         |  half          |
 *    +--------------+--------------+----------------+
 *    | int8         | int8         |  float         |
 *    +--------------+--------------+----------------+
 *    | int8         | int8         |  int16         |
 *    +--------------+--------------+----------------+
 *    | int8         | int8         |  int32         |
 *    +--------------+--------------+----------------+
 *    | int16        | int16        |  half          |
 *    +--------------+--------------+----------------+
 *    | int16        | int16        |  float         |
 *    +--------------+--------------+----------------+
 *    | int16        | int16        |  int16         |
 *    +--------------+--------------+----------------+
 *    | int16        | int16        |  int32         |
 *    +--------------+--------------+----------------+
 *    | half         | half         |  float         |
 *    +--------------+--------------+----------------+
 *    | bfloat16_t   | bfloat16_t   |  float         |
 *    +--------------+--------------+----------------+
 *
 * .. table::  Conv Data Types Supported on ``tp_322``
 *    :widths: 25 20 20
 *
 *    +--------------+--------------+----------------+
 *    | Src Type     | Kernel Type  |  Dst Type      |
 *    +==============+==============+================+
 *    | int8         | int8         |  half          |
 *    +--------------+--------------+----------------+
 *    | int8         | int8         |  float         |
 *    +--------------+--------------+----------------+
 *    | int8         | int8         |  int16         |
 *    +--------------+--------------+----------------+
 *    | int8         | int8         |  int32         |
 *    +--------------+--------------+----------------+
 *    | int16        | int16        |  half          |
 *    +--------------+--------------+----------------+
 *    | int16        | int16        |  float         |
 *    +--------------+--------------+----------------+
 *    | int16        | int16        |  int16         |
 *    +--------------+--------------+----------------+
 *    | int16        | int16        |  int32         |
 *    +--------------+--------------+----------------+
 * \endrst
 *
 * @par Example
 * @par
 * The data layout of ``<kernel>`` is 64 rows. Every row is 64 bytes, and the value of each row is corresponding to the histogram of x-axis. There are 32 values in each row when data format is int16, and 64 values when data format is int8;
 *
 * @par
 * For example, src is 0 1 2 3 0 1 2 3 3. As kernel's first line is 0, this function selects ``<src>``'s "0" and generates 2; as kernel's second line is 1, it selects ``<src>``'s "1" and generates 2; as kernel's third line is 2, it selects ``<src>``'s "2" and generates 2; as kernel's fourth line is 3, it selects ``<src>``'s "3" and generates 3; as kernel's the other line is 0, it generates 2.
 *
 * @par
 * Therefore, ``<dst>`` is ``2 2 2 3 2 2 ... 2`` and the number of elements of ``<dst>`` is 64.
 *
 * @par
 * @code
 *
 *    #include <bang.h>
 *
 *    #define SRC_NUM 512
 *    #define DST_NUM 64
 *    #define WEI_NUM (64 * 32)
 *
 *    __mlu_entry__ void kernel(int32_t* dst, int16_t* src, int16_t* filter, int size) {
 *      __nram__ int32_t dst_tmp[DST_NUM];
 *      __nram__ int16_t src_tmp[SRC_NUM];
 *      __wram__ int16_t filter_tmp[WEI_NUM];
 *      __memcpy(src_tmp, src, SRC_NUM * sizeof(int16_t), GDRAM2NRAM);
 *      __memcpy(filter_tmp, filter, WEI_NUM * sizeof(int16_t), GDRAM2WRAM);
 *      __bang_write_zero((half*)dst_tmp, DST_NUM * 2);
 *      __bang_histogram(dst_tmp, src_tmp, filter_tmp, size);
 *      __memcpy(dst, dst_tmp, DST_NUM * sizeof(int32_t), NRAM2GDRAM);
 *    }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_histogram(float* dst,
                                                          bfloat16_t* src,
                                                          bfloat16_t* kernel,
                                                          int size);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_integral(int* dst,
                                                         short* src,
                                                         short* kernel,
                                                         int size);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_integral(short* dst,
                                                         short* src,
                                                         short* kernel,
                                                         int size);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_integral(half* dst,
                                                         int16* src,
                                                         int16* kernel,
                                                         int size,
                                                         int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_integral(float* dst,
                                                         int16* src,
                                                         int16* kernel,
                                                         int size,
                                                         int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_integral(int* dst,
                                                         char* src,
                                                         char* kernel,
                                                         int size);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_integral(short* dst,
                                                         char* src,
                                                         char* kernel,
                                                         int size);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_integral(half* dst,
                                                         int8* src,
                                                         int8* kernel,
                                                         int size,
                                                         int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_integral(float* dst,
                                                         int8* src,
                                                         int8* kernel,
                                                         int size,
                                                         int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_integral(float* dst,
                                                         float* src,
                                                         float* kernel,
                                                         int size);
//Group:Stream Operation Functions
/**
 * @brief Generate integral of ``<src>`` according to ``<kernel>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector
 * @param[in] src The address of source vector
 * @param[in] kernel The address of kernel vector
 * @param[in] size The elements number of source vector
 * @param[in] fix_position Scale factor. \f$<src\_value> = <src> \div 2^{<fix\_position>}\f$.
 * @return ``void``.
 * @remark
 * - This interface is supported on ``(m)tp_3xx`` and higher;
 * - ``tp_322`` does not support ``<src>`` whose data type is ``float`` or ``half``;
 * - ``<dst>`` and ``<src>`` must point to ``__nram__`` space;
 * - ``<kernel>`` must point to ``__wram__`` space;
 * - The address of ``<dst>`` and ``<src>`` must be 64-byte aligned;
 * - The address of ``<kernel>`` must be 32-byte aligned;
 * - ``<size> * sizeof(typeof<src>)`` must be 64-byte aligned;
 * - ``<dst>`` and ``<src>`` can not be homologous operands;
 * - When data type of ``<src>`` is ``int8`` or ``char``, ``<kernel>`` should be \f$64 \times 64\f$ Lower Triangular Matrix(LTM); when data type of ``<src>`` is ``int16``, ``short`` or ``half``, ``<kernel>`` should be \f$32 \times 32\f$ LTM; when datatype of ``<src>`` is ``float``, ``<kernel>`` should be \f$16 \times 16\f$ LTM; ``kernel`` always requires 4096 bytes of memory, LTM should be placed at the beginning of the memory;
 * - Generally, the value of elements in the LTM should be ``1``, so ``<dst>[n]`` is sum of ``<src>[0]`` to ``<src>[n]``;
 * - When data type of ``<src>`` is ``int8`` or ``char``, ``<size>`` cannot be greater than ``65472``; when data type of ``<src>`` is ``int16``, ``short`` or ``half``, ``<size>`` cannot be greater than ``32736``; when datatype of ``<src>`` is ``float``, ``<size>`` cannot be greater than ``16368``;
 * - ``<fix_position>`` must be in the range ``[-127, 127]``.
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *   - BANG Version: ``__BANG_ARCH__ >= 322``;
 *   - CNCC Version: ``cncc --version >= 3.2.0``;
 *   - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *   - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322``.
 *
 * @par Example
 * @par
 * If ``<size>`` is 64,  ``<src>`` is ``[1, 1, ... 1, 1]``, ``<dst>`` should be ``[1, 2, 3, ... 63, 64]``.
 *
 * @par
 * @code
 *
 *   #include <bang.h>
 *
 *   #define DATA_NUM 64
 *   #define KERNEL_SIZE (4096 / sizeof(short))
 *
 *   __mlu_entry__ void kernel(int* dst, short* src, short* kernel, int size) {
 *     __nram__ int dst_tmp[DATA_NUM];
 *     __nram__ short src_tmp[DATA_NUM];
 *     __wram__ short kernel_tmp[KERNEL_SIZE];
 *     __memcpy(src_tmp, src, DATA_NUM * sizeof(short), GDRAM2NRAM);
 *     __memcpy(kernel_tmp, kernel, KERNEL_SIZE * sizeof(short), GDRAM2WRAM);
 *     __bang_integral(dst_tmp, src_tmp, kernel_tmp, size);
 *     __memcpy(dst, dst_tmp, DATA_NUM * sizeof(int), NRAM2GDRAM);
 *   }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_integral(float* dst,
                                                         half* src,
                                                         half* kernel,
                                                         int size);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int8* src,
                                                             int8* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int16* src,
                                                             int8* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int16* src,
                                                             int16* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int8* src,
                                                             int8* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int16* src,
                                                             int8* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int16* src,
                                                             int16* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int8* src,
                                                             int8* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int indilation_width,
                                                             int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int16* src,
                                                             int8* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int indilation_width,
                                                             int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int16* src,
                                                             int16* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int indilation_width,
                                                             int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int8* src,
                                                             int8* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int indilation_width,
                                                             int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int16* src,
                                                             int8* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int indilation_width,
                                                             int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int16* src,
                                                             int16* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int indilation_width,
                                                             int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             half* src,
                                                             half* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             half* src,
                                                             float* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             float* src,
                                                             half* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             float* src,
                                                             float* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             bfloat16_t* src,
                                                             bfloat16_t* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             bfloat16_t* src,
                                                             float* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             float* src,
                                                             bfloat16_t* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             half* src,
                                                             half* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int indilation_width,
                                                             int indilation_height,
                                                             int outdilation_width,
                                                             int outdilation_height);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             float* src,
                                                             float* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int indilation_width,
                                                             int indilation_height,
                                                             int outdilation_width,
                                                             int outdilation_height);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             float* src,
                                                             half* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int indilation_width,
                                                             int indilation_height,
                                                             int outdilation_width,
                                                             int outdilation_height);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             half* src,
                                                             float* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int indilation_width,
                                                             int indilation_height,
                                                             int outdilation_width,
                                                             int outdilation_height);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             float* src,
                                                             bfloat16_t* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int indilation_width,
                                                             int indilation_height,
                                                             int outdilation_width,
                                                             int outdilation_height);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             bfloat16_t* src,
                                                             bfloat16_t* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int indilation_width,
                                                             int indilation_height,
                                                             int outdilation_width,
                                                             int outdilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int4x2_t* src,
                                                             int4x2_t* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int4x2_t* src,
                                                             int4x2_t* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int4x2_t* src,
                                                             int8* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int4x2_t* src,
                                                             int8* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int4x2_t* src,
                                                             int16* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int4x2_t* src,
                                                             int16* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int8* src,
                                                             int4x2_t* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int8* src,
                                                             int4x2_t* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int16* src,
                                                             int4x2_t* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int16* src,
                                                             int4x2_t* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int4x2_t* src,
                                                             int4x2_t* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int indilation_width,
                                                             int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int4x2_t* src,
                                                             int4x2_t* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int indilation_width,
                                                             int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int4x2_t* src,
                                                             int8* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int indilation_width,
                                                             int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int4x2_t* src,
                                                             int8* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int indilation_width,
                                                             int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int4x2_t* src,
                                                             int16* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int indilation_width,
                                                             int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int4x2_t* src,
                                                             int16* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int indilation_width,
                                                             int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int8* src,
                                                             int4x2_t* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int indilation_width,
                                                             int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int8* src,
                                                             int4x2_t* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int indilation_width,
                                                             int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int16* src,
                                                             int4x2_t* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int indilation_width,
                                                             int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int16* src,
                                                             int4x2_t* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int indilation_width,
                                                             int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int4x2_t* src,
                                                             int4x2_t* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int indilation_width,
                                                             int indilation_height,
                                                             int outdilation_width,
                                                             int outdilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int4x2_t* src,
                                                             int4x2_t* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int indilation_width,
                                                             int indilation_height,
                                                             int outdilation_width,
                                                             int outdilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int4x2_t* src,
                                                             int8* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int indilation_width,
                                                             int indilation_height,
                                                             int outdilation_width,
                                                             int outdilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int4x2_t* src,
                                                             int8* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int indilation_width,
                                                             int indilation_height,
                                                             int outdilation_width,
                                                             int outdilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int4x2_t* src,
                                                             int16* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int indilation_width,
                                                             int indilation_height,
                                                             int outdilation_width,
                                                             int outdilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int4x2_t* src,
                                                             int16* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int indilation_width,
                                                             int indilation_height,
                                                             int outdilation_width,
                                                             int outdilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int8* src,
                                                             int4x2_t* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int indilation_width,
                                                             int indilation_height,
                                                             int outdilation_width,
                                                             int outdilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int8* src,
                                                             int4x2_t* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int indilation_width,
                                                             int indilation_height,
                                                             int outdilation_width,
                                                             int outdilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(half* dst,
                                                             int16* src,
                                                             int4x2_t* kernel,
                                                             half* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int indilation_width,
                                                             int indilation_height,
                                                             int outdilation_width,
                                                             int outdilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             int16* src,
                                                             int4x2_t* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int fix_position,
                                                             int indilation_width,
                                                             int indilation_height,
                                                             int outdilation_width,
                                                             int outdilation_height);


//Group:Stream Operation Functions
/**
 * @brief Performs partial convolution operation.
 *
 * @details In ``__nram__`` address space, uses the four-dimensional convolution kernel ``<kernel>[<channel_output>, <kernel_height>, <kernel_width>, <channel_input>]`` to perform a partial convolution operation on the three-dimensional tensor ``<src>[<height>, <width>, <channel_input>]`` with an interactive step size of ``[<stride_width>, <stride_height>]``, then adds the three-dimensional tensor ``<partial>[<dst_height>, <dst_width>, <channel_output>]``, and stores the result in the three-dimensional tensor ``<dst>[<dst_height>, <dst_width>, <channel_output>]``.
 *
 * @param[out] dst The address of destination tensor which has \f$NH_oW_oC_o\f$ data layout.
 * @param[in] src The address of source tensor which has \f$NH_iW_iC_i\f$ data layout.
 * @param[in] kernel The address of filter tensor which has \f$C_oH_kW_kC_i\f$ data layout.
 * @param[in] partial The address of partial_sum tensor which has \f$NH_oW_oC_o\f$ data layout.
 * @param[in] channel_input Number of input channels.
 * @param[in] height The height of source tensor.
 * @param[in] width The width of source tensor.
 * @param[in] kernel_height The height of filter tensor.
 * @param[in] kernel_width The width of filter tensor.
 * @param[in] stride_width The stride in W direction.
 * @param[in] stride_height The stride in H direction.
 * @param[in] channel_output Number of output channels.
 * @param[in] fix_position Scale factor. \f$<src\_value> = <src>\div 2^{<fix\_position>}\f$
 * @param[in] indilation_width Input dilation in W direction.
 * @param[in] indilation_height Input dilation in H direction.
 * @param[in] outdilation_width Output dilation in W direction.
 * @param[in] outdilation_height Output dilation in H direction.
 *
 * @return ``void``
 *
 * @remark
 * - Supported on ``(m)tp_2xx`` and higher;
 * - ``<src>``, ``<dst>`` and ``<partial>`` must point to ``__nram__`` space;
 * - ``<kernel>`` must point to ``__wram__`` space;
 * - ``<fix_position>`` of ``<dst>`` is the sum of the ``<fix_position>`` of ``<src>`` and ``<kernel>``.
 * - ``<fix_position>`` must be in the range [-127, 127];
 * - The address of ``<dst>``, ``<src>`` or ``<partial>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - The address of ``<kernel>`` must be 32-byte aligned;
 * - <kernel> needs to be reshaped through interface ::__bang_reshape_filter on device-side, or ``cnrtFilterReshape`` on host-side;
 * - ``<channel_input> * sizeof(typeof<src>)`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<channel_output>`` must be divisible by 64 on ``(m)tp_2xx``;
 * - ``<channel_output> * sizeof(typeof<dst>)`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - On ``(m)tp_3xx``, if ``--bang-wram-align64`` option is used, the byte size of ``<kernel>`` must be 64-byte aligned; otherwise, the byte size of ``<kernel>`` must be 32-byte aligned;
 * - On ``(m)tp_3xx``, ``ci`` dimension space of ``<kernel>`` must satisfy the following alignment constraints:
 *
 *    - If ``sizeof(typeof<src>) / sizeof(typeof<kernel>) == 4``, ``ci * sizeof(typeof<kernel>)`` must be 16-byte aligned;
 *    - If ``sizeof(typeof<src>) / sizeof(typeof<kernel>) == 2``, ``ci * sizeof(typeof<kernel>)`` must be 32-byte aligned;
 *    - If ``sizeof(typeof<src>) / sizeof(typeof<kernel>)`` doesn't satisfy the above mentioned constraints, ``ci * sizeof(typeof<kernel>)`` must be 64-byte aligned;
 *
 * - ``co`` dimension space of ``<kernel>`` must satisfy that ``co`` is divisible by 64 on ``(m)tp_3xx``;
 * - On ``(m)tp_3xx``, if ``<kernel>`` does not follow the above alignment rules, the values of the non-aligned part will be random numbers, which may cause calculation errors;
 * - The difference between ::__bang_conv_partial and ::__bang_conv with bias version is: the parameter ``<partial>`` of ::__bang_conv_partial is a tensor with the same shape as the ``<dst>``; and the parameter ``<bias>``  of ::__bang_conv is a vector  whose length is the same with the numbers of channels of ``<dst>``;
 * - ``<kernel_height>``, ``<kernel_width>``, ``<channel_input>`` and ``<channel_output>`` must be greater than 0;
 * - ``<stride_width>`` and ``<stride_height>`` must be in range [1, 1023];
 * - ``<indilation_width>``, ``<indilation_height>``, ``<outdilation_width>`` and ``<outdilation_height>`` must be in range [1, 1023], and 1 means no dilation;
 * - If ``<indilation_height>`` is used, ``(<height> - ((<kernel_height> - 1) * <indilation_height> + 1)) / <stride_height> + 1`` must be greater than 0; otherwise, ``(<height> - <kernel_height>) / <stride_height> + 1`` must be greater than 0;
 * - If ``<indilation_width>`` is used, ``(<width> - ((<kernel_width> - 1) * <indilation_width> + 1)) / <stride_width> + 1`` must be greater than 0; otherwise, ``(<width> - <kernel_width>) / <stride_width> + 1`` must be greater than 0;
 * - On target ``(m)tp_322`` , ``<kernel>`` must be ``int4``, ``int8`` or ``int16``;
 * - On target ``(m)tp_322`` , if use ``<indilation_height>`` , ``(<height> - ((<kernel_height> - 1) * <indilation_height> + 1)) / <stride_height> + 1`` must be in the range ``[1, 1024]`` .
 * - On target ``(m)tp_322`` , if use ``<dilation_height>`` , ``(<height> - ((<kernel_height> - 1) * <dilation_height> + 1)) / <stride_height> + 1`` must be in the range ``[1, 1024]`` .
 * - On target ``(m)tp_322`` , if neither ``<dilation_height>`` nor ``<indilation_height>`` are used, ``(<height> - <kernel_height>) / <stride_height> + 1`` must be in the range ``[1, 1024]`` .
 * - ``<dst>`` and ``<src>`` can not be homologous operands;
 * - ``<dst>`` and ``<partial>`` can be homologous operands;
 *
 * @par
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_binary_operation_functions` for more details.
 * \endrst
 *
 * @par Compatibility between Various Architectures
 * @par
 * \rst
 *
 * .. table::  Conv Partial Data Types Supported on ``(m)tp_2xx``
 *    :widths: 25 20 20 20
 *    :class: longtable
 *
 *    +--------------+--------------+----------------+--------------+
 *    | Src Type     | Kernel Type  |  Dst Type      |  Partial Type|
 *    +==============+==============+================+==============+
 *    | int16        | int8         |  float         |  float       |
 *    +--------------+--------------+----------------+--------------+
 *    | int8         | int8         |  float         |  float       |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int16        |  float         |  float       |
 *    +--------------+--------------+----------------+--------------+
 *    | int4         | int4         |  float         |  float       |
 *    +--------------+--------------+----------------+--------------+
 *    | int8         | int4         |  float         |  float       |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int4         |  float         |  float       |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int16        |  half          |  half        |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int8         |  half          |  half        |
 *    +--------------+--------------+----------------+--------------+
 *    | int8         | int8         |  half          |  half        |
 *    +--------------+--------------+----------------+--------------+
 *    | int4         | int4         |  half          |  half        |
 *    +--------------+--------------+----------------+--------------+
 *    | int8         | int4         |  half          |  half        |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int4         |  half          |  half        |
 *    +--------------+--------------+----------------+--------------+
 *
 * .. table::  Conv Partial Data Types Supported on ``(m)tp_3xx``
 *    :widths: 25 20 20 20
 *    :class: longtable
 *
 *    +--------------+--------------+----------------+--------------+
 *    | Src Type     | Kernel Type  |  Dst Type      |  Partial Type|
 *    +==============+==============+================+==============+
 *    | int16        | int8         |  float         |  float       |
 *    +--------------+--------------+----------------+--------------+
 *    | int8         | int8         |  float         |  float       |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int16        |  float         |  float       |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int16        |  half          |  half        |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int8         |  half          |  half        |
 *    +--------------+--------------+----------------+--------------+
 *    | int8         | int8         |  half          |  half        |
 *    +--------------+--------------+----------------+--------------+
 *    | float        | float        |  float         |  float       |
 *    +--------------+--------------+----------------+--------------+
 *    | float        | half         |  float         |  float       |
 *    +--------------+--------------+----------------+--------------+
 *    | half         | float        |  float         |  float       |
 *    +--------------+--------------+----------------+--------------+
 *    | half         | half         |  float         |  float       |
 *    +--------------+--------------+----------------+--------------+
 *    | float        | bfloat16_t   |  float         |  float       |
 *    +--------------+--------------+----------------+--------------+
 *    | bfloat16_t   | float        |  float         |  float       |
 *    +--------------+--------------+----------------+--------------+
 *    | bfloat16_t   | bfloat16_t   |  float         |  float       |
 *    +--------------+--------------+----------------+--------------+
 *    | int4         | int4         |  float         |  float       |
 *    +--------------+--------------+----------------+--------------+
 *    | int4         | int8         |  float         |  float       |
 *    +--------------+--------------+----------------+--------------+
 *    | int4         | int16        |  float         |  float       |
 *    +--------------+--------------+----------------+--------------+
 *    | int8         | int4         |  float         |  float       |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int4         |  float         |  float       |
 *    +--------------+--------------+----------------+--------------+
 *    | int4         | int4         |  half          |  half        |
 *    +--------------+--------------+----------------+--------------+
 *    | int4         | int8         |  half          |  half        |
 *    +--------------+--------------+----------------+--------------+
 *    | int4         | int16        |  half          |  half        |
 *    +--------------+--------------+----------------+--------------+
 *    | int8         | int4         |  half          |  half        |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int4         |  half          |  half        |
 *    +--------------+--------------+----------------+--------------+
 *
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *    #include <bang.h>
 *
 *    #define IN_CHANNEL 128
 *    #define IN_HEIGHT 9
 *    #define IN_WIDTH 8
 *    #define FILTER_HEIGHT 2
 *    #define FILTER_WIDTH 3
 *    #define STRIDE_HEIGHT 4
 *    #define STRIDE_WIDTH 3
 *    #define OUT_CHANNEL 64
 *    #define POS 2
 *    #define DILATION_HEIGHT 4
 *    #define DILATION_WIDTH 2
 *
 *    #define NEW_FILTER_HEIGHT ((FILTER_HEIGHT - 1) * DILATION_HEIGHT + 1)
 *    #define NEW_FILTER_WIDTH ((FILTER_WIDTH - 1) * DILATION_WIDTH + 1)
 *    #define OUT_HEIGHT ((((IN_HEIGHT) - (NEW_FILTER_HEIGHT)) / (STRIDE_HEIGHT)) + 1)
 *    #define OUT_WIDTH ((((IN_WIDTH) - (NEW_FILTER_WIDTH)) / (STRIDE_WIDTH)) + 1)
 *    #define OUT_DATA_NUM ((OUT_HEIGHT) * (OUT_WIDTH) * (OUT_CHANNEL))
 *    #define IN_DATA_NUM ((IN_HEIGHT) * (IN_WIDTH) * (IN_CHANNEL))
 *    #define FILTER_DATA_NUM ((FILTER_HEIGHT) * (FILTER_WIDTH) *\
 *                            (IN_CHANNEL) * (OUT_CHANNEL))
 *
 *    __mlu_entry__ void ConvKernel(float *out_data, int16_t *in_data,
 *                                  int16_t *filter_data, float *partial_data) {
 *      __nram__ float nram_out_data[OUT_DATA_NUM];
 *      __nram__ int16_t nram_in_data[IN_DATA_NUM];
 *      __nram__ float nram_partial_data[OUT_DATA_NUM];
 *      __wram__ int16_t wram_filter[FILTER_DATA_NUM];
 *
 *      __memcpy(nram_in_data, in_data, IN_DATA_NUM * sizeof(int16_t), GDRAM2NRAM);
 *      __memcpy(wram_filter, filter_data, FILTER_DATA_NUM * sizeof(int16_t), GDRAM2WRAM);
 *      __memcpy(nram_partial_data, partial_data, OUT_DATA_NUM * sizeof(float),
 *               GDRAM2NRAM);
 *
 *      __bang_conv_partial(nram_out_data, nram_in_data, wram_filter,
 *                          nram_partial_data, IN_CHANNEL, IN_HEIGHT, IN_WIDTH,
 *                          FILTER_HEIGHT, FILTER_WIDTH, STRIDE_WIDTH, STRIDE_HEIGHT,
 *                          OUT_CHANNEL, POS, DILATION_WIDTH, DILATION_HEIGHT);
 *      __memcpy(out_data, nram_out_data, OUT_DATA_NUM * sizeof(float), NRAM2GDRAM);
 *    }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_conv_partial(float* dst,
                                                             bfloat16_t* src,
                                                             float* kernel,
                                                             float* partial,
                                                             int channel_input,
                                                             int height,
                                                             int width,
                                                             int kernel_height,
                                                             int kernel_width,
                                                             int stride_width,
                                                             int stride_height,
                                                             int channel_output,
                                                             int indilation_width,
                                                             int indilation_height,
                                                             int outdilation_width,
                                                             int outdilation_height);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(int16* dst,
                                                     int16* src,
                                                     int8* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(int16* dst,
                                                     int16* src,
                                                     int8* kernel,
                                                     int16* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(int16* dst,
                                                     int16* src,
                                                     int16* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(int16* dst,
                                                     int16* src,
                                                     int16* kernel,
                                                     int16* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int16* src,
                                                     int8* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int16* src,
                                                     int16* kernel,
                                                     float* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(int16* dst,
                                                     int8* src,
                                                     int8* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(int16* dst,
                                                     int8* src,
                                                     int8* kernel,
                                                     int16* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int16* src,
                                                     int8* kernel,
                                                     float* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int16* src,
                                                     int16* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int16* src,
                                                     int8* kernel,
                                                     half* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int8* src,
                                                     int8* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int8* src,
                                                     int8* kernel,
                                                     float* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int16* src,
                                                     int16* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int16* src,
                                                     int16* kernel,
                                                     half* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int16* src,
                                                     int8* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(int16* dst,
                                                     int8* src,
                                                     int8* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(int16* dst,
                                                     int16* src,
                                                     int16* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(int16* dst,
                                                     int16* src,
                                                     int16* kernel,
                                                     int16* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int8* src,
                                                     int8* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int8* src,
                                                     int8* kernel,
                                                     half* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(int16* dst,
                                                     int8* src,
                                                     int8* kernel,
                                                     int16* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(int16* dst,
                                                     int16* src,
                                                     int8* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(int16* dst,
                                                     int16* src,
                                                     int8* kernel,
                                                     int16* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int16* src,
                                                     int8* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int16* src,
                                                     int8* kernel,
                                                     float* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int16* src,
                                                     int16* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int16* src,
                                                     int16* kernel,
                                                     float* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int16* src,
                                                     int8* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int16* src,
                                                     int8* kernel,
                                                     half* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int8* src,
                                                     int8* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int8* src,
                                                     int8* kernel,
                                                     float* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int8* src,
                                                     int8* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int8* src,
                                                     int8* kernel,
                                                     half* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int16* src,
                                                     int16* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int16* src,
                                                     int16* kernel,
                                                     half* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     half* src,
                                                     half* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     float* src,
                                                     float* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     half* src,
                                                     half* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     float* src,
                                                     half* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     half* src,
                                                     float* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     bfloat16_t* src,
                                                     float* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     float* src,
                                                     bfloat16_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     bfloat16_t* src,
                                                     bfloat16_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     float* src,
                                                     float* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int indilation_width,
                                                     int indilation_height,
                                                     int outdilation_width,
                                                     int outdilation_height);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     half* src,
                                                     half* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int indilation_width,
                                                     int indilation_height,
                                                     int outdilation_width,
                                                     int outdilation_height);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     half* src,
                                                     float* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int indilation_width,
                                                     int indilation_height,
                                                     int outdilation_width,
                                                     int outdilation_height);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     float* src,
                                                     half* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int indilation_width,
                                                     int indilation_height,
                                                     int outdilation_width,
                                                     int outdilation_height);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     float* src,
                                                     bfloat16_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int indilation_width,
                                                     int indilation_height,
                                                     int outdilation_width,
                                                     int outdilation_height);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     bfloat16_t* src,
                                                     float* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int indilation_width,
                                                     int indilation_height,
                                                     int outdilation_width,
                                                     int outdilation_height);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int4x2_t* src,
                                                     int4x2_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int4x2_t* src,
                                                     int4x2_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int4x2_t* src,
                                                     int8* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int4x2_t* src,
                                                     int8* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int4x2_t* src,
                                                     int16* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int4x2_t* src,
                                                     int16* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int8* src,
                                                     int4x2_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int8* src,
                                                     int4x2_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int16* src,
                                                     int4x2_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int16* src,
                                                     int4x2_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int4x2_t* src,
                                                     int4x2_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int4x2_t* src,
                                                     int4x2_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int4x2_t* src,
                                                     int8* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int4x2_t* src,
                                                     int8* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int4x2_t* src,
                                                     int16* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int4x2_t* src,
                                                     int16* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int8* src,
                                                     int4x2_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int8* src,
                                                     int4x2_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int16* src,
                                                     int4x2_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int16* src,
                                                     int4x2_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int4x2_t* src,
                                                     int4x2_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height,
                                                     int outdilation_width,
                                                     int outdilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int4x2_t* src,
                                                     int4x2_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height,
                                                     int outdilation_width,
                                                     int outdilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int4x2_t* src,
                                                     int8* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int fix_position,
                                                     int channel_output,
                                                     int indilation_width,
                                                     int indilation_height,
                                                     int outdilation_width,
                                                     int outdilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int4x2_t* src,
                                                     int8* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height,
                                                     int outdilation_width,
                                                     int outdilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int4x2_t* src,
                                                     int16* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height,
                                                     int outdilation_width,
                                                     int outdilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int4x2_t* src,
                                                     int16* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height,
                                                     int outdilation_width,
                                                     int outdilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int8* src,
                                                     int4x2_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height,
                                                     int outdilation_width,
                                                     int outdilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int8* src,
                                                     int4x2_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height,
                                                     int outdilation_width,
                                                     int outdilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int16* src,
                                                     int4x2_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height,
                                                     int outdilation_width,
                                                     int outdilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int16* src,
                                                     int4x2_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height,
                                                     int outdilation_width,
                                                     int outdilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int4x2_t* src,
                                                     int4x2_t* kernel,
                                                     half* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int4x2_t* src,
                                                     int4x2_t* kernel,
                                                     float* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int4x2_t* src,
                                                     int8* kernel,
                                                     half* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int4x2_t* src,
                                                     int8* kernel,
                                                     float* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int4x2_t* src,
                                                     int16* kernel,
                                                     half* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int4x2_t* src,
                                                     int16* kernel,
                                                     float* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int8* src,
                                                     int4x2_t* kernel,
                                                     half* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int8* src,
                                                     int4x2_t* kernel,
                                                     float* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int16* src,
                                                     int4x2_t* kernel,
                                                     half* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int16* src,
                                                     int4x2_t* kernel,
                                                     float* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int4x2_t* src,
                                                     int4x2_t* kernel,
                                                     half* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int4x2_t* src,
                                                     int4x2_t* kernel,
                                                     float* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int4x2_t* src,
                                                     int8* kernel,
                                                     half* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int4x2_t* src,
                                                     int8* kernel,
                                                     float* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int4x2_t* src,
                                                     int16* kernel,
                                                     half* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int4x2_t* src,
                                                     int16* kernel,
                                                     float* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int8* src,
                                                     int4x2_t* kernel,
                                                     half* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int8* src,
                                                     int4x2_t* kernel,
                                                     float* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(half* dst,
                                                     int16* src,
                                                     int4x2_t* kernel,
                                                     half* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     int16* src,
                                                     int4x2_t* kernel,
                                                     float* bias,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int fix_position,
                                                     int indilation_width,
                                                     int indilation_height);

//Group:Stream Operation Functions
/**
 * @brief Performs convolution operation.
 *
 * @details In ``__nram__`` address space, uses the four-dimensional convolution kernel ``<kernel>[<channel_output>, <kernel_height>, <kernel_width>, <channel_input>]`` to perform a convolution operation on the three-dimensional tensor ``<src>[<height>, <width>, <channel_input>]`` with an interactive step size of ``[<stride_width>, <stride_height>]``, and stores the result in the three-dimensional tensor ``<dst>[<dst_height>, <dst_width>, <channel_output>]``.
 *
 * @param[out] dst The address of destination tensor which has \f$NH_oW_oC_o\f$ data layout.
 * @param[in] src The address of source tensor which has \f$NH_iW_iC_i\f$ data layout.
 * @param[in] kernel The address of filter tensor which has \f$C_oH_kW_kC_i\f$ data layout.
 * @param[in] bias The address of bias tensor which has \f$[C_o]\f$ shape.
 * @param[in] channel_input Number of input channels.
 * @param[in] height The height of source tensor.
 * @param[in] width The width of source tensor.
 * @param[in] kernel_height The height of filter tensor.
 * @param[in] kernel_width The width of filter tensor.
 * @param[in] stride_width The stride in W direction.
 * @param[in] stride_height The stride in H direction.
 * @param[in] channel_output Number of output channels.
 * @param[in] fix_position Scale factor. \f$<src\_value> = <src>\div 2^{<fix\_position>}\f$
 * @param[in] indilation_width Input dilation in W direction.
 * @param[in] indilation_height Input dilation in H direction.
 * @param[in] outdilation_width Output dilation in W direction.
 * @param[in] outdilation_height Output dilation in H direction.
 * @return ``void``.
 * @remark
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<src>``, ``<dst>`` and ``<bias>`` must point to ``__nram__`` space;
 * - ``<kernel>`` must point to ``__wram__`` space;
 * - ``<fix_position>`` of ``<dst>`` is the sum of the ``<fix_position>`` of ``<src>`` and ``<kernel>``.
 * - ``<fix_position>`` must be an immediate integer on ``(m)tp_1xx``;
 * - ``<fix_position>`` must be in the range ``[-63, 63]`` on ``(m)tp_1xx``, and in the range ``[-127, 127]`` on ``(m)tp_2xx`` or higher;
 * - The address of ``<dst>``, ``<src>`` and ``<bias>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The address of ``<kernel>`` must be 32-byte aligned;
 * - ``<kernel>`` needs to be reshaped through interface ::__bang_reshape_filter on device-side, or ``cnrtFilterReshape`` on host-side;
 * - ``<channel_input> * sizeof(typeof<src>)`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<channel_output>`` must be divisible by 64 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<channel_output> * sizeof(typeof<dst>)`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ::__bang_conv with ``int`` input version is not recommended, because it is implemented by combination, with lower performance. ``bang_device_functions_extra.h`` should be included when using this version. When ``<channel_input> * <width> * <height> > MAX_CONV_INPUT_BUFFER``, ``MAX_CONV_INPUT_BUFFER / (<width> * <height>)`` should be divisible by 32;
 * - On ``(m)tp_3xx``, if ``--bang-wram-align64`` option is used, the byte size of ``<kernel>`` must be 64-byte aligned; otherwise, the byte size of ``<kernel>`` must be 32-byte aligned;
 * - On ``(m)tp_3xx``, ``ci`` dimension space of ``<kernel>`` must satisfy the following alignment constraints:
 *    - If ``sizeof(typeof<src>) / sizeof(typeof<kernel>) == 4``, ``ci * sizeof(typeof<kernel>)`` must be 16-byte aligned;
 *    - If ``sizeof(typeof<src>) / sizeof(typeof<kernel>) == 2``, ``ci * sizeof(typeof<kernel>)`` must be 32-byte aligned;
 *    - If ``sizeof(typeof<src>) / sizeof(typeof<kernel>)`` doesn't satisfy the above mentioned constraints, ``ci * sizeof(typeof<kernel>)`` must be 64-byte aligned;
 * - ``co`` dimension space of ``<kernel>`` must satisfy that ``co`` is divisible by 64 on ``(m)tp_3xx``;
 * - On ``(m)tp_3xx``, if ``<kernel>`` does not follow the above alignment rules, the values of the non-aligned part will be random numbers, which may cause calculation errors;
 * - The space size of ``<bias>`` is identical to ``<channel_output>``;
 * - ``<kernel_height>``, ``<kernel_width>``, ``<channel_input>`` and ``<channel_output>`` must be greater than 0;
 * - ``<stride_width>`` and ``<stride_height>`` must be in range [1, 1023];
 * - ``<indilation_width>``, ``<indilation_height>``, ``<outdilation_width>`` and ``<outdilation_height>`` must be in range [1, 1023], and 1 means no dilation;
 * - If ``<indilation_height>`` is used, ``(<height> - ((<kernel_height> - 1) * <indilation_height> + 1)) / <stride_height> + 1`` must be greater than 0; otherwise, ``(<height> - <kernel_height>) / <stride_height> + 1`` must be greater than 0;
 * - If ``<indilation_width>`` is used, ``(<width> - ((<kernel_width> - 1) * <indilation_width> + 1)) / <stride_width> + 1`` must be greater than 0; otherwise, ``(<width> - <kernel_width>) / <stride_width> + 1`` must be greater than 0;
 * - On target ``(m)tp_322``, ``<kernel>`` must be ``int4``, ``int8`` or ``int16``;
 * - On target ``(m)tp_322`` , if use ``<indilation_height>`` , ``(<height> - ((<kernel_height> - 1) * <indilation_height> + 1)) / <stride_height> + 1`` must be in the range ``[1, 1024]`` .
 * - On target ``(m)tp_322`` , if use ``<dilation_height>`` , ``(<height> - ((<kernel_height> - 1) * <dilation_height> + 1)) / <stride_height> + 1`` must be in the range ``[1, 1024]`` .
 * - On target ``(m)tp_322`` , if neither ``<dilation_height>`` nor ``<indilation_height>`` are used, ``(<height> - <kernel_height>) / <stride_height> + 1`` must be in range ``[1, 1024]`` .
 * - ``<dst>`` and ``<src>`` can not be homologous operands;
 * - ``<dst>`` and ``<bias>`` can not be homologous operands;
 *
 * @par
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_binary_operation_functions` for more details.
 * \endrst
 *
 * @par Compatibility between Various Architectures
 * @par
 * \rst
 *
 * .. table::  Conv Data Types Supported on ``(m)tp_1xx``
 *    :widths: 25 25 25
 *    :class: longtable
 *
 *    +--------------+--------------+----------------+
 *    | Src Type     | Kernel Type  |  Dst Type      |
 *    +==============+==============+================+
 *    | half         | half         |  half          |
 *    +--------------+--------------+----------------+
 *    | int8         | int8         |  half          |
 *    +--------------+--------------+----------------+
 *
 * .. table::  Conv Data Types Supported on ``(m)tp_2xx``
 *    :widths: 25 20 20 20
 *    :class: longtable
 *
 *    +--------------+--------------+----------------+--------------+
 *    | Src Type     | Kernel Type  |  Dst Type      |  Bias Type   |
 *    +==============+==============+================+==============+
 *    | int4         | int4         |  half          |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | int4         | int4         |  float         |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | int8         | int4         |  half          |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | int8         | int4         |  float         |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | int8         | int8         |  half          |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | int8         | int8         |  float         |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | int8         | int8         |  int16         |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int4         |  half          |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int4         |  float         |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int8         |  half          |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int8         |  float         |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int8         |  int16         |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int16        |  half          |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int16        |  float         |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int16        |  int16         |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | int          | int16        |  float         |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | int4         | int4         |  half          |  half        |
 *    +--------------+--------------+----------------+--------------+
 *    | int4         | int4         |  float         |  float       |
 *    +--------------+--------------+----------------+--------------+
 *    | int8         | int4         |  half          |  half        |
 *    +--------------+--------------+----------------+--------------+
 *    | int8         | int4         |  float         |  float       |
 *    +--------------+--------------+----------------+--------------+
 *    | int8         | int8         |  half          |  half        |
 *    +--------------+--------------+----------------+--------------+
 *    | int8         | int8         |  float         |  float       |
 *    +--------------+--------------+----------------+--------------+
 *    | int8         | int8         |  int16         |  int16       |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int4         |  half          |  half        |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int4         |  float         |  float       |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int8         |  half          |  half        |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int8         |  float         |  float       |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int8         |  int16         |  int16       |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int16        |  half          |  half        |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int16        |  float         |  float       |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int16        |  int16         |  int16       |
 *    +--------------+--------------+----------------+--------------+
 *
 * .. table::  Conv Data Types Supported on ``(m)tp_3xx``
 *    :widths: 25 20 20 20
 *    :class: longtable
 *
 *    +--------------+--------------+----------------+--------------+
 *    | Src Type     | Kernel Type  |  Dst Type      |  Bias Type   |
 *    +==============+==============+================+==============+
 *    | int8         | int8         |  half          |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | int8         | int8         |  float         |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | int8         | int8         |  int16         |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int8         |  half          |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int8         |  float         |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int8         |  int16         |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int16        |  half          |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int16        |  float         |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int16        |  int16         |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | int          | int16        |  float         |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | int8         | int8         |  half          |  half        |
 *    +--------------+--------------+----------------+--------------+
 *    | int8         | int8         |  float         |  float       |
 *    +--------------+--------------+----------------+--------------+
 *    | int8         | int8         |  int16         |  int16       |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int8         |  half          |  half        |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int8         |  float         |  float       |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int8         |  int16         |  int16       |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int16        |  half          |  half        |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int16        |  float         |  float       |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int16        |  int16         |  int16       |
 *    +--------------+--------------+----------------+--------------+
 *    | float        | float        |  float         |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | half         | half         |  float         |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | float        | half         |  float         |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | half         | float        |  float         |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | bfloat16_t   | bfloat16_t   |  float         |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | float        | bfloat16_t   |  float         |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | bfloat16_t   | float        |  float         |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | int4         | int4         |  float         |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | int4         | int8         |  float         |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | int4         | int16        |  float         |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | int8         | int4         |  float         |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int4         |  float         |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | int4         | int4         |  half          |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | int4         | int8         |  half          |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | int4         | int16        |  half          |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | int8         | int4         |  half          |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int4         |  half          |  none        |
 *    +--------------+--------------+----------------+--------------+
 *    | int4         | int4         |  float         |  float       |
 *    +--------------+--------------+----------------+--------------+
 *    | int4         | int8         |  float         |  float       |
 *    +--------------+--------------+----------------+--------------+
 *    | int4         | int16        |  float         |  float       |
 *    +--------------+--------------+----------------+--------------+
 *    | int8         | int4         |  float         |  float       |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int4         |  float         |  float       |
 *    +--------------+--------------+----------------+--------------+
 *    | int4         | int4         |  half          |  half        |
 *    +--------------+--------------+----------------+--------------+
 *    | int4         | int8         |  half          |  half        |
 *    +--------------+--------------+----------------+--------------+
 *    | int4         | int16        |  half          |  half        |
 *    +--------------+--------------+----------------+--------------+
 *    | int8         | int4         |  half          |  half        |
 *    +--------------+--------------+----------------+--------------+
 *    | int16        | int4         |  half          |  half        |
 *    +--------------+--------------+----------------+--------------+

 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * Refer to ::__bang_conv_partial.
 */
static __mlu_func__ __mlu_builtin__ void __bang_conv(float* dst,
                                                     bfloat16_t* src,
                                                     bfloat16_t* kernel,
                                                     int channel_input,
                                                     int height,
                                                     int width,
                                                     int kernel_height,
                                                     int kernel_width,
                                                     int stride_width,
                                                     int stride_height,
                                                     int channel_output,
                                                     int indilation_width,
                                                     int indilation_height,
                                                     int outdilation_width,
                                                     int outdilation_height);

static __mlu_func__ __mlu_builtin__ void __bang_conv_sparse(float* dst,
                                                            float* src,
                                                            float* kernel,
                                                            int channel_input,
                                                            int height,
                                                            int width,
                                                            int kernel_height,
                                                            int kernel_width,
                                                            int stride_width,
                                                            int stride_height,
                                                            int channel_output);

static __mlu_func__ __mlu_builtin__ void __bang_conv_sparse(float* dst,
                                                            half* src,
                                                            half* kernel,
                                                            int channel_input,
                                                            int height,
                                                            int width,
                                                            int kernel_height,
                                                            int kernel_width,
                                                            int stride_width,
                                                            int stride_height,
                                                            int channel_output);

static __mlu_func__ __mlu_builtin__ void __bang_conv_sparse(float* dst,
                                                            int8* src,
                                                            int8* kernel,
                                                            int channel_input,
                                                            int height,
                                                            int width,
                                                            int kernel_height,
                                                            int kernel_width,
                                                            int stride_width,
                                                            int stride_height,
                                                            int channel_output,
                                                            int fix_position);

static __mlu_func__ __mlu_builtin__ void __bang_conv_sparse(float* dst,
                                                            int8* src,
                                                            int16* kernel,
                                                            int channel_input,
                                                            int height,
                                                            int width,
                                                            int kernel_height,
                                                            int kernel_width,
                                                            int stride_width,
                                                            int stride_height,
                                                            int channel_output,
                                                            int fix_position);

static __mlu_func__ __mlu_builtin__ void __bang_conv_sparse(float* dst,
                                                            int16* src,
                                                            int8* kernel,
                                                            int channel_input,
                                                            int height,
                                                            int width,
                                                            int kernel_height,
                                                            int kernel_width,
                                                            int stride_width,
                                                            int stride_height,
                                                            int channel_output,
                                                            int fix_position);

static __mlu_func__ __mlu_builtin__ void __bang_conv_sparse(float* dst,
                                                            int16* src,
                                                            int16* kernel,
                                                            int channel_input,
                                                            int height,
                                                            int width,
                                                            int kernel_height,
                                                            int kernel_width,
                                                            int stride_width,
                                                            int stride_height,
                                                            int channel_output,
                                                            int fix_position);

static __mlu_func__ __mlu_builtin__ void __bang_conv_sparse(half* dst,
                                                            int8* src,
                                                            int8* kernel,
                                                            int channel_input,
                                                            int height,
                                                            int width,
                                                            int kernel_height,
                                                            int kernel_width,
                                                            int stride_width,
                                                            int stride_height,
                                                            int channel_output,
                                                            int fix_position);

static __mlu_func__ __mlu_builtin__ void __bang_conv_sparse(half* dst,
                                                            int8* src,
                                                            int16* kernel,
                                                            int channel_input,
                                                            int height,
                                                            int width,
                                                            int kernel_height,
                                                            int kernel_width,
                                                            int stride_width,
                                                            int stride_height,
                                                            int channel_output,
                                                            int fix_position);

static __mlu_func__ __mlu_builtin__ void __bang_conv_sparse(half* dst,
                                                            int16* src,
                                                            int8* kernel,
                                                            int channel_input,
                                                            int height,
                                                            int width,
                                                            int kernel_height,
                                                            int kernel_width,
                                                            int stride_width,
                                                            int stride_height,
                                                            int channel_output,
                                                            int fix_position);

static __mlu_func__ __mlu_builtin__ void __bang_conv_sparse(half* dst,
                                                            int16* src,
                                                            int16* kernel,
                                                            int channel_input,
                                                            int height,
                                                            int width,
                                                            int kernel_height,
                                                            int kernel_width,
                                                            int stride_width,
                                                            int stride_height,
                                                            int channel_output,
                                                            int fix_position);

static __mlu_func__ __mlu_builtin__ void __bang_conv_sparse(int16* dst,
                                                            int8* src,
                                                            int8* kernel,
                                                            int channel_input,
                                                            int height,
                                                            int width,
                                                            int kernel_height,
                                                            int kernel_width,
                                                            int stride_width,
                                                            int stride_height,
                                                            int channel_output,
                                                            int fix_position);

static __mlu_func__ __mlu_builtin__ void __bang_conv_sparse(int16* dst,
                                                            int16* src,
                                                            int8* kernel,
                                                            int channel_input,
                                                            int height,
                                                            int width,
                                                            int kernel_height,
                                                            int kernel_width,
                                                            int stride_width,
                                                            int stride_height,
                                                            int channel_output,
                                                            int fix_position);

static __mlu_func__ __mlu_builtin__ void __bang_conv_sparse(int16* dst,
                                                            int16* src,
                                                            int16* kernel,
                                                            int channel_input,
                                                            int height,
                                                            int width,
                                                            int kernel_height,
                                                            int kernel_width,
                                                            int stride_width,
                                                            int stride_height,
                                                            int channel_output,
                                                            int fix_position);

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_union(half* dst,
                                                                     half* src,
                                                                     int input_channel,
                                                                     int src_height,
                                                                     int src_width,
                                                                     int output_channel);

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_union(float* dst,
                                                                     float* src,
                                                                     int input_channel,
                                                                     int src_height,
                                                                     int src_width,
                                                                     int output_channel);

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_union(int8* dst,
                                                                     int8* src,
                                                                     int input_channel,
                                                                     int src_height,
                                                                     int src_width,
                                                                     int output_channel);

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_union(int16* dst,
                                                                     int16* src,
                                                                     int input_channel,
                                                                     int src_height,
                                                                     int src_width,
                                                                     int output_channel);

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_union(int* dst,
                                                                     int* src,
                                                                     int input_channel,
                                                                     int src_height,
                                                                     int src_width,
                                                                     int output_channel);

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_union(bfloat16_t* dst,
                                                                     bfloat16_t* src,
                                                                     int input_channel,
                                                                     int src_height,
                                                                     int src_width,
                                                                     int output_channel);

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_index(half* dst,
                                                                     half* src,
                                                                     int input_channel,
                                                                     int src_height,
                                                                     int src_width,
                                                                     int output_channel);

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_index(float* dst,
                                                                     float* src,
                                                                     int input_channel,
                                                                     int src_height,
                                                                     int src_width,
                                                                     int output_channel);

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_index(int8* dst,
                                                                     int8* src,
                                                                     int input_channel,
                                                                     int src_height,
                                                                     int src_width,
                                                                     int output_channel);

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_index(int16* dst,
                                                                     int16* src,
                                                                     int input_channel,
                                                                     int src_height,
                                                                     int src_width,
                                                                     int output_channel);

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_index(int* dst,
                                                                     int* src,
                                                                     int input_channel,
                                                                     int src_height,
                                                                     int src_width,
                                                                     int output_channel);

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_index(bfloat16_t* dst,
                                                                     bfloat16_t* src,
                                                                     int input_channel,
                                                                     int src_height,
                                                                     int src_width,
                                                                     int output_channel);

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_union_index(half* dst,
                                                                           half* src,
                                                                           half* index,
                                                                           int input_channel,
                                                                           int src_height,
                                                                           int src_width,
                                                                           int output_channel);

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_union_index(float* dst,
                                                                           float* src,
                                                                           float* index,
                                                                           int input_channel,
                                                                           int src_height,
                                                                           int src_width,
                                                                           int output_channel);

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_union_index(int8* dst,
                                                                           int8* src,
                                                                           int8* index,
                                                                           int input_channel,
                                                                           int src_height,
                                                                           int src_width,
                                                                           int output_channel);

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_union_index(int16* dst,
                                                                           int16* src,
                                                                           int16* index,
                                                                           int input_channel,
                                                                           int src_height,
                                                                           int src_width,
                                                                           int output_channel);

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_union_index(int* dst,
                                                                           int* src,
                                                                           int* index,
                                                                           int input_channel,
                                                                           int src_height,
                                                                           int src_width,
                                                                           int output_channel);

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_union_index(bfloat16_t* dst,
                                                                           bfloat16_t* src,
                                                                           bfloat16_t* index,
                                                                           int input_channel,
                                                                           int src_height,
                                                                           int src_width,
                                                                           int output_channel);

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_sparse_index(half* dst,
                                                                            half* src,
                                                                            half* index,
                                                                            int input_channel,
                                                                            int src_height,
                                                                            int src_width,
                                                                            int output_channel);

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_sparse_index(float* dst,
                                                                            float* src,
                                                                            float* index,
                                                                            int input_channel,
                                                                            int src_height,
                                                                            int src_width,
                                                                            int output_channel);

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_sparse_index(int8* dst,
                                                                            int8* src,
                                                                            int8* index,
                                                                            int input_channel,
                                                                            int src_height,
                                                                            int src_width,
                                                                            int output_channel);

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_sparse_index(int16* dst,
                                                                            int16* src,
                                                                            int16* index,
                                                                            int input_channel,
                                                                            int src_height,
                                                                            int src_width,
                                                                            int output_channel);

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_sparse_index(int* dst,
                                                                            int* src,
                                                                            int* index,
                                                                            int input_channel,
                                                                            int src_height,
                                                                            int src_width,
                                                                            int output_channel);

static __mlu_func__ __mlu_builtin__ void __bang_ssparse_filter_sparse_index(bfloat16_t* dst,
                                                                            bfloat16_t* src,
                                                                            bfloat16_t* index,
                                                                            int input_channel,
                                                                            int src_height,
                                                                            int src_width,
                                                                            int output_channel);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_mlp(half* dst,
                                                    int8* src,
                                                    int8* weight,
                                                    int height,
                                                    int width,
                                                    int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_mlp(half* dst,
                                                    int16* src,
                                                    int8* weight,
                                                    int height,
                                                    int width,
                                                    int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_mlp(half* dst,
                                                    int16* src,
                                                    int16* weight,
                                                    int height,
                                                    int width,
                                                    int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_mlp(float* dst,
                                                    int8* src,
                                                    int8* weight,
                                                    int height,
                                                    int width,
                                                    int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_mlp(float* dst,
                                                    int16* src,
                                                    int8* weight,
                                                    int height,
                                                    int width,
                                                    int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_mlp(float* dst,
                                                    int16* src,
                                                    int16* weight,
                                                    int height,
                                                    int width,
                                                    int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_mlp(int16* dst,
                                                    int8* src,
                                                    int8* weight,
                                                    int height,
                                                    int width,
                                                    int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_mlp(int16* dst,
                                                    int16* src,
                                                    int8* weight,
                                                    int height,
                                                    int width,
                                                    int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_mlp(int16* dst,
                                                    int16* src,
                                                    int16* weight,
                                                    int height,
                                                    int width,
                                                    int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_mlp(half* dst,
                                                    int8* src,
                                                    half* bias,
                                                    int8* weight,
                                                    int height,
                                                    int width,
                                                    int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_mlp(half* dst,
                                                    int16* src,
                                                    half* bias,
                                                    int8* weight,
                                                    int height,
                                                    int width,
                                                    int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_mlp(half* dst,
                                                    int16* src,
                                                    half* bias,
                                                    int16* weight,
                                                    int height,
                                                    int width,
                                                    int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_mlp(float* dst,
                                                    int8* src,
                                                    float* bias,
                                                    int8* weight,
                                                    int height,
                                                    int width,
                                                    int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_mlp(float* dst,
                                                    int16* src,
                                                    float* bias,
                                                    int8* weight,
                                                    int height,
                                                    int width,
                                                    int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_mlp(float* dst,
                                                    int16* src,
                                                    float* bias,
                                                    int16* weight,
                                                    int height,
                                                    int width,
                                                    int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_mlp(int16* dst,
                                                    int8* src,
                                                    int16* bias,
                                                    int8* weight,
                                                    int height,
                                                    int width,
                                                    int fix_position);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ void __bang_mlp(int16* dst,
                                                    int16* src,
                                                    int16* bias,
                                                    int8* weight,
                                                    int height,
                                                    int width,
                                                    int fix_position);

//Group:Stream Operation Functions
/**
 * @brief Applies multilayer perception operation.
 *
 *
 * @details
 *
 * For version with ``<bias>``: \f$<dst> = <src> \times <weight> + <bias>\f$.
 *
 * For version without ``<bias>``: \f$<dst> = <src> \times <weight>\f$.
 *
 * @param[out] dst The address of destination matrix.
 * @param[in] src The address of source matrix.
 * @param[in] bias The address of bias matrix.
 * @param[in] weight The address of weight matrix.
 * @param[in] height The height of <weight>.
 * @param[in] width The width of <weight>.
 * @param[in] fix_position Scale factor. \f$<src> \div 2^{<fix\_position>}\f$.
 * @return ``void``.
 * @remark
 * - ``half`` is the only supported data type on ``(m)tp_1xx``;
 * - ``<dst>``, ``<src>`` and ``<bias>`` must point to ``__nram__`` space;
 * - ``<weight>`` must point to ``__wram__`` space;
 * - ``<fix_position>`` must be an immediate integer on ``(m)tp_1xx``;
 * - ``<fix_position>`` must be in the range ``[-63, 63]`` on ``(m)tp_1xx``, and in the range ``[-127, 127]`` on ``(m)tp_2xx`` or higher;
 * - The address of ``<dst>``, ``<src>`` and ``<bias>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - The address of ``<weight>`` must be 32-byte aligned;
 * - ``<weight>`` needs to be reshaped, through interface ``cnrtFilterReshape`` in the host, or ::__bang_reshape_filter in the device on ``(m)tp_2xx`` and higher.
 * - ``<height>`` must be divisible by 64 on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<height> * sizeof(typeof<dst>)`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - ``<width> * sizeof(typeof<src>)`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``;
 * - Version without bias is not supported on ``(m)tp_1xx``, and is supported on ``(m)tp_2xx`` and higher;
 * - ::__bang_mlp of int input type version is not recommended, because it is implemented by combination, with lower performance. ``__clang_bang_extra.h`` should be included when using this version;
 * - On ``(m)tp_3xx``, if ``--bang-wram-align64`` option is used, the byte size of ``<weight>`` must be 64-byte aligned; otherwise, the byte size of ``<weight>`` must be 32-byte aligned;
 * - On ``(m)tp_3xx``, ``width`` dimension space of ``<weight>`` must satisfy the following alignment constraints:
 *
 *    - If ``sizeof(typeof<src>) / sizeof(typeof<weight>) == 4``, ``width * sizeof(typeof<weight>)`` must be 16-byte aligned;
 *    - If ``sizeof(typeof<src>) / sizeof(typeof<weight>) == 2``, ``width * sizeof(typeof<weight>)`` must be 32-byte aligned;
 *    - If ``sizeof(typeof<src>) / sizeof(typeof<weight>)`` doesn't satisfy the above mentioned constraints, ``width * sizeof(typeof<weight>)`` must be 64-byte aligned;
 *
 * - ``height`` dimension space of ``<weight>`` must satisfy that ``height`` is divisible by 64 on ``(m)tp_3xx``;
 * - On ``(m)tp_3xx``, if ``<kernel>`` does not follow the above alignment rules, the values of the non-aligned part will be random numbers, which may cause calculation errors;
 * - ``<width>`` and ``<height>`` must be greater than 0;
 * - ``<dst>`` and ``<src>`` can not be homologous operands;
 * - ``<dst>`` and ``<bias>`` can not be homologous operands;
 * @par
 * \rst
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_binary_operation_functions` for more details.
 * \endrst
 *
 * @par Compatibility between Various Architectures
 * @par
 * \rst
 *
 * .. table::  Data Types Supported on ``(m)tp_1xx``
 *    :widths: 25 20 20 20
 *
 *    +--------------+--------------+----------------+----------------+
 *    | Dst Type     | Src Type     |  Bias Type     |  Weight Type   |
 *    +==============+==============+================+================+
 *    | half         | half         |  half          |  half          |
 *    +--------------+--------------+----------------+----------------+
 *    | half         | int8         |  half          |  int8          |
 *    +--------------+--------------+----------------+----------------+
 *
 * \endrst
 *
 * @par
 * \rst
 *
 * .. table::  Data Types Supported on ``(m)tp_2xx``
 *    :widths: 25 20 20 20
 *    :class: longtable
 *
 *    +--------------+--------------+----------------+----------------+
 *    | Dst Type     | Src Type     |  Bias Type     |  Weight Type   |
 *    +==============+==============+================+================+
 *    | half         | int16        |  half          |  int16         |
 *    +--------------+--------------+----------------+----------------+
 *    | half         | int8         |  half          |  int8          |
 *    +--------------+--------------+----------------+----------------+
 *    | half         | int16        |  half          |  int8          |
 *    +--------------+--------------+----------------+----------------+
 *    | float        | int16        |  float         |  int16         |
 *    +--------------+--------------+----------------+----------------+
 *    | float        | int8         |  float         |  int8          |
 *    +--------------+--------------+----------------+----------------+
 *    | float        | int16        |  float         |  int8          |
 *    +--------------+--------------+----------------+----------------+
 *    | float        | int          |  float         |  int16         |
 *    +--------------+--------------+----------------+----------------+
 *    | int16        | int16        |  int16         |  int16         |
 *    +--------------+--------------+----------------+----------------+
 *    | int16        | int8         |  int16         |  int8          |
 *    +--------------+--------------+----------------+----------------+
 *    | int16        | int16        |  int16         |  int8          |
 *    +--------------+--------------+----------------+----------------+
 *    | half         | int8         |  none          |  int8          |
 *    +--------------+--------------+----------------+----------------+
 *    | half         | int16        |  none          |  int8          |
 *    +--------------+--------------+----------------+----------------+
 *    | half         | int16        |  none          |  int16         |
 *    +--------------+--------------+----------------+----------------+
 *    | float        | int8         |  none          |  int8          |
 *    +--------------+--------------+----------------+----------------+
 *    | float        | int16        |  none          |  int8          |
 *    +--------------+--------------+----------------+----------------+
 *    | float        | int16        |  none          |  int16         |
 *    +--------------+--------------+----------------+----------------+
 *    | int16        | int8         |  none          |  int8          |
 *    +--------------+--------------+----------------+----------------+
 *    | int16        | int16        |  none          |  int8          |
 *    +--------------+--------------+----------------+----------------+
 *    | int16        | int16        |  none          |  int16         |
 *    +--------------+--------------+----------------+----------------+
 *
 * \endrst
 *
 * @par
 * \rst
 *
 * .. table::  mlp Data Types Supported on ``(m)tp_3xx``
 *    :widths: 25 20 20 20
 *    :class: longtable
 *
 *    +--------------+--------------+----------------+----------------+
 *    | Dst Type     | Src Type     |  Bias Type     |  Weight Type   |
 *    +==============+==============+================+================+
 *    | half         | int16        |  half          |  int16         |
 *    +--------------+--------------+----------------+----------------+
 *    | half         | int8         |  half          |  int8          |
 *    +--------------+--------------+----------------+----------------+
 *    | half         | int16        |  half          |  int8          |
 *    +--------------+--------------+----------------+----------------+
 *    | float        | int16        |  float         |  int16         |
 *    +--------------+--------------+----------------+----------------+
 *    | float        | int8         |  float         |  int8          |
 *    +--------------+--------------+----------------+----------------+
 *    | float        | int16        |  float         |  int8          |
 *    +--------------+--------------+----------------+----------------+
 *    | float        | int          |  float         |  int16         |
 *    +--------------+--------------+----------------+----------------+
 *    | half         | int8         |  none          |  int8          |
 *    +--------------+--------------+----------------+----------------+
 *    | half         | int16        |  none          |  int8          |
 *    +--------------+--------------+----------------+----------------+
 *    | half         | int16        |  none          |  int16         |
 *    +--------------+--------------+----------------+----------------+
 *    | float        | int8         |  none          |  int8          |
 *    +--------------+--------------+----------------+----------------+
 *    | float        | int16        |  none          |  int8          |
 *    +--------------+--------------+----------------+----------------+
 *    | float        | int16        |  none          |  int16         |
 *    +--------------+--------------+----------------+----------------+
 *
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *     #include <bang.h>
 *
 *     #define HEIGHT 64
 *     #define WIDTH 64
 *     #define POS 0
 *
 *     __mlu_entry__ void MlpKernel(half* out_data, int16_t* in_data,
 *                                  int16_t* filter_data, half* bias_data,
 *                                  int height, int width, int pos) {
 *      __nram__ half nram_out_data[HEIGHT];
 *      __nram__ half nram_bias_data[HEIGHT];
 *      __nram__ int16_t nram_in_data[WIDTH];
 *      __wram__ int16_t wram_filter[HEIGHT * WIDTH];
 *      __memcpy(nram_in_data, in_data, WIDTH * sizeof(int16_t), GDRAM2NRAM);
 *      __memcpy(nram_bias_data, bias_data, HEIGHT * sizeof(half), GDRAM2NRAM);
 *      __memcpy(wram_filter, filter_data, HEIGHT * WIDTH * sizeof(int16_t),
 *               GDRAM2WRAM);
 *      __bang_mlp(nram_out_data, nram_in_data, nram_bias_data, wram_filter,
 *                 HEIGHT, WIDTH, POS);
 *      __memcpy(out_data, nram_out_data, HEIGHT * sizeof(half), NRAM2GDRAM);
 *    }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_mlp(int16* dst,
                                                    int16* src,
                                                    int16* bias,
                                                    int16* weight,
                                                    int height,
                                                    int width,
                                                    int fix_position);

static __mlu_func__ __mlu_builtin__ void __bang_atomic_add(unsigned short* dst,
                                                           unsigned short* src1,
                                                           unsigned short src2,
                                                           int size = 1);
//Group:Scalar Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_add(short* dst,
                                                           short* src1,
                                                           short src2,
                                                           int size = 1);
static __mlu_func__ __mlu_builtin__ void __bang_atomic_add(unsigned int* dst,
                                                           unsigned int* src1,
                                                           unsigned int src2,
                                                           int size = 1);
//Group:Scalar Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_add(int* dst,
                                                           int* src1,
                                                           int src2,
                                                           int size = 1);
//Group:Scalar Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_add(half* dst,
                                                           half* src1,
                                                           half src2,
                                                           int size = 1);

static __mlu_func__ __mlu_builtin__ void __bang_atomic_add(bfloat16_t* dst,
                                                           bfloat16_t* src1,
                                                           bfloat16_t src2,
                                                           int size = 1);

//Group:Scalar Atomic Functions
/**
 * @brief Reads ``<*src1>`` value, adds ``<src2>`` to ``<*src1>``, and stores the original value of ``<*src1>`` in ``<dst>``. These three operations are performed in one atomic transaction. That is: ``<*dst>`` = ``<*src1>``; ``<*src1>`` = ``<*src1>`` + ``<src2>``. All steps are inseparable.
 *
 * @details
 *
 * @param[out] dst The address of destination operand.
 * @param[in] src1 The address of first operand.
 * @param[in] src2 The second operand.
 * @param[in] size The element count.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<src1>`` must point to ``__mlu_device__`` address space;
 * - ``<dst>`` must point to ``__nram__`` address space;
 * - This interface is supported on ``mtp_2xx`` and higher;
 * - The address of ``<src1>`` must be ``sizeof(type)`` aligned;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_binary_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *    #include <bang.h>
 *
 *    __mlu_entry__ void kernel(short* src1, short src2) {
 *      __nram__ short v[64];
 *      __bang_atomic_add(v, src1, src2, 64);
 *    }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_atomic_add(float* dst,
                                                           float* src1,
                                                           float src2,
                                                           int size = 1);

//Group:Scalar Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_inc(unsigned short* dst,
                                                           unsigned short* src1,
                                                           unsigned short src2,
                                                           int size = 1);
//Group:Scalar Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_inc(short* dst,
                                                           short* src1,
                                                           short src2,
                                                           int size = 1);
//Group:Scalar Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_inc(unsigned int* dst,
                                                           unsigned int* src1,
                                                           unsigned int src2,
                                                           int size = 1);

//Group:Scalar Atomic Functions
/**
 * @brief Compares ``<*src1>`` and ``<src2>``. If ``<*src1>`` is smaller than ``<src2>``, increases ``<*src1>`` by 1; otherwise, sets ``<*src1>`` to 0. Stores the original value of ``<*src1>`` in ``<dst>``. That is: ``<*dst>`` = ``<*src1>``; ``<*src1>`` = (``<*src1>`` >= ``<src2>``) ? 0 : (``<*src1>`` + 1). All steps are inseparable.
 *
 * @details
 *
 * @param[out] dst The address of destination operand.
 * @param[in] src1 The address of first operand.
 * @param[in] src2 The second operand.
 * @param[in] size The element count.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<dst>`` must point to ``__nram__`` address space;
 * - ``<src1>`` must point to ``__mlu_device__`` address space;
 * - This interface is supported on ``mtp_2xx`` and higher;
 * - The address of ``<src1>`` must be ``sizeof(type)`` aligned.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_atomic_inc(int* dst,
                                                           int* src1,
                                                           int src2,
                                                           int size = 1);

//Group:Scalar Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_dec(unsigned short* dst,
                                                           unsigned short* src1,
                                                           unsigned short src2,
                                                           int size = 1);
//Group:Scalar Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_dec(short* dst,
                                                           short* src1,
                                                           short src2,
                                                           int size = 1);
//Group:Scalar Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_dec(unsigned int* dst,
                                                           unsigned int* src1,
                                                           unsigned int src2,
                                                           int size = 1);

//Group:Scalar Atomic Functions
/**
 * @brief Compares ``<*src1>`` and ``<src2>``. If ``<*src1>`` is greater than ``<src2>``, or the value of ``<*src1>`` is 0, stores the value ``<src2>`` in ``<src1>``; otherwise, subtract ``<*src1>`` by 1. Stores the original value of ``<*src1>`` in ``<dst>``. That is: ``<*dst>`` = ``<*src1>``; ``<*src1>`` = (``<*src1>`` == 0 || ``<*src1>`` > ``<src2>``) ? ``<src2>`` : (``<*src1>`` - 1). All steps are inseparable.
 *
 * @param[out] dst The address of destination operand.
 * @param[in] src1 The address of first operand.
 * @param[in] src2 The second operand.
 * @param[in] size The element count.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<dst>`` must point to ``__nram__`` address space;
 * - ``<src1>`` must point to ``__mlu_device__`` address space;
 * - The address of ``<src1>`` must be ``sizeof(type)`` aligned;
 * - This interface is supported on ``mtp_2xx`` and higher.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_atomic_dec(int* dst,
                                                           int* src1,
                                                           int src2,
                                                           int size = 1);

//Group:Scalar Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_max(unsigned short* dst,
                                                           unsigned short* src1,
                                                           unsigned short src2,
                                                           int size = 1);
//Group:Scalar Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_max(short* dst,
                                                           short* src1,
                                                           short src2,
                                                           int size = 1);
//Group:Scalar Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_max(unsigned int* dst,
                                                           unsigned int* src1,
                                                           unsigned int src2,
                                                           int size = 1);
//Group:Scalar Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_max(int* dst,
                                                           int* src1,
                                                           int src2,
                                                           int size = 1);
//Group:Scalar Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_max(half* dst,
                                                           half* src1,
                                                           half src2,
                                                           int size = 1);

static __mlu_func__ __mlu_builtin__ void __bang_atomic_max(bfloat16_t* dst,
                                                           bfloat16_t* src1,
                                                           bfloat16_t src2,
                                                           int size = 1);

//Group:Scalar Atomic Functions
/**
 * @brief Stores the larger value of ``<*src1>`` and ``<src2>`` in ``<src1>``. Stores the original value of ``<*src1>`` in ``<dst>``.  That is: ``<*dst>`` = ``<*src1>``; ``<*src1>`` = (``<*src1>`` > ``<src2>``) ? ``<*src1>`` : ``<src2>``. All steps are inseparable.
 *
 * @details
 *
 * @param[out] dst The address of destination operand.
 * @param[in] src1 The address of first operand.
 * @param[in] src2 The second operand.
 * @param[in] size The element count.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<dst>`` must point to ``__nram__`` address space;
 * - ``<src1>`` must point to ``__mlu_device__`` address space;
 * - The address of ``<src1>`` must be ``sizeof(type)`` aligned;
 * - This interface is supported on ``mtp_2xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_operation_functions_with_elementwise` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_atomic_max(float* dst,
                                                           float* src1,
                                                           float src2,
                                                           int size = 1);

//Group:Scalar Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_min(unsigned short* dst,
                                                           unsigned short* src1,
                                                           unsigned short src2,
                                                           int size = 1);
//Group:Scalar Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_min(short* dst,
                                                           short* src1,
                                                           short src2,
                                                           int size = 1);
//Group:Scalar Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_min(unsigned int* dst,
                                                           unsigned int* src1,
                                                           unsigned int src2,
                                                           int size = 1);
//Group:Scalar Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_min(int* dst,
                                                           int* src1,
                                                           int src2,
                                                           int size = 1);
//Group:Scalar Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_min(half* dst,
                                                           half* src1,
                                                           half src2,
                                                           int size = 1);

static __mlu_func__ __mlu_builtin__ void __bang_atomic_min(bfloat16_t* dst,
                                                           bfloat16_t* src1,
                                                           bfloat16_t src2,
                                                           int size = 1);

//Group:Scalar Atomic Functions
/**
 * @brief Stores the smaller value of ``<*src1>`` and ``<src2>`` in ``<src1>``. Stores the original value of ``<*src1>`` in ``<dst>``. That is: ``<*dst>`` = ``<*src1>``; ``<*src1>`` = (``<*src1>`` < ``<src2>``) ? ``<*src1>`` : ``<src2>``. All steps are inseparable.
 *
 * @details
 *
 * @param[out] dst The address of destination operand.
 * @param[in] src1 The address of first operand.
 * @param[in] src2 The second operand.
 * @param[in] size The element count.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<dst>`` must point to ``__nram__`` address space;
 * - ``<src1>`` must point to ``__mlu_device__`` address space;
 * - The address of ``<src1>`` must be ``sizeof(type)`` aligned;
 * - This interface is supported on ``mtp_2xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_operation_functions_with_elementwise` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_atomic_min(float* dst,
                                                           float* src1,
                                                           float src2,
                                                           int size = 1);

static __mlu_func__ __mlu_builtin__ void __bang_atomic_and(unsigned short* dst,
                                                           unsigned short* src1,
                                                           unsigned short src2,
                                                           int size = 1);
//Group:Scalar Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_and(short* dst,
                                                           short* src1,
                                                           short src2,
                                                           int size = 1);
static __mlu_func__ __mlu_builtin__ void __bang_atomic_and(unsigned int* dst,
                                                           unsigned int* src1,
                                                           unsigned int src2,
                                                           int size = 1);

//Group:Scalar Atomic Functions
/**
 * @brief Applies bitwise AND operation to ``<*src1>`` and ``<src2>``, stores the result in ``<src1>``, and stores the original value of ``<*src1>`` in ``<dst>``. That is: ``<*dst>`` = ``<*src1>``; ``<*src1>`` = ``<*src1>`` & ``<src2>``. All steps are inseparable.
 *
 * @details
 *
 * @param[out] dst The address of destination operand.
 * @param[in] src1 The address of first operand.
 * @param[in] src2 The second operand.
 * @param[in] size The element count.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<dst>`` must point to ``__nram__`` address space;
 * - ``<src1>`` must point to ``__mlu_device__`` address space;
 * - The address of ``<src1>`` must be ``sizeof(type)`` aligned;
 * - This interface is supported on ``mtp_2xx`` and higher.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_atomic_and(int* dst,
                                                           int* src1,
                                                           int src2,
                                                           int size = 1);

static __mlu_func__ __mlu_builtin__ void __bang_atomic_or(unsigned short* dst,
                                                          unsigned short* src1,
                                                          unsigned short src2,
                                                          int size = 1);
//Group:Scalar Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_or(short* dst,
                                                          short* src1,
                                                          short src2,
                                                          int size = 1);
static __mlu_func__ __mlu_builtin__ void __bang_atomic_or(unsigned int* dst,
                                                          unsigned int* src1,
                                                          unsigned int src2,
                                                          int size = 1);

//Group:Scalar Atomic Functions
/**
 * @brief Applies bitwise OR operation to ``<*src1>`` and ``<src2>``, stores the result in ``<src1>``, and stores the original value of ``<*src1>`` in ``<dst>``. That is: ``<*dst>`` = ``<*src1>``; ``<*src1>`` = ``<*src1>`` | ``<src2>``. All steps are inseparable.
 *
 * @details
 *
 * @param[out] dst The address of destination operand.
 * @param[in] src1 The address of first operand.
 * @param[in] src2 The second operand.
 * @param[in] size The element count.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<dst>`` must point to ``__nram__`` address space;
 * - ``<src1>`` must point to ``__mlu_device__`` address space;
 * - The address of ``<src1>`` must be ``sizeof(type)`` aligned;
 * - This interface is supported on ``mtp_2xx`` and higher.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_atomic_or(int* dst,
                                                          int* src1,
                                                          int src2,
                                                          int size = 1);

static __mlu_func__ __mlu_builtin__ void __bang_atomic_xor(unsigned short* dst,
                                                           unsigned short* src1,
                                                           unsigned short src2,
                                                           int size = 1);
//Group:Scalar Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_xor(short* dst,
                                                           short* src1,
                                                           short src2,
                                                           int size = 1);
static __mlu_func__ __mlu_builtin__ void __bang_atomic_xor(unsigned int* dst,
                                                           unsigned int* src1,
                                                           unsigned int src2,
                                                           int size = 1);

//Group:Scalar Atomic Functions
/**
 * @brief Applies bitwise XOR operation to ``<*src1>`` and ``<src2>``, stores the result in ``<src1>``, and stores the original value of ``<*src1>`` in ``<dst>``. That is: ``<*dst>`` = ``<*src1>``; ``<*src1>`` = ``<*src1>`` ^ ``<src2>``. All steps are inseparable.
 *
 * @details
 *
 * @param[out] dst The address of destination operand.
 * @param[in] src1 The address of first operand.
 * @param[in] src2 The second operand.
 * @param[in] size The element count.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<dst>`` must point to ``__nram__`` address space;
 * - ``<src1>`` must point to ``__mlu_device__`` address space;
 * - The address of ``<src1>`` must be ``sizeof(type)`` aligned;
 * - This interface is supported on ``mtp_2xx`` and higher.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_atomic_xor(int* dst,
                                                           int* src1,
                                                           int src2,
                                                           int size = 1);

static __mlu_func__ __mlu_builtin__ void __bang_atomic_cas(unsigned short* dst,
                                                           unsigned short* src1,
                                                           unsigned short src2,
                                                           unsigned short src3);
//Group:Scalar Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_cas(short* dst,
                                                           short* src1,
                                                           short src2,
                                                           short src3);
static __mlu_func__ __mlu_builtin__ void __bang_atomic_cas(unsigned int* dst,
                                                           unsigned int* src1,
                                                           unsigned int src2,
                                                           unsigned int src3);
static __mlu_func__ __mlu_builtin__ void __bang_atomic_cas(float* dst,
                                                           float* src1,
                                                           float src2,
                                                           float src3);
static __mlu_func__ __mlu_builtin__ void __bang_atomic_cas(half* dst,
                                                           half* src1,
                                                           half src2,
                                                           half src3);
static __mlu_func__ __mlu_builtin__ void __bang_atomic_cas(bfloat16_t* dst,
                                                           bfloat16_t* src1,
                                                           bfloat16_t src2,
                                                           bfloat16_t src3);

//Group:Scalar Atomic Functions
/**
 * @brief Compares ``<*src1>`` and ``<src2>``, and swaps with ``<src3>``.
 *
 * @details If ``<src2>`` is equal to ``<*src1>``, stores ``<src3>`` in ``<src1>``. Stores the original value of ``<*src1>`` in ``<dst>``. That is: ``<*dst>`` = ``<*src1>``; ``<*src1>`` = (``<*src1>`` == ``<src2>``) ? ``<src3>`` : ``<*src1>``. All steps are inseparable.
 *
 * @param[out] dst The address of destination operand.
 * @param[in] src1 The address of first operand.
 * @param[in] src2 The second operand.
 * @param[in] src3 The third operand.
 * @return ``void``.
 * @remark
 * \rst
 * This interface only operates on one element;
 * - ``<dst>`` must point to ``__nram__`` address space;
 * - ``<src1>`` must point to ``__mlu_device__`` address space;
 * - The address of ``<src1>`` must be ``sizeof(type)`` aligned;
 * - This interface is supported on ``mtp_2xx`` and higher.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   __mlu_entry__ void kernel(short* src1, short src2, short src3) {
 *     __nram__ short v;
 *     __bang_atomic_cas(&v, src1, src2, src3);
 *   }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_atomic_cas(int* dst,
                                                           int* src1,
                                                           int src2,
                                                           int src3);

static __mlu_func__ __mlu_builtin__ void __bang_atomic_exch(unsigned short* dst,
                                                            unsigned short* src1,
                                                            unsigned short src2,
                                                            int size = 1);
//Group:Scalar Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_exch(short* dst,
                                                            short* src1,
                                                            short src2,
                                                            int size = 1);
static __mlu_func__ __mlu_builtin__ void __bang_atomic_exch(unsigned int* dst,
                                                            unsigned int* src1,
                                                            unsigned int src2,
                                                            int size = 1);
//Group:Scalar Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_exch(int* dst,
                                                            int* src1,
                                                            int src2,
                                                            int size = 1);
//Group:Scalar Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_exch(half* dst,
                                                            half* src1,
                                                            half src2,
                                                            int size = 1);
static __mlu_func__ __mlu_builtin__ void __bang_atomic_exch(bfloat16_t* dst,
                                                            bfloat16_t* src1,
                                                            bfloat16_t src2,
                                                            int size = 1);

//Group:Scalar Atomic Functions
/**
 * @brief Stores ``<*src1>`` in ``<dst>``. Stores ``<src2>`` in ``<src1>``. That is: ``<*dst>`` = ``<*src1>``; ``<*src1>`` = ``<src2>``. All steps are inseparable.
 *
 * @param[out] dst The address of destination operand.
 * @param[in] src1 The address of first operand.
 * @param[in] src2 The second operand.
 * @param[in] size The element count.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<dst>`` must point to ``__nram__`` address space;
 * - ``<src1>`` must point to ``__mlu_device__`` address space;
 * - The address of ``<src1>`` must be ``sizeof(type)`` aligned;
 * - This interface is supported on ``mtp_2xx`` and higher.
 * \endrst
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_atomic_exch(float* dst,
                                                            float* src1,
                                                            float src2,
                                                            int size = 1);

//Group:Scalar Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_add(short* dst,
                                                                  short src1,
                                                                  int size = 1);
//Group:Scalar Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_add(int* dst,
                                                                  int src1,
                                                                  int size = 1);
//Group:Scalar Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_add(half* dst,
                                                                  half src1,
                                                                  int size = 1);

static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_add(bfloat16_t* dst,
                                                                  bfloat16_t src1,
                                                                  int size = 1);

//Group:Scalar Atomic Reduce Functions
/**
 * @brief Reads ``<*dst>`` value, adds value ``<src1>`` to value ``<*dst>``. These operations are performed in one atomic transaction.
 *
 * @details
 *
 * @param[out] dst The address of destination operand.
 * @param[in] src1 The first operand.
 * @param[in] size The element count.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<dst>`` must point to ``__mlu_device__`` address space;
 * - This interface is supported on ``mtp_3xx`` and higher;
 * - The address of ``<dst>`` must be ``sizeof(type)`` aligned;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_binary_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *    #include <bang.h>
 *
 *    __mlu_entry__ void kernel(short* src1, short src2, int size) {
 *      __bang_atomic_reduce_add(src1, src2, size);
 *    }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_add(float* dst,
                                                                  float src1,
                                                                  int size = 1);

//Group:Scalar Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_inc(unsigned short* dst,
                                                                  unsigned short src1,
                                                                  int size = 1);
//Group:Scalar Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_inc(short* dst,
                                                                  short src1,
                                                                  int size = 1);
//Group:Scalar Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_inc(unsigned int* dst,
                                                                  unsigned int src1,
                                                                  int size = 1);

//Group:Scalar Atomic Reduce Functions
/**
 * @brief Compares ``<*dst>`` and ``<src1>``. If ``<*dst>`` is smaller than ``<src1>``, increases ``<*dst>`` by 1; otherwise, sets ``<*dst>`` to 0. That is: ``<*dst>`` = (``<*dst>`` >= ``<src1>``) ? 0 : (``<*dst>`` + 1).
 *
 * @details
 *
 * @param[out] dst The address of destination operand.
 * @param[in] src1 The first operand.
 * @param[in] size The element count.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<dst>`` must point to ``__mlu_device__`` address space;
 * - This interface is supported on ``mtp_3xx`` and higher;
 * - The address of ``<dst>`` must be ``sizeof(type)`` aligned.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_inc(int* dst,
                                                                  int src1,
                                                                  int size = 1);

//Group:Scalar Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_dec(unsigned short* dst,
                                                                  unsigned short src1,
                                                                  int size = 1);
//Group:Scalar Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_dec(short* dst,
                                                                  short src1,
                                                                  int size = 1);
//Group:Scalar Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_dec(unsigned int* dst,
                                                                  unsigned int src1,
                                                                  int size = 1);

//Group:Scalar Atomic Reduce Functions
/**
 * @brief Compares ``<*dst>`` and ``<src1>``. If ``<*dst>`` is greater than ``<src1>``, or the value of ``<*dst>`` is 0, stores the int value ``<src1>`` in ``<dst>``; otherwise, subtract ``<*dst>`` by 1. That is: ``<*dst>`` = (``<*dst>`` == 0 || ``<*dst>`` > ``<src1>``) ? ``<src1>`` : (``<*dst>`` - 1).
 *
 * @param[out] dst The address of destination operand.
 * @param[in] src1 The first operand.
 * @param[in] size The element count.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<dst>`` must point to ``__mlu_device__`` address space;
 * - The address of ``<dst>`` must be ``sizeof(type)`` aligned;
 * - This interface is supported on ``mtp_3xx`` and higher.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_dec(int* dst,
                                                                  int src1,
                                                                  int size = 1);

//Group:Scalar Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_max(unsigned short* dst,
                                                                  unsigned short src1,
                                                                  int size = 1);
//Group:Scalar Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_max(short* dst,
                                                                  short src1,
                                                                  int size = 1);
//Group:Scalar Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_max(unsigned int* dst,
                                                                  unsigned int src1,
                                                                  int size = 1);
//Group:Scalar Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_max(int* dst,
                                                                  int src1,
                                                                  int size = 1);
//Group:Scalar Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_max(half* dst,
                                                                  half src1,
                                                                  int size = 1);

static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_max(bfloat16_t* dst,
                                                                  bfloat16_t src1,
                                                                  int size = 1);

//Group:Scalar Atomic Reduce Functions
/**
 * @brief Takes the larger value from ``<*dst>`` and ``<src1>``, and stores it in ``<dst>``.  That is: ``<*dst>`` = (``<*dst>`` > ``<src1>``) ? ``<*dst>`` : ``<src1>``.
 *
 * @details
 *
 * @param[out] dst The address of destination operand.
 * @param[in] src1 The first operand.
 * @param[in] size The element count.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<dst>`` must point to ``__mlu_device__`` address space;
 * - The address of ``<dst>`` must be ``sizeof(type)`` aligned;
 * - This interface is supported on ``mtp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_operation_functions_with_elementwise` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_max(float* dst,
                                                                  float src1,
                                                                  int size = 1);

//Group:Scalar Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_min(unsigned short* dst,
                                                                  unsigned short src1,
                                                                  int size = 1);
//Group:Scalar Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_min(short* dst,
                                                                  short src1,
                                                                  int size = 1);
//Group:Scalar Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_min(unsigned int* dst,
                                                                  unsigned int src1,
                                                                  int size = 1);
//Group:Scalar Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_min(int* dst,
                                                                  int src1,
                                                                  int size = 1);
//Group:Scalar Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_min(half* dst,
                                                                  half src1,
                                                                  int size = 1);

static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_min(bfloat16_t* dst,
                                                                  bfloat16_t src1,
                                                                  int size = 1);

//Group:Scalar Atomic Reduce Functions
/**
 * @brief Stores the smaller value of ``<*dst>`` and ``<src1>`` in ``<dst>``. That is: ``<*dst>`` = (``<*dst>`` < ``<src1>``) ? ``<*dst>`` : ``<src1>``.
 *
 * @details
 *
 * @param[out] dst The address of destination operand.
 * @param[in] src1 The first operand.
 * @param[in] size The element count.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<dst>`` must point to ``__mlu_device__`` address space;
 * - The address of ``<dst>`` must be ``sizeof(type)`` aligned;
 * - This interface is supported on ``mtp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_operation_functions_with_elementwise` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_min(float* dst,
                                                                  float src1,
                                                                  int size = 1);

//Group:Scalar Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_and(short* dst,
                                                                  short src1,
                                                                  int size = 1);

//Group:Scalar Atomic Reduce Functions
/**
 * @brief Applies bitwise AND operation to ``<*dst>`` and ``<src1>``, and stores the result in ``<dst>``. That is: ``<*dst>`` = ``<*dst>`` & ``<src1>``.
 *
 * @details
 *
 * @param[out] dst The address of destination operand.
 * @param[in] src1 The first operand.
 * @param[in] size The element count.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<dst>`` must point to ``__mlu_device__`` address space;
 * - The address of ``<dst>`` must be ``sizeof(type)`` aligned;
 * - This interface is supported on ``mtp_3xx`` and higher.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_and(int* dst,
                                                                  int src1,
                                                                  int size = 1);

//Group:Scalar Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_or(short* dst,
                                                                 short src1,
                                                                 int size = 1);

//Group:Scalar Atomic Reduce Functions
/**
 * @brief Applies bitwise OR operation to ``<*dst>`` and ``<src1>``, and stores the result in ``<dst>``. That is: ``<*dst>`` = ``<*dst>`` | ``<src1>``.
 *
 * @details
 *
 * @param[out] dst The address of destination operand.
 * @param[in] src1 The address of first operand.
 * @param[in] size The element count.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<dst>`` must point to ``__mlu_device__`` address space;
 * - The address of ``<dst>`` must be ``sizeof(type)`` aligned;
 * - This interface is supported on ``mtp_3xx`` and higher.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_or(int* dst,
                                                                 int src1,
                                                                 int size = 1);

//Group:Scalar Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_xor(short* dst,
                                                                  short src1,
                                                                  int size = 1);

//Group:Scalar Atomic Reduce Functions
/**
 * @brief Applies bitwise XOR operation to ``<*dst>`` and ``<src1>``, and stores the result in ``<dst>``. That is: ``<*src1>`` = ``<*src1>`` ^ ``<src2>``.
 *
 * @details
 *
 * @param[out] dst The address of destination operand.
 * @param[in] src1 The second operand.
 * @param[in] size The element count.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<dst>`` must point to ``__mlu_device__`` address space;
 * - The address of ``<dst>`` must be ``sizeof(type)`` aligned;
 * - This interface is supported on ``mtp_3xx`` and higher.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_xor(int* dst,
                                                                  int src1,
                                                                  int size = 1);

//Group:Scalar Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_cas(short* dst,
                                                                  short src1,
                                                                  short src2);
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_cas(half* dst,
                                                                  half src1,
                                                                  half src2);
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_cas(float* dst,
                                                                  float src1,
                                                                  float src2);
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_cas(bfloat16_t* dst,
                                                                  bfloat16_t src1,
                                                                  bfloat16_t src2);
//Group:Scalar Atomic Reduce Functions
/**
 * @brief Compares ``<*dst>`` and ``<src1>``, and swaps with ``<src2>``.
 *
 * @details If ``<src1>`` is equal to ``<*dst>``, stores ``<src2>`` in ``<dst>``. That is: ``<*dst>`` = (``<*dst>`` == ``<src1>``) ? ``<src2>`` : ``<*dst>``.
 *
 * @param[out] dst The address of destination operand.
 * @param[in] src1 The first operand.
 * @param[in] src2 The second operand.
 * @return ``void``.
 * @remark
 * \rst
 * This interface only operates on one element;
 * - ``<dst>`` must point to ``__mlu_device__`` address space;
 * - The address of ``<dst>`` must be ``sizeof(type)`` aligned;
 * - This interface is supported on ``mtp_3xx`` and higher.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *   #include <bang.h>
 *
 *   __mlu_entry__ void kernel(int* dst, int src1, int src2) {
 *     __bang_atomic_reduce_cas(dst, src1, src2);
 *   }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_cas(int* dst,
                                                                  int src1,
                                                                  int src2);

//Group:Scalar Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_exch(short* dst,
                                                                   short src1,
                                                                   int size = 1);
//Group:Scalar Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_exch(int* dst,
                                                                   int src1,
                                                                   int size = 1);
//Group:Scalar Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_exch(half* dst,
                                                                   half src1,
                                                                   int size = 1);

static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_exch(bfloat16_t* dst,
                                                                   bfloat16_t src1,
                                                                   int size = 1);

//Group:Scalar Atomic Reduce Functions
/**
 * @brief Stores ``<src1>`` in ``<dst>``. That is: ``<*src1>`` = ``<src2>``.
 *
 * @param[out] dst The address of destination operand.
 * @param[in] src1 The first operand.
 * @param[in] size The element count.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<dst>`` must point to ``__mlu_device__`` address space;
 * - The address of ``<dst>`` must be ``sizeof(type)`` aligned;
 * - This interface is supported on ``mtp_3xx`` and higher.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_exch(float* dst,
                                                                   float src1,
                                                                   int size = 1);

//Group:Stream Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_add(unsigned short* dst,
                                                           unsigned short* src1,
                                                           unsigned short* src2,
                                                           int size);
//Group:Stream Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_add(short* dst,
                                                           short* src1,
                                                           short* src2,
                                                           int size);
static __mlu_func__ __mlu_builtin__ void __bang_atomic_add(unsigned int* dst,
                                                           unsigned int* src1,
                                                           unsigned int* src2,
                                                           int size);
//Group:Stream Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_add(int* dst,
                                                           int* src1,
                                                           int* src2,
                                                           int size);
//Group:Stream Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_add(half* dst,
                                                           half* src1,
                                                           half* src2,
                                                           int size);

static __mlu_func__ __mlu_builtin__ void __bang_atomic_add(bfloat16_t* dst,
                                                           bfloat16_t* src1,
                                                           bfloat16_t* src2,
                                                           int size);

//Group:Stream Atomic Functions
/**
 * @brief Copies ``<src1>`` to ``<dst>``, adds ``<src2>`` to ``<src1>`` element-wisely. That is: ``<dst>`` = ``<src1>``; ``<src1>`` = ``<src1>`` + ``<src2>``. All steps are inseparable.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src1 The address of first source vector.
 * @param[in] src2 The address of second source vector.
 * @param[in] size The elements number of source vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<dst>`` and ``<src2>`` must point to ``__nram__`` address space;
 * - ``<src1>`` must point to ``__mlu_device__`` address space;
 * - The address of ``<src1>`` must be ``sizeof(type)`` aligned;
 * - ``<dst>`` and ``<src2>`` can be homologous operands;
 * - This interface is supported on ``mtp_2xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_binary_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_atomic_add(float* dst,
                                                           float* src1,
                                                           float* src2,
                                                           int size);

//Group:Stream Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_inc(unsigned short* dst,
                                                           unsigned short* src1,
                                                           unsigned short* src2,
                                                           int size);
//Group:Stream Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_inc(short* dst,
                                                           short* src1,
                                                           short* src2,
                                                           int size);
//Group:Stream Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_inc(unsigned int* dst,
                                                           unsigned int* src1,
                                                           unsigned int* src2,
                                                           int size);

//Group:Stream Atomic Functions
/**
 * @brief Compares vector ``<src1>`` and ``<src2>`` elsement-wisely. If ``<src1>`` is smaller than ``<src2>``, increases ``<src1>`` by 1; otherwise, sets ``<src1>`` to 0. Stores the original value of ``<src1>`` in ``<dst>``. That is: ``<dst>`` = ``<src1>``; ``<src1>`` = (``<src1>`` >= ``<src2>``) ? 0 : (``<src1>`` + 1). All steps are inseparable.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src1 The address of first source vector.
 * @param[in] src2 The address of second source vector.
 * @param[in] size The elements number of source vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<dst>`` and ``<src2>`` must point to ``__nram__`` address space;
 * - ``<src1>`` must point to ``__mlu_device__`` address space;
 * - ``<dst>`` and ``<src2>`` can be homologous operands;
 * - The address of ``<src1>`` must be ``sizeof(type)`` aligned;
 * - This interface is supported on ``mtp_2xx`` and higher.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_atomic_inc(int* dst,
                                                           int* src1,
                                                           int* src2,
                                                           int size);

static __mlu_func__ __mlu_builtin__ void __bang_atomic_dec(unsigned short* dst,
                                                           unsigned short* src1,
                                                           unsigned short* src2,
                                                           int size);
//Group:Stream Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_dec(short* dst,
                                                           short* src1,
                                                           short* src2,
                                                           int size);
static __mlu_func__ __mlu_builtin__ void __bang_atomic_dec(unsigned int* dst,
                                                           unsigned int* src1,
                                                           unsigned int* src2,
                                                           int size);

//Group:Stream Atomic Functions
/**
 * @brief Compares vector ``<src1>`` and ``<src2>`` element-wiselyly. If ``<src1>`` is larger than ``<src2>``, or the value of ``<src1>`` is 0, stores the int value ``<src2>`` in ``<src1>``; otherwise, subtracts ``<src1>`` by 1. Stores the original value of ``<src1>`` in ``<dst>``. That is: ``<dst>`` = ``<src1>``; ``<src1>`` = (``<src1>`` == 0 || ``<src1>`` > ``<src2>``) ? ``<src2>`` : (``<src1>`` - 1). All steps are inseparable.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src1 The address of first source vector.
 * @param[in] src2 The address of second source vector.
 * @param[in] size The elements number of source vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<dst>`` and ``<src2>`` must point to ``__nram__`` address space;
 * - ``<src1>`` must point to ``__mlu_device__`` address space;
 * - ``<dst>`` and ``<src2>`` can be homologous operands;
 * - The address of ``<src1>`` must be ``sizeof(type)`` aligned;
 * - This interface is supported on ``mtp_2xx`` and higher.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_atomic_dec(int* dst,
                                                           int* src1,
                                                           int* src2,
                                                           int size);

//Group:Stream Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_max(unsigned short* dst,
                                                           unsigned short* src1,
                                                           unsigned short* src2,
                                                           int size);
//Group:Stream Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_max(short* dst,
                                                           short* src1,
                                                           short* src2,
                                                           int size);
//Group:Stream Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_max(unsigned int* dst,
                                                           unsigned int* src1,
                                                           unsigned int* src2,
                                                           int size);
//Group:Stream Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_max(int* dst,
                                                           int* src1,
                                                           int* src2,
                                                           int size);
//Group:Stream Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_max(half* dst,
                                                           half* src1,
                                                           half* src2,
                                                           int size);

static __mlu_func__ __mlu_builtin__ void __bang_atomic_max(bfloat16_t* dst,
                                                           bfloat16_t* src1,
                                                           bfloat16_t* src2,
                                                           int size);

//Group:Stream Atomic Functions
/**
 * @brief element-wiselyly stores the larger value of vector ``<src1>`` and ``<src2>`` in ``<src1>``. Stores the original value of ``<src1>`` in ``<dst>``. That is: ``<dst>`` = ``<src1>``; ``<src1>`` = (``<src1>`` > ``<src2>``) ? ``<src1>`` : ``<src2>``. All steps are inseparable.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src1 The address of first source vector.
 * @param[in] src2 The address of second source vector.
 * @param[in] size The elements number of source vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<dst>`` and ``<src2>`` must point to ``__nram__`` address space;
 * - ``<src1>`` must point to ``__mlu_device__`` address space;
 * - ``<dst>`` and ``<src2>`` can be homologous operands;
 * - The address of ``<src1>`` must be ``sizeof(type)`` aligned;
 * - This interface is supported on ``mtp_2xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_operation_functions_with_elementwise` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_atomic_max(float* dst,
                                                           float* src1,
                                                           float* src2,
                                                           int size);

//Group:Stream Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_min(unsigned short* dst,
                                                           unsigned short* src1,
                                                           unsigned short* src2,
                                                           int size);
//Group:Stream Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_min(short* dst,
                                                           short* src1,
                                                           short* src2,
                                                           int size);
//Group:Stream Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_min(unsigned int* dst,
                                                           unsigned int* src1,
                                                           unsigned int* src2,
                                                           int size);
//Group:Stream Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_min(int* dst,
                                                           int* src1,
                                                           int* src2,
                                                           int size);
//Group:Stream Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_min(half* dst,
                                                           half* src1,
                                                           half* src2,
                                                           int size);

static __mlu_func__ __mlu_builtin__ void __bang_atomic_min(bfloat16_t* dst,
                                                           bfloat16_t* src1,
                                                           bfloat16_t* src2,
                                                           int size);

//Group:Stream Atomic Functions
/**
 * @brief Takes the smaller value from two vector values ``<src1>`` and ``<src2>``, and stores it in ``<src1>``. Stores the original value of ``<src1>`` in ``<dst>``. That is: ``<dst>`` = ``<src1>``; ``<src1>`` = (``<src1>`` < ``<src2>``) ? ``<src1>`` : ``<src2>``. All steps are inseparable.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src1 The address of first source vector.
 * @param[in] src2 The address of second source vector.
 * @param[in] size The elements number of source vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<dst>`` and ``<src2>`` must point to ``__nram__`` address space;
 * - ``<src1>`` must point to ``__mlu_device__`` address space;
 * - ``<dst>`` and ``<src2>`` can be homologous operands;
 * - The address of ``<src1>`` must be ``sizeof(type)`` aligned;
 * - This interface is supported on ``mtp_2xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_operation_functions_with_elementwise` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_atomic_min(float* dst,
                                                           float* src1,
                                                           float* src2,
                                                           int size);

static __mlu_func__ __mlu_builtin__ void __bang_atomic_and(unsigned short* dst,
                                                           unsigned short* src1,
                                                           unsigned short* src2,
                                                           int size);
//Group:Stream Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_and(short* dst,
                                                           short* src1,
                                                           short* src2,
                                                           int size);
static __mlu_func__ __mlu_builtin__ void __bang_atomic_and(unsigned int* dst,
                                                           unsigned int* src1,
                                                           unsigned int* src2,
                                                           int size);

//Group:Stream Atomic Functions
/**
 * @brief Applies bitwise AND operation to the vector ``<src1>`` and ``<src2>``, stores the result in ``<src1>``, and stores the original value of ``<src1>`` in ``<dst>``. That is: ``<dst>`` = ``<src1>``; ``<src1>`` = ``<src1>`` & ``<src2>``. All steps are inseparable.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src1 The address of first source vector.
 * @param[in] src2 The address of second source vector.
 * @param[in] size The elements number of source vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<dst>`` and ``<src2>`` must point to ``__nram__`` address space;
 * - ``<src1>`` must point to ``__mlu_device__`` address space;
 * - ``<dst>`` and ``<src2>`` can be homologous operands;
 * - The address of ``<src1>`` must be ``sizeof(type)`` aligned;
 * - This interface is supported on ``mtp_2xx`` and higher.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_atomic_and(int* dst,
                                                           int* src1,
                                                           int* src2,
                                                           int size);

static __mlu_func__ __mlu_builtin__ void __bang_atomic_or(unsigned short* dst,
                                                          unsigned short* src1,
                                                          unsigned short* src2,
                                                          int size);
//Group:Stream Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_or(short* dst,
                                                          short* src1,
                                                          short* src2,
                                                          int size);
static __mlu_func__ __mlu_builtin__ void __bang_atomic_or(unsigned int* dst,
                                                          unsigned int* src1,
                                                          unsigned int* src2,
                                                          int size);

//Group:Stream Atomic Functions
/**
 * @brief Applies bitwise OR operation to vector ``<src1>`` and ``<src2>``, stores the result in ``<src1>``, and stores the original value of ``<src1>`` in ``<dst>``. That is: ``<dst>`` = ``<src1>``; ``<src1>`` = ``<src1>`` | ``<src2>``. All steps are inseparable.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src1 The address of first source vector.
 * @param[in] src2 The address of second source vector.
 * @param[in] size The elements number of source vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<dst>`` must point to ``__nram__`` address space;
 * - ``<src1>`` must point to ``__mlu_device__`` address space;
 * - ``<dst>`` and ``<src2>`` can be homologous operands;
 * - The address of ``<src1>`` must be ``sizeof(type)`` aligned;
 * - This interface is supported on ``mtp_2xx`` and higher.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_atomic_or(int* dst,
                                                          int* src1,
                                                          int* src2,
                                                          int size);

static __mlu_func__ __mlu_builtin__ void __bang_atomic_xor(unsigned short* dst,
                                                           unsigned short* src1,
                                                           unsigned short* src2,
                                                           int size);
//Group:Stream Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_xor(short* dst,
                                                           short* src1,
                                                           short* src2,
                                                           int size);
static __mlu_func__ __mlu_builtin__ void __bang_atomic_xor(unsigned int* dst,
                                                           unsigned int* src1,
                                                           unsigned int* src2,
                                                           int size);

//Group:Stream Atomic Functions
/**
 * @brief Applies bitwise XOR operation to vector ``<src1>`` and ``<src2>``, stores the result in ``<src1>``, and stores the original value of ``<src1>`` in ``<dst>``. That is: ``<dst>`` = ``<src1>``; ``<src1>`` = ``<src1>`` ^ ``<src2>``. All steps are inseparable.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src1 The address of first source vector.
 * @param[in] src2 The address of second source vector.
 * @param[in] size The elements number of source vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<dst>`` and ``<src2>`` must point to ``__nram__`` address space;
 * - ``<src1>`` must point to ``__mlu_device__`` address space;
 * - ``<dst>`` and ``<src2>`` can be homologous operands;
 * - The address of ``<src1>`` must be ``sizeof(type)`` aligned;
 * - This interface is supported on ``mtp_2xx`` and higher.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_atomic_xor(int* dst,
                                                           int* src1,
                                                           int* src2,
                                                           int size);

static __mlu_func__ __mlu_builtin__ void __bang_atomic_exch(unsigned short* dst,
                                                            unsigned short* src1,
                                                            unsigned short* src2,
                                                            int size);
//Group:Stream Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_exch(short* dst,
                                                            short* src1,
                                                            short* src2,
                                                            int size);
static __mlu_func__ __mlu_builtin__ void __bang_atomic_exch(unsigned int* dst,
                                                            unsigned int* src1,
                                                            unsigned int* src2,
                                                            int size);
//Group:Stream Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_exch(int* dst,
                                                            int* src1,
                                                            int* src2,
                                                            int size);
//Group:Stream Atomic Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_exch(half* dst,
                                                            half* src1,
                                                            half* src2,
                                                            int size);

static __mlu_func__ __mlu_builtin__ void __bang_atomic_exch(bfloat16_t* dst,
                                                            bfloat16_t* src1,
                                                            bfloat16_t* src2,
                                                            int size);

//Group:Stream Atomic Functions
/**
 * @brief Stores vector ``<src1>`` in ``<dst>``. Stores ``<src2>`` in ``<src1>``. That is: ``<dst>`` = ``<src1>``; ``<src1>`` = ``<src2>``. All steps are inseparable.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src1 The address of first source vector.
 * @param[in] src2 The address of second source vector.
 * @param[in] size The elements number of source vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<dst>`` and ``<src2>`` must point to ``__nram__`` address space;
 * - ``<src1>`` must point to ``__mlu_device__`` address space;
 * - ``<dst>`` and ``<src2>`` can be homologous operands;
 * - The address of ``<src1>`` must be ``sizeof(type)`` aligned;
 * - This interface is supported on ``mtp_2xx`` and higher.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_atomic_exch(float* dst,
                                                            float* src1,
                                                            float* src2,
                                                            int size);

//Group:Stream Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_add(short* dst,
                                                                  short* src1,
                                                                  int size);
//Group:Stream Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_add(int* dst,
                                                                  int* src1,
                                                                  int size);
//Group:Stream Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_add(half* dst,
                                                                  half* src1,
                                                                  int size);

static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_add(bfloat16_t* dst,
                                                                  bfloat16_t* src1,
                                                                  int size);

//Group:Stream Atomic Reduce Functions
/**
 * @brief Increases ``<dst>`` by ``<src1>`` element-wisely. That is: ``<dst>`` = ``<dst>`` + ``<src1>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src1 The address of first source vector.
 * @param[in] size The elements number of source vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<src1>`` must point to ``__nram__`` address space;
 * - ``<dst>`` must point to ``__mlu_device__`` address space;
 * - The address of ``<dst>`` must be ``sizeof(type)`` aligned;
 * - This interface is supported on ``mtp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_binary_operation_functions` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_add(float* dst,
                                                                  float* src1,
                                                                  int size);

//Group:Stream Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_inc(unsigned short* dst,
                                                                  unsigned short* src1,
                                                                  int size);
//Group:Stream Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_inc(short* dst,
                                                                  short* src1,
                                                                  int size);
//Group:Stream Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_inc(unsigned int* dst,
                                                                  unsigned int* src1,
                                                                  int size);

//Group:Stream Atomic Reduce Functions
/**
 * @brief Compares vector ``<dst>`` and ``<src1>``. If ``<dst>`` is smaller than ``<src1>``, increases ``<dst>`` by 1; otherwise, sets ``<dst>`` to 0. That is: ``<dst>`` = (``<dst>`` >= ``<src1>``) ? 0 : (``<dst>`` + 1).
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src1 The address of first source vector.
 * @param[in] size The elements number of source vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<src1>`` must point to ``__nram__`` address space;
 * - ``<dst>`` must point to ``__mlu_device__`` address space;
 * - The address of ``<dst>`` must be ``sizeof(type)`` aligned;
 * - This interface is supported on ``mtp_3xx`` and higher.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_inc(int* dst,
                                                                  int* src1,
                                                                  int size);

//Group:Stream Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_dec(unsigned short* dst,
                                                                  unsigned short* src1,
                                                                  int size);
//Group:Stream Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_dec(short* dst,
                                                                  short* src1,
                                                                  int size);
//Group:Stream Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_dec(unsigned int* dst,
                                                                  unsigned int* src1,
                                                                  int size);

//Group:Stream Atomic Reduce Functions
/**
 * @brief Compares vector ``<dst>`` and ``<src1>``. If ``<dst>`` is larger than ``<src1>``, or the value of ``<dst>`` is 0, stores the int value ``<src1>`` in ``<dst>``; otherwise, reduces ``<dst>`` by 1. That is: ``<dst>`` = (``<dst>`` == 0 || ``<dst>`` > ``<src1>``) ? ``<src1>`` : (``<dst>`` - 1).
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src1 The address of first source vector.
 * @param[in] size The elements number of source vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<src1>`` must point to ``__nram__`` address space;
 * - ``<dst>`` must point to ``__mlu_device__`` address space;
 * - The address of ``<dst>`` must be ``sizeof(type)`` aligned;
 * - This interface is supported on ``mtp_3xx`` and higher.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_dec(int* dst,
                                                                  int* src1,
                                                                  int size);

//Group:Stream Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_max(unsigned short* dst,
                                                                  unsigned short* src1,
                                                                  int size);
//Group:Stream Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_max(short* dst,
                                                                  short* src1,
                                                                  int size);
//Group:Stream Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_max(unsigned int* dst,
                                                                  unsigned int* src1,
                                                                  int size);
//Group:Stream Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_max(int* dst,
                                                                  int* src1,
                                                                  int size);
//Group:Stream Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_max(half* dst,
                                                                  half* src1,
                                                                  int size);

static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_max(bfloat16_t* dst,
                                                                  bfloat16_t* src1,
                                                                  int size);

//Group:Stream Atomic Reduce Functions
/**
 * @brief Takes the larger value from vector ``<dst>`` and ``<src1>``, and stores it in ``<dst>``. That is: ``<dst>`` = (``<dst>`` > ``<src1>``) ? ``<dst>`` : ``<src1>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src1 The address of first source vector.
 * @param[in] size The elements number of source vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<src1>`` must point to ``__nram__`` address space;
 * - ``<dst>`` must point to ``__mlu_device__`` address space;
 * - The address of ``<dst>`` must be ``sizeof(type)`` aligned;
 * - This interface is supported on ``mtp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_operation_functions_with_elementwise` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_max(float* dst,
                                                                  float* src1,
                                                                  int size);

//Group:Stream Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_min(unsigned short* dst,
                                                                  unsigned short* src1,
                                                                  int size);
//Group:Stream Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_min(short* dst,
                                                                  short* src1,
                                                                  int size);
//Group:Stream Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_min(unsigned int* dst,
                                                                  unsigned int* src1,
                                                                  int size);
//Group:Stream Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_min(int* dst,
                                                                  int* src1,
                                                                  int size);
//Group:Stream Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_min(half* dst,
                                                                  half* src1,
                                                                  int size);

static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_min(bfloat16_t* dst,
                                                                  bfloat16_t* src1,
                                                                  int size);

//Group:Stream Atomic Reduce Functions
/**
 * @brief Takes the smaller value from two vector values ``<dst>`` and ``<src1>``, and stores it in ``<dst>``. That is: ``<dst>`` = (``<dst>`` < ``<src1>``) ? ``<dst>`` : ``<src1>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src1 The address of first source vector.
 * @param[in] size The elements number of source vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<src1>`` must point to ``__nram__`` address space;
 * - ``<dst>`` must point to ``__mlu_device__`` address space;
 * - The address of ``<src1>`` must be ``sizeof(type)`` aligned;
 * - This interface is supported on ``mtp_3xx`` and higher;
 * - See the table :ref:`floating_point_calculation_of_stream_and_scalar_comparison_operation_functions_with_elementwise` for more details.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_min(float* dst,
                                                                  float* src1,
                                                                  int size);

//Group:Stream Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_and(short* dst,
                                                                  short* src1,
                                                                  int size);

//Group:Stream Atomic Reduce Functions
/**
 * @brief Applies bitwise AND operation to the vector ``<dst>`` and ``<src1>``, and stores the result in ``<dst>``. That is: ``<dst>`` = ``<dst>`` & ``<src1>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src1 The address of first source vector.
 * @param[in] size The elements number of source vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<src1>`` must point to ``__nram__`` address space;
 * - ``<dst>`` must point to ``__mlu_device__`` address space;
 * - The address of ``<dst>`` must be ``sizeof(type)`` aligned;
 * - This interface is supported on ``mtp_3xx`` and higher.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_and(int* dst,
                                                                  int* src1,
                                                                  int size);

//Group:Stream Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_or(short* dst,
                                                                 short* src1,
                                                                 int size);

//Group:Stream Atomic Reduce Functions
/**
 * @brief Applies bitwise OR operation to vector ``<dst>`` and ``<src1>``, and stores the result in ``<dst>``. That is: ``<dst>`` = ``<dst>`` | ``<src1>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src1 The address of first source vector.
 * @param[in] size The elements number of source vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<src1>`` must point to ``__nram__`` address space;
 * - ``<dst>`` must point to ``__mlu_device__`` address space;
 * - The address of ``<dst>`` must be ``sizeof(type)`` aligned;
 * - This interface is supported on ``mtp_3xx`` and higher.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_or(int* dst,
                                                                 int* src1,
                                                                 int size);

//Group:Stream Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_xor(short* dst,
                                                                  short* src1,
                                                                  int size);

//Group:Stream Atomic Reduce Functions
/**
 * @brief Applies bitwise XOR operation to vector ``<dst>`` and ``<src1>``, and stores the result in ``<dst>``. That is: ``<dst>`` = ``<dst>`` ^ ``<src1>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src1 The address of first source vector.
 * @param[in] size The elements number of source vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<src1>`` must point to ``__nram__`` address space;
 * - ``<dst>`` must point to ``__mlu_device__`` address space;
 * - The address of ``<dst>`` must be ``sizeof(type)`` aligned;
 * - This interface is supported on ``mtp_3xx`` and higher.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_xor(int* dst,
                                                                  int* src1,
                                                                  int size);


//Group:Stream Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_exch(short* dst,
                                                                   short* src1,
                                                                   int size);
//Group:Stream Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_exch(int* dst,
                                                                   int* src1,
                                                                   int size);
//Group:Stream Atomic Reduce Functions
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_exch(half* dst,
                                                                   half* src1,
                                                                   int size);

static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_exch(bfloat16_t* dst,
                                                                   bfloat16_t* src1,
                                                                   int size);

//Group:Stream Atomic Reduce Functions
/**
 * @brief Stores ``<src1>`` in ``<dst>``. That is: ``<dst>`` = ``<src1>``.
 *
 * @details
 *
 * @param[out] dst The address of destination vector.
 * @param[in] src1 The address of first source vector.
 * @param[in] size The elements number of source vector.
 * @return ``void``.
 * @remark
 * \rst
 * - ``<src1>`` must point to ``__nram__`` address space;
 * - ``<dst>`` must point to ``__mlu_device__`` address space;
 * - The address of ``<dst>`` must be ``sizeof(type)`` aligned;
 * - This interface is supported on ``mtp_3xx`` and higher.
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __bang_atomic_reduce_exch(float* dst,
                                                                   float* src1,
                                                                   int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(short* dst,
                                                                    short* src1_base,
                                                                    char* src1_offset,
                                                                    short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(short* dst,
                                                                    short* src1_base,
                                                                    short* src1_offset,
                                                                    short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(short* dst,
                                                                    short* src1_base,
                                                                    int* src1_offset,
                                                                    short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(short* dst,
                                                                    short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(int* dst,
                                                                    int* src1_base,
                                                                    char* src1_offset,
                                                                    int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(int* dst,
                                                                    int* src1_base,
                                                                    short* src1_offset,
                                                                    int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(int* dst,
                                                                    int* src1_base,
                                                                    int* src1_offset,
                                                                    int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(int* dst,
                                                                    int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(half* dst,
                                                                    half* src1_base,
                                                                    char* src1_offset,
                                                                    half* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(half* dst,
                                                                    half* src1_base,
                                                                    short* src1_offset,
                                                                    half* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(half* dst,
                                                                    half* src1_base,
                                                                    int* src1_offset,
                                                                    half* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(half* dst,
                                                                    half* src1_base,
                                                                    int64_t* src1_offset,
                                                                    half* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(float* dst,
                                                                    float* src1_base,
                                                                    char* src1_offset,
                                                                    float* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(float* dst,
                                                                    float* src1_base,
                                                                    short* src1_offset,
                                                                    float* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(float* dst,
                                                                    float* src1_base,
                                                                    int* src1_offset,
                                                                    float* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(float* dst,
                                                                    float* src1_base,
                                                                    int64_t* src1_offset,
                                                                    float* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    char* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    short* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    int* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    int64_t* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(short* dst,
                                                                    short* src1_base,
                                                                    char* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(short* dst,
                                                                    short* src1_base,
                                                                    short* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(short* dst,
                                                                    short* src1_base,
                                                                    int* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(short* dst,
                                                                    short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(int* dst,
                                                                    int* src1_base,
                                                                    char* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(int* dst,
                                                                    int* src1_base,
                                                                    short* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(int* dst,
                                                                    int* src1_base,
                                                                    int* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(int* dst,
                                                                    int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(half* dst,
                                                                    half* src1_base,
                                                                    char* src1_offset,
                                                                    half* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(half* dst,
                                                                    half* src1_base,
                                                                    short* src1_offset,
                                                                    half* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(half* dst,
                                                                    half* src1_base,
                                                                    int* src1_offset,
                                                                    half* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(half* dst,
                                                                    half* src1_base,
                                                                    int64_t* src1_offset,
                                                                    half* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(float* dst,
                                                                    float* src1_base,
                                                                    char* src1_offset,
                                                                    float* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(float* dst,
                                                                    float* src1_base,
                                                                    short* src1_offset,
                                                                    float* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(float* dst,
                                                                    float* src1_base,
                                                                    int* src1_offset,
                                                                    float* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(float* dst,
                                                                    float* src1_base,
                                                                    int64_t* src1_offset,
                                                                    float* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    char* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    short* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    int* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_add(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    int64_t* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(short* dst,
                                                                    short* src1_base,
                                                                    char* src1_offset,
                                                                    short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(short* dst,
                                                                    short* src1_base,
                                                                    short* src1_offset,
                                                                    short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(short* dst,
                                                                    short* src1_base,
                                                                    int* src1_offset,
                                                                    short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(short* dst,
                                                                    short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    char* src1_offset,
                                                                    unsigned short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    short* src1_offset,
                                                                    unsigned short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    int* src1_offset,
                                                                    unsigned short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    unsigned short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(int* dst,
                                                                    int* src1_base,
                                                                    char* src1_offset,
                                                                    int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(int* dst,
                                                                    int* src1_base,
                                                                    short* src1_offset,
                                                                    int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(int* dst,
                                                                    int* src1_base,
                                                                    int* src1_offset,
                                                                    int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(int* dst,
                                                                    int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    char* src1_offset,
                                                                    unsigned int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    short* src1_offset,
                                                                    unsigned int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    int* src1_offset,
                                                                    unsigned int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    unsigned int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(short* dst,
                                                                    short* src1_base,
                                                                    char* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(short* dst,
                                                                    short* src1_base,
                                                                    short* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(short* dst,
                                                                    short* src1_base,
                                                                    int* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(short* dst,
                                                                    short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    char* src1_offset,
                                                                    unsigned short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    short* src1_offset,
                                                                    unsigned short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    int* src1_offset,
                                                                    unsigned short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    unsigned short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(int* dst,
                                                                    int* src1_base,
                                                                    char* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(int* dst,
                                                                    int* src1_base,
                                                                    short* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(int* dst,
                                                                    int* src1_base,
                                                                    int* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(int* dst,
                                                                    int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    char* src1_offset,
                                                                    unsigned int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    short* src1_offset,
                                                                    unsigned int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    int* src1_offset,
                                                                    unsigned int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_inc(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    unsigned int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(short* dst,
                                                                    short* src1_base,
                                                                    char* src1_offset,
                                                                    short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(short* dst,
                                                                    short* src1_base,
                                                                    short* src1_offset,
                                                                    short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(short* dst,
                                                                    short* src1_base,
                                                                    int* src1_offset,
                                                                    short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(short* dst,
                                                                    short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    char* src1_offset,
                                                                    unsigned short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    short* src1_offset,
                                                                    unsigned short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    int* src1_offset,
                                                                    unsigned short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    unsigned short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(int* dst,
                                                                    int* src1_base,
                                                                    char* src1_offset,
                                                                    int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(int* dst,
                                                                    int* src1_base,
                                                                    short* src1_offset,
                                                                    int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(int* dst,
                                                                    int* src1_base,
                                                                    int* src1_offset,
                                                                    int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(int* dst,
                                                                    int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    char* src1_offset,
                                                                    unsigned int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    short* src1_offset,
                                                                    unsigned int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    int* src1_offset,
                                                                    unsigned int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    unsigned int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(short* dst,
                                                                    short* src1_base,
                                                                    char* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(short* dst,
                                                                    short* src1_base,
                                                                    short* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(short* dst,
                                                                    short* src1_base,
                                                                    int* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(short* dst,
                                                                    short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    char* src1_offset,
                                                                    unsigned short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    short* src1_offset,
                                                                    unsigned short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    int* src1_offset,
                                                                    unsigned short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    unsigned short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(int* dst,
                                                                    int* src1_base,
                                                                    char* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(int* dst,
                                                                    int* src1_base,
                                                                    short* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(int* dst,
                                                                    int* src1_base,
                                                                    int* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(int* dst,
                                                                    int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    char* src1_offset,
                                                                    unsigned int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    short* src1_offset,
                                                                    unsigned int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    int* src1_offset,
                                                                    unsigned int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_dec(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    unsigned int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(short* dst,
                                                                    short* src1_base,
                                                                    char* src1_offset,
                                                                    short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(short* dst,
                                                                    short* src1_base,
                                                                    short* src1_offset,
                                                                    short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(short* dst,
                                                                    short* src1_base,
                                                                    int* src1_offset,
                                                                    short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(short* dst,
                                                                    short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    char* src1_offset,
                                                                    unsigned short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    short* src1_offset,
                                                                    unsigned short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    int* src1_offset,
                                                                    unsigned short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    unsigned short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(int* dst,
                                                                    int* src1_base,
                                                                    char* src1_offset,
                                                                    int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(int* dst,
                                                                    int* src1_base,
                                                                    short* src1_offset,
                                                                    int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(int* dst,
                                                                    int* src1_base,
                                                                    int* src1_offset,
                                                                    int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(int* dst,
                                                                    int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    char* src1_offset,
                                                                    unsigned int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    short* src1_offset,
                                                                    unsigned int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    int* src1_offset,
                                                                    unsigned int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    unsigned int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(half* dst,
                                                                    half* src1_base,
                                                                    char* src1_offset,
                                                                    half* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(half* dst,
                                                                    half* src1_base,
                                                                    short* src1_offset,
                                                                    half* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(half* dst,
                                                                    half* src1_base,
                                                                    int* src1_offset,
                                                                    half* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(half* dst,
                                                                    half* src1_base,
                                                                    int64_t* src1_offset,
                                                                    half* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(float* dst,
                                                                    float* src1_base,
                                                                    char* src1_offset,
                                                                    float* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(float* dst,
                                                                    float* src1_base,
                                                                    short* src1_offset,
                                                                    float* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(float* dst,
                                                                    float* src1_base,
                                                                    int* src1_offset,
                                                                    float* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(float* dst,
                                                                    float* src1_base,
                                                                    int64_t* src1_offset,
                                                                    float* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    char* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    short* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    int* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    int64_t* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(short* dst,
                                                                    short* src1_base,
                                                                    char* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(short* dst,
                                                                    short* src1_base,
                                                                    short* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(short* dst,
                                                                    short* src1_base,
                                                                    int* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(short* dst,
                                                                    short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    char* src1_offset,
                                                                    unsigned short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    short* src1_offset,
                                                                    unsigned short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    int* src1_offset,
                                                                    unsigned short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    unsigned short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(int* dst,
                                                                    int* src1_base,
                                                                    char* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(int* dst,
                                                                    int* src1_base,
                                                                    short* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(int* dst,
                                                                    int* src1_base,
                                                                    int* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(int* dst,
                                                                    int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    char* src1_offset,
                                                                    unsigned int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    short* src1_offset,
                                                                    unsigned int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    int* src1_offset,
                                                                    unsigned int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    unsigned int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(half* dst,
                                                                    half* src1_base,
                                                                    char* src1_offset,
                                                                    half* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(half* dst,
                                                                    half* src1_base,
                                                                    short* src1_offset,
                                                                    half* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(half* dst,
                                                                    half* src1_base,
                                                                    int* src1_offset,
                                                                    half* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(half* dst,
                                                                    half* src1_base,
                                                                    int64_t* src1_offset,
                                                                    half* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(float* dst,
                                                                    float* src1_base,
                                                                    char* src1_offset,
                                                                    float* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(float* dst,
                                                                    float* src1_base,
                                                                    short* src1_offset,
                                                                    float* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(float* dst,
                                                                    float* src1_base,
                                                                    int* src1_offset,
                                                                    float* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(float* dst,
                                                                    float* src1_base,
                                                                    int64_t* src1_offset,
                                                                    float* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    char* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    short* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    int* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_max(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    int64_t* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(short* dst,
                                                                    short* src1_base,
                                                                    char* src1_offset,
                                                                    short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(short* dst,
                                                                    short* src1_base,
                                                                    short* src1_offset,
                                                                    short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(short* dst,
                                                                    short* src1_base,
                                                                    int* src1_offset,
                                                                    short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(short* dst,
                                                                    short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    char* src1_offset,
                                                                    unsigned short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    short* src1_offset,
                                                                    unsigned short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    int* src1_offset,
                                                                    unsigned short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    unsigned short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(int* dst,
                                                                    int* src1_base,
                                                                    char* src1_offset,
                                                                    int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(int* dst,
                                                                    int* src1_base,
                                                                    short* src1_offset,
                                                                    int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(int* dst,
                                                                    int* src1_base,
                                                                    int* src1_offset,
                                                                    int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(int* dst,
                                                                    int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    char* src1_offset,
                                                                    unsigned int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    short* src1_offset,
                                                                    unsigned int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    int* src1_offset,
                                                                    unsigned int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    unsigned int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(half* dst,
                                                                    half* src1_base,
                                                                    char* src1_offset,
                                                                    half* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(half* dst,
                                                                    half* src1_base,
                                                                    short* src1_offset,
                                                                    half* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(half* dst,
                                                                    half* src1_base,
                                                                    int* src1_offset,
                                                                    half* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(half* dst,
                                                                    half* src1_base,
                                                                    int64_t* src1_offset,
                                                                    half* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(float* dst,
                                                                    float* src1_base,
                                                                    char* src1_offset,
                                                                    float* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(float* dst,
                                                                    float* src1_base,
                                                                    short* src1_offset,
                                                                    float* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(float* dst,
                                                                    float* src1_base,
                                                                    int* src1_offset,
                                                                    float* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(float* dst,
                                                                    float* src1_base,
                                                                    int64_t* src1_offset,
                                                                    float* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    char* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    short* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    int* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    int64_t* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(short* dst,
                                                                    short* src1_base,
                                                                    char* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(short* dst,
                                                                    short* src1_base,
                                                                    short* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(short* dst,
                                                                    short* src1_base,
                                                                    int* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(short* dst,
                                                                    short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    char* src1_offset,
                                                                    unsigned short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    short* src1_offset,
                                                                    unsigned short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    int* src1_offset,
                                                                    unsigned short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(unsigned short* dst,
                                                                    unsigned short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    unsigned short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(int* dst,
                                                                    int* src1_base,
                                                                    char* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(int* dst,
                                                                    int* src1_base,
                                                                    short* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(int* dst,
                                                                    int* src1_base,
                                                                    int* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(int* dst,
                                                                    int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    char* src1_offset,
                                                                    unsigned int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    short* src1_offset,
                                                                    unsigned int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    int* src1_offset,
                                                                    unsigned int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(unsigned int* dst,
                                                                    unsigned int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    unsigned int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(half* dst,
                                                                    half* src1_base,
                                                                    char* src1_offset,
                                                                    half* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(half* dst,
                                                                    half* src1_base,
                                                                    short* src1_offset,
                                                                    half* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(half* dst,
                                                                    half* src1_base,
                                                                    int* src1_offset,
                                                                    half* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(half* dst,
                                                                    half* src1_base,
                                                                    int64_t* src1_offset,
                                                                    half* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(float* dst,
                                                                    float* src1_base,
                                                                    char* src1_offset,
                                                                    float* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(float* dst,
                                                                    float* src1_base,
                                                                    short* src1_offset,
                                                                    float* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(float* dst,
                                                                    float* src1_base,
                                                                    int* src1_offset,
                                                                    float* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(float* dst,
                                                                    float* src1_base,
                                                                    int64_t* src1_offset,
                                                                    float* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    char* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    short* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    int* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_min(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    int64_t* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_and(short* dst,
                                                                    short* src1_base,
                                                                    char* src1_offset,
                                                                    short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_and(short* dst,
                                                                    short* src1_base,
                                                                    short* src1_offset,
                                                                    short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_and(short* dst,
                                                                    short* src1_base,
                                                                    int* src1_offset,
                                                                    short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_and(short* dst,
                                                                    short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_and(int* dst,
                                                                    int* src1_base,
                                                                    char* src1_offset,
                                                                    int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_and(int* dst,
                                                                    int* src1_base,
                                                                    short* src1_offset,
                                                                    int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_and(int* dst,
                                                                    int* src1_base,
                                                                    int* src1_offset,
                                                                    int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_and(int* dst,
                                                                    int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_and(short* dst,
                                                                    short* src1_base,
                                                                    char* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_and(short* dst,
                                                                    short* src1_base,
                                                                    short* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_and(short* dst,
                                                                    short* src1_base,
                                                                    int* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_and(short* dst,
                                                                    short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_and(int* dst,
                                                                    int* src1_base,
                                                                    char* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_and(int* dst,
                                                                    int* src1_base,
                                                                    short* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_and(int* dst,
                                                                    int* src1_base,
                                                                    int* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_and(int* dst,
                                                                    int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_or(short* dst,
                                                                   short* src1_base,
                                                                   char* src1_offset,
                                                                   short* src2,
                                                                   int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_or(short* dst,
                                                                   short* src1_base,
                                                                   short* src1_offset,
                                                                   short* src2,
                                                                   int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_or(short* dst,
                                                                   short* src1_base,
                                                                   int* src1_offset,
                                                                   short* src2,
                                                                   int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_or(short* dst,
                                                                   short* src1_base,
                                                                   int64_t* src1_offset,
                                                                   short* src2,
                                                                   int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_or(int* dst,
                                                                   int* src1_base,
                                                                   char* src1_offset,
                                                                   int* src2,
                                                                   int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_or(int* dst,
                                                                   int* src1_base,
                                                                   short* src1_offset,
                                                                   int* src2,
                                                                   int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_or(int* dst,
                                                                   int* src1_base,
                                                                   int* src1_offset,
                                                                   int* src2,
                                                                   int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_or(int* dst,
                                                                   int* src1_base,
                                                                   int64_t* src1_offset,
                                                                   int* src2,
                                                                   int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_or(short* dst,
                                                                   short* src1_base,
                                                                   char* src1_offset,
                                                                   short* src2,
                                                                   void* mask,
                                                                   int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_or(short* dst,
                                                                   short* src1_base,
                                                                   short* src1_offset,
                                                                   short* src2,
                                                                   void* mask,
                                                                   int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_or(short* dst,
                                                                   short* src1_base,
                                                                   int* src1_offset,
                                                                   short* src2,
                                                                   void* mask,
                                                                   int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_or(short* dst,
                                                                   short* src1_base,
                                                                   int64_t* src1_offset,
                                                                   short* src2,
                                                                   void* mask,
                                                                   int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_or(int* dst,
                                                                   int* src1_base,
                                                                   char* src1_offset,
                                                                   int* src2,
                                                                   void* mask,
                                                                   int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_or(int* dst,
                                                                   int* src1_base,
                                                                   short* src1_offset,
                                                                   int* src2,
                                                                   void* mask,
                                                                   int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_or(int* dst,
                                                                   int* src1_base,
                                                                   int* src1_offset,
                                                                   int* src2,
                                                                   void* mask,
                                                                   int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_or(int* dst,
                                                                   int* src1_base,
                                                                   int64_t* src1_offset,
                                                                   int* src2,
                                                                   void* mask,
                                                                   int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_xor(short* dst,
                                                                    short* src1_base,
                                                                    char* src1_offset,
                                                                    short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_xor(short* dst,
                                                                    short* src1_base,
                                                                    short* src1_offset,
                                                                    short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_xor(short* dst,
                                                                    short* src1_base,
                                                                    int* src1_offset,
                                                                    short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_xor(short* dst,
                                                                    short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    short* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_xor(int* dst,
                                                                    int* src1_base,
                                                                    char* src1_offset,
                                                                    int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_xor(int* dst,
                                                                    int* src1_base,
                                                                    short* src1_offset,
                                                                    int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_xor(int* dst,
                                                                    int* src1_base,
                                                                    int* src1_offset,
                                                                    int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_xor(int* dst,
                                                                    int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    int* src2,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_xor(short* dst,
                                                                    short* src1_base,
                                                                    char* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_xor(short* dst,
                                                                    short* src1_base,
                                                                    short* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_xor(short* dst,
                                                                    short* src1_base,
                                                                    int* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_xor(short* dst,
                                                                    short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_xor(int* dst,
                                                                    int* src1_base,
                                                                    char* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_xor(int* dst,
                                                                    int* src1_base,
                                                                    short* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_xor(int* dst,
                                                                    int* src1_base,
                                                                    int* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_xor(int* dst,
                                                                    int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(short* dst,
                                                                     short* src1_base,
                                                                     char* src1_offset,
                                                                     short* src2,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(short* dst,
                                                                     short* src1_base,
                                                                     short* src1_offset,
                                                                     short* src2,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(short* dst,
                                                                     short* src1_base,
                                                                     int* src1_offset,
                                                                     short* src2,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(short* dst,
                                                                     short* src1_base,
                                                                     int64_t* src1_offset,
                                                                     short* src2,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(int* dst,
                                                                     int* src1_base,
                                                                     char* src1_offset,
                                                                     int* src2,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(int* dst,
                                                                     int* src1_base,
                                                                     short* src1_offset,
                                                                     int* src2,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(int* dst,
                                                                     int* src1_base,
                                                                     int* src1_offset,
                                                                     int* src2,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(int* dst,
                                                                     int* src1_base,
                                                                     int64_t* src1_offset,
                                                                     int* src2,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(half* dst,
                                                                     half* src1_base,
                                                                     char* src1_offset,
                                                                     half* src2,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(half* dst,
                                                                     half* src1_base,
                                                                     short* src1_offset,
                                                                     half* src2,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(half* dst,
                                                                     half* src1_base,
                                                                     int* src1_offset,
                                                                     half* src2,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(half* dst,
                                                                     half* src1_base,
                                                                     int64_t* src1_offset,
                                                                     half* src2,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(float* dst,
                                                                     float* src1_base,
                                                                     char* src1_offset,
                                                                     float* src2,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(float* dst,
                                                                     float* src1_base,
                                                                     short* src1_offset,
                                                                     float* src2,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(float* dst,
                                                                     float* src1_base,
                                                                     int* src1_offset,
                                                                     float* src2,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(float* dst,
                                                                     float* src1_base,
                                                                     int64_t* src1_offset,
                                                                     float* src2,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(bfloat16_t* dst,
                                                                     bfloat16_t* src1_base,
                                                                     char* src1_offset,
                                                                     bfloat16_t* src2,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(bfloat16_t* dst,
                                                                     bfloat16_t* src1_base,
                                                                     short* src1_offset,
                                                                     bfloat16_t* src2,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(bfloat16_t* dst,
                                                                     bfloat16_t* src1_base,
                                                                     int* src1_offset,
                                                                     bfloat16_t* src2,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(bfloat16_t* dst,
                                                                     bfloat16_t* src1_base,
                                                                     int64_t* src1_offset,
                                                                     bfloat16_t* src2,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(short* dst,
                                                                     short* src1_base,
                                                                     char* src1_offset,
                                                                     short* src2,
                                                                     void* mask,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(short* dst,
                                                                     short* src1_base,
                                                                     short* src1_offset,
                                                                     short* src2,
                                                                     void* mask,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(short* dst,
                                                                     short* src1_base,
                                                                     int* src1_offset,
                                                                     short* src2,
                                                                     void* mask,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(short* dst,
                                                                     short* src1_base,
                                                                     int64_t* src1_offset,
                                                                     short* src2,
                                                                     void* mask,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(int* dst,
                                                                     int* src1_base,
                                                                     char* src1_offset,
                                                                     int* src2,
                                                                     void* mask,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(int* dst,
                                                                     int* src1_base,
                                                                     short* src1_offset,
                                                                     int* src2,
                                                                     void* mask,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(int* dst,
                                                                     int* src1_base,
                                                                     int* src1_offset,
                                                                     int* src2,
                                                                     void* mask,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(int* dst,
                                                                     int* src1_base,
                                                                     int64_t* src1_offset,
                                                                     int* src2,
                                                                     void* mask,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(half* dst,
                                                                     half* src1_base,
                                                                     char* src1_offset,
                                                                     half* src2,
                                                                     void* mask,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(half* dst,
                                                                     half* src1_base,
                                                                     short* src1_offset,
                                                                     half* src2,
                                                                     void* mask,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(half* dst,
                                                                     half* src1_base,
                                                                     int* src1_offset,
                                                                     half* src2,
                                                                     void* mask,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(half* dst,
                                                                     half* src1_base,
                                                                     int64_t* src1_offset,
                                                                     half* src2,
                                                                     void* mask,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(float* dst,
                                                                     float* src1_base,
                                                                     char* src1_offset,
                                                                     float* src2,
                                                                     void* mask,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(float* dst,
                                                                     float* src1_base,
                                                                     short* src1_offset,
                                                                     float* src2,
                                                                     void* mask,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(float* dst,
                                                                     float* src1_base,
                                                                     int* src1_offset,
                                                                     float* src2,
                                                                     void* mask,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(float* dst,
                                                                     float* src1_base,
                                                                     int64_t* src1_offset,
                                                                     float* src2,
                                                                     void* mask,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(bfloat16_t* dst,
                                                                     bfloat16_t* src1_base,
                                                                     char* src1_offset,
                                                                     bfloat16_t* src2,
                                                                     void* mask,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(bfloat16_t* dst,
                                                                     bfloat16_t* src1_base,
                                                                     short* src1_offset,
                                                                     bfloat16_t* src2,
                                                                     void* mask,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(bfloat16_t* dst,
                                                                     bfloat16_t* src1_base,
                                                                     int* src1_offset,
                                                                     bfloat16_t* src2,
                                                                     void* mask,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_exch(bfloat16_t* dst,
                                                                     bfloat16_t* src1_base,
                                                                     int64_t* src1_offset,
                                                                     bfloat16_t* src2,
                                                                     void* mask,
                                                                     int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(short* dst,
                                                                    short* src1_base,
                                                                    char* src1_offset,
                                                                    short* src2,
                                                                    short src3,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(short* dst,
                                                                    short* src1_base,
                                                                    short* src1_offset,
                                                                    short* src2,
                                                                    short src3,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(short* dst,
                                                                    short* src1_base,
                                                                    int* src1_offset,
                                                                    short* src2,
                                                                    short src3,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(short* dst,
                                                                    short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    short* src2,
                                                                    short src3,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(int* dst,
                                                                    int* src1_base,
                                                                    char* src1_offset,
                                                                    int* src2,
                                                                    int src3,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(int* dst,
                                                                    int* src1_base,
                                                                    short* src1_offset,
                                                                    int* src2,
                                                                    int src3,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(int* dst,
                                                                    int* src1_base,
                                                                    int* src1_offset,
                                                                    int* src2,
                                                                    int src3,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(int* dst,
                                                                    int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    int* src2,
                                                                    int src3,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(half* dst,
                                                                    half* src1_base,
                                                                    char* src1_offset,
                                                                    half* src2,
                                                                    half src3,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(half* dst,
                                                                    half* src1_base,
                                                                    short* src1_offset,
                                                                    half* src2,
                                                                    half src3,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(half* dst,
                                                                    half* src1_base,
                                                                    int* src1_offset,
                                                                    half* src2,
                                                                    half src3,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(half* dst,
                                                                    half* src1_base,
                                                                    int64_t* src1_offset,
                                                                    half* src2,
                                                                    half src3,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(float* dst,
                                                                    float* src1_base,
                                                                    char* src1_offset,
                                                                    float* src2,
                                                                    float src3,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(float* dst,
                                                                    float* src1_base,
                                                                    short* src1_offset,
                                                                    float* src2,
                                                                    float src3,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(float* dst,
                                                                    float* src1_base,
                                                                    int* src1_offset,
                                                                    float* src2,
                                                                    float src3,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(float* dst,
                                                                    float* src1_base,
                                                                    int64_t* src1_offset,
                                                                    float* src2,
                                                                    float src3,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    char* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    bfloat16_t src3,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    short* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    bfloat16_t src3,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    int* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    bfloat16_t src3,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    int64_t* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    bfloat16_t src3,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(short* dst,
                                                                    short* src1_base,
                                                                    char* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    short src3,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(short* dst,
                                                                    short* src1_base,
                                                                    short* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    short src3,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(short* dst,
                                                                    short* src1_base,
                                                                    int* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    short src3,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(short* dst,
                                                                    short* src1_base,
                                                                    int64_t* src1_offset,
                                                                    short* src2,
                                                                    void* mask,
                                                                    short src3,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(int* dst,
                                                                    int* src1_base,
                                                                    char* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int src3,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(int* dst,
                                                                    int* src1_base,
                                                                    short* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int src3,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(int* dst,
                                                                    int* src1_base,
                                                                    int* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int src3,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(int* dst,
                                                                    int* src1_base,
                                                                    int64_t* src1_offset,
                                                                    int* src2,
                                                                    void* mask,
                                                                    int src3,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(half* dst,
                                                                    half* src1_base,
                                                                    char* src1_offset,
                                                                    half* src2,
                                                                    void* mask,
                                                                    half src3,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(half* dst,
                                                                    half* src1_base,
                                                                    short* src1_offset,
                                                                    half* src2,
                                                                    void* mask,
                                                                    half src3,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(half* dst,
                                                                    half* src1_base,
                                                                    int* src1_offset,
                                                                    half* src2,
                                                                    void* mask,
                                                                    half src3,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(half* dst,
                                                                    half* src1_base,
                                                                    int64_t* src1_offset,
                                                                    half* src2,
                                                                    void* mask,
                                                                    half src3,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(float* dst,
                                                                    float* src1_base,
                                                                    char* src1_offset,
                                                                    float* src2,
                                                                    void* mask,
                                                                    float src3,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(float* dst,
                                                                    float* src1_base,
                                                                    short* src1_offset,
                                                                    float* src2,
                                                                    void* mask,
                                                                    float src3,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(float* dst,
                                                                    float* src1_base,
                                                                    int* src1_offset,
                                                                    float* src2,
                                                                    void* mask,
                                                                    float src3,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(float* dst,
                                                                    float* src1_base,
                                                                    int64_t* src1_offset,
                                                                    float* src2,
                                                                    void* mask,
                                                                    float src3,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    char* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    void* mask,
                                                                    bfloat16_t src3,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    short* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    void* mask,
                                                                    bfloat16_t src3,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    int* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    void* mask,
                                                                    bfloat16_t src3,
                                                                    int size);

static __mlu_func__ __mlu_builtin__ void __bang_discrete_atomic_cas(bfloat16_t* dst,
                                                                    bfloat16_t* src1_base,
                                                                    int64_t* src1_offset,
                                                                    bfloat16_t* src2,
                                                                    void* mask,
                                                                    bfloat16_t src3,
                                                                    int size);

//Group:Scalar Type Conversion Functions
static __mlu_func__ __mlu_builtin__ unsigned char __popcnt(unsigned char src);
//Group:Scalar Type Conversion Functions
static __mlu_func__ __mlu_builtin__ unsigned short __popcnt(unsigned short src);
//Group:Scalar Type Conversion Functions
/**
 * @brief Counts the number of bits that are set to 1 in ``<src>``.
 *
 * @param[in] src The input data.
 *
 * @return ``unsigned char/short/int``.
 *
 * @remark
 * - None.
 *
 * @par Requirements
 * - This interface is supported on all architecture.
 *
*/
static __mlu_func__ __mlu_builtin__ unsigned int __popcnt(unsigned int src);

//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ int __bang_popcnt(unsigned int *src, int elem_count);
//Group:Stream Operation Functions
static __mlu_func__ __mlu_builtin__ int __bang_popcnt(unsigned short *src, int elem_count);
//Group:Stream Operation Functions
/**
 * @brief Counts the number of bits that are set to 1 in ``<src>``.
 *
 * @param[in] src The address of source vector.
 * @param[in] elem_count The elements number of source vector.
 *
 * @return ``int``.
 *
 * @remark
 * - This interface is supported on all architecture.
 *
*/
static __mlu_func__ __mlu_builtin__ int __bang_popcnt(unsigned char *src, int elem_count);

//Group:Control Flow And Debugging Functions
/**
 * @brief Makes assertion in the code, prints assert message and abort.
 *
 * @details
 *
 * @param[in] __assertion assertion message.
 * @param[in] __file assertion file.
 * @param[in] __line assertion line number.
 * @param[in] __function assertion function.
 * @return ``void``.
 * @remark
 * - This interface is supported on all architectures.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __assert_fail(const char* __assertion,
                                                       const char* __file,
                                                       unsigned int __line,
                                                       const char* __function);

//Group:Control Flow And Debugging Functions
/**
 * @brief Makes assertion in the code, prints assert message and abort. ``__assert`` is the same as that of in C language.
 *
 * <assert.h> should be included. For example, void assert(int exp), when exp is 0, message will be printed as: BANG Assertion failed: expression, file filename, line nnn. If macro NDEBUG is defined, macro assert will be ignored.
 *
 * @details
 *
 * @param[in] __assertion assertion message.
 * @param[in] __file assertion file.
 * @param[in] __line assertion line number.
 * @return ``void``.
 * @remark
 * - This interface is supported on all architectures.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __assert(const char* __assertion,
                                                  const char* __file,
                                                  int __line);

//Group:Lock Functions
/**
 * @brief Applies and seize lock_id.
 *
 * @details
 *
 * @param[in] lock_id_0 The first lock id.
 * @param[in] lock_id_1 The second lock id.
 * @return ``void``.
 * @remark
 * - For IPU Core, ``lock_id_0`` should be equal to ``lock_id_1``;
 * - For Mem Core, ``lock_id_0`` should be not equal to ``lock_id_1``;
 * - ::__bang_lock is always paired with ::__bang_unlock;
 * - ::__bang_lock can be used before ``__memcpy`` from to GDRAM, whose size is larger than 64KB;
 * - This interface is supported on ``(m)tp_2xx`` and higher.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * Example of ::__bang_lock usage in IPU Core is as follows:
 *
 * @par
 * @code
 *
 *    #include <bang.h>
 *
 *    #define BUFFER_SIZE 261632
 *
 *    __mlu_entry__ void add_kernel(half *input, half *output,
 *                                  int copyin_len, int copyout_len,
 *                                  int offseta, int offsetb,
 *                                  int offsetc, int tid) {
 *      __wram__ half temp[BUFFER_SIZE];
 *      if (coreId != 0x80) {
 *        __bang_lock(0, 0);
 *      }
 *      __memcpy(temp, input, 510 * 512 * sizeof(half), GDRAM2WRAM);
 *      if (coreId != 0x80) {
 *        __bang_unlock(0, 0);
 *      }
 *    }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __bang_lock(int lock_id_0, int lock_id_1);

//Group:Lock Functions
/**
 * @brief Releases lock_id.
 *
 * @details
 *
 * @param[in] lock_id_0 The first lock id.
 * @param[in] lock_id_1 The second lock id.
 * @return ``void``.
 * @remark
 * - For IPU Core, ``lock_id_0`` should be equal to ``lock_id_1``;
 * - For Mem Core, ``lock_id_0`` should be not equal to ``lock_id_1``;
 * - ::__bang_unlock is always paired with ::__bang_lock;
 * - ::__bang_unlock can be used after ``__memcpy`` from to GDRAM, whose size is larger than 64KB;
 * - This interface is supported on ``(m)tp_2xx`` and higher.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @par
 * Refer to ::__bang_unlock.
 */
static __mlu_func__ __mlu_builtin__ void __bang_unlock(int lock_id_0, int lock_id_1);

//Group:Control Flow And Debugging Functions
/**
 * @brief Return ``true`` if ``<ptr>`` points to ``__nram__`` address space.
 *
 * @details
 *
 * @param[in] ptr The input pointer.
 * @return ``bool``.
 * @remark
 * \rst
 *
 * - This interface is supported on all architectures.
 *
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ bool __is_nram(const void* ptr);

//Group:Control Flow And Debugging Functions
/**
 * @brief Return ``true`` if ``<ptr>`` points to ``__wram__`` address space.
 *
 * @details
 *
 * @param[in] ptr The input pointer.
 * @return ``bool``.
 * @remark
 * \rst
 *
 * - This interface is supported on all architectures.
 *
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ bool __is_wram(const void* ptr);

//Group:Control Flow And Debugging Functions
/**
 * @brief Return ``true`` if ``<ptr>`` points to ``__mlu_shared__`` address space.
 *
 * @details
 *
 * @param[in] ptr The input pointer.
 * @return ``bool``.
 * @remark
 * \rst
 *
 * - This interface is supported on all architectures.
 *
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ bool __is_sram(const void* ptr);

//Group:Control Flow And Debugging Functions
/**
 * @brief Return ``true`` for IPU cores.
 *
 * @details
 *
 * @return ``bool``.
 * @remark
 * \rst
 *
 * - This interface is supported on all architectures.
 *
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ bool __is_ipu();

//Group:Control Flow And Debugging Functions
/**
 * @brief Return ``true`` for MPU cores.
 *
 * @details
 *
 * @return ``bool``.
 * @remark
 * \rst
 *
 * - This interface is supported on all architectures.
 *
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ bool __is_mpu();

//Group:Synchronization Functions
/**
 * @brief Synchronizes all IPU cores of clusters on which the kernel executes. The number of IPU cores to synchronize is related to task type, e.g.,  UNION1 is 4, UNION2 is 8, and UNION4 is 16.
 *
 * @details
 *
 * @return``void``.
 * @remark
 * - This interface is supported on ``(m)tp_2xx`` and higher.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __sync_all_ipu();

//Group:Synchronization Functions
/**
 * @brief Synchronizes all MPU cores of clusters on which the kernel executes. The number of MPU cores to synchronize is related to task type, e.g.,  UNION1 is 1, UNION2 is 2, and UNION4 is 4.
 *
 * @details
 *
 * @return``void``.
 * @remark
 * - This interface is supported on ``(m)tp_2xx`` and higher.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __sync_all_mpu();

//Group:Synchronization Functions
/**
 * @brief Synchronizes all cores inside the cluster on which the kernel executes. The cores to synchronize consists of 1 mpu core and 4 ipu cores.
 *
 * @details
 *
 * @return``void``.
 * @remark
 * - This interface is supported on ``(m)tp_1xx`` and higher.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __sync_cluster();

//Group:Synchronization Functions
/**
 * @brief Synchronizes all clusters on which the kernel executes. It's effect is equal to __sync_all_ipu + __sync_all_mpu. The number of ipu core and mpu core to synchronize is related to task type, UNION1 is 5, UNION2 is 10, UNION4 is 20.
 *
 * @details
 *
 * @return``void``.
 * @remark
 * - This interface is supported on ``(m)tp_1xx`` and higher.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __sync_all();

//Group:Synchronization Functions
/**
 * @brief Synchronizes all computation instructions within a core.
 *
 * @details
 *
 * @return``void``.
 * @remark
 * - This interface is supported on ``(m)tp_2xx`` and higher.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __sync_compute();

//Group:Synchronization Functions
/**
 * @brief Synchronizes all copy instructions of NRAM2NRAM direction within a core. ``__sync_copy_nram_to_nram`` is used paired with ::__memcpy_async. For example, __memcpy_async(dst, src, size, NRAM2NRAM) is a producer, before instruction using ``<dst>``, ::__sync_copy_nram_to_nram should be inserted. Sync copy is used in pipeline programming model.
 *
 * @details
 *
 * @return``void``.
 * @remark
 * - This interface is supported on ``(m)tp_2xx`` and higher.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __sync_copy_nram_to_nram();

//Group:Synchronization Functions
/**
 * @brief Synchronizes all copy instructions of NRAM2GDRAM or NRAM2LDRAM direction within a core. ``__sync_copy_nram_to_dram`` is used paired with ::__memcpy_async. For example, __memcpy_async(dst, src, size, NRAM2GDRAM) is a producer, before instruction using ``<dst>``, ::__sync_copy_nram_to_dram should be inserted. Sync copy is used in pipeline programming model.
 *
 * @details
 *
 * @return``void``.
 * @remark
 * - This interface is supported on ``(m)tp_2xx`` and higher.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __sync_copy_nram_to_dram();

//Group:Synchronization Functions
/**
 * @brief Synchronizes all copy instructions of GDRAM2NRAM or LDRAM2NRAM direction within a core. ``__sync_copy_dram_to_nram`` is used paired with ::__memcpy_async. For example, __memcpy_async(dst, src, size, GDRAM2NRAM) is a producer, before instruction using ``<dst>``, ::__sync_copy_dram_to_nram should be inserted. Sync copy is used in pipeline programming model.
 *
 * @details
 *
 * @return``void``.
 * @remark
 * - This interface is supported on ``(m)tp_2xx`` and higher.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __sync_copy_dram_to_nram();

//Group:Synchronization Functions
/**
 * @brief Synchronizes all copy instructions of WRAM2GDRAM or WRAM2LDRAM direction within a core. ``__sync_copy_wram_to_dram`` is used paired with ::__memcpy_async. For example, __memcpy_async(dst, src, size, WRAM2GDRAM) is a producer, before instruction using ``<dst>``, ::__sync_copy_wram_to_dram should be inserted. Sync copy is used in pipeline programming model.
 *
 * @details
 *
 * @return``void``.
 * @remark
 * - This interface is supported on ``(m)tp_2xx`` and higher.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __sync_copy_wram_to_dram();

//Group:Synchronization Functions
/**
 * @brief Synchronizes all copy instructions of GDRAM2WRAM or LDRAM2WRAM direction within a core. ``__sync_copy_dram_to_wram`` is used paired with ::__memcpy_async. For example, __memcpy_async(dst, src, size, GDRAM2WRAM) is a producer, before instruction using ``<dst>``, ::__sync_copy_dram_to_wram should be inserted. Sync copy is used in pipeline programming model.
 *
 * @details
 *
 * @return``void``.
 * @remark
 * - This interface is supported on ``(m)tp_2xx`` and higher.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __sync_copy_dram_to_wram();

static __mlu_func__ __mlu_builtin__ void __sync_copy_sram_to_dram();

static __mlu_func__ __mlu_builtin__ void __sync_copy_dram_to_sram();

//Group:Synchronization Functions
/**
 * @brief Synchronizes all copy instructions of NRAM2SRAM direction within a core. ``__sync_copy_nram_to_sram`` is used paired with ::__memcpy_async. For example, __memcpy_async(dst, src, size, NRAM2SRAM) is a producer, before instruction using ``<dst>``, ::__sync_copy_nram_to_sram should be inserted. Sync copy is used in pipeline programming model.
 *
 * @details
 *
 * @return``void``.
 * @remark
 * - This interface is supported on ``(m)tp_2xx`` and higher.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __sync_copy_nram_to_sram();

//Group:Synchronization Functions
/**
 * @brief Synchronizes all copy instructions of SRAM2NRAM direction within a core. ``__sync_copy_sram_to_nram`` is used paired with ::__memcpy_async. For example, __memcpy_async(dst, src, size, SRAM2NRAM) is a producer, before instruction using ``<dst>``, ::__sync_copy_sram_to_nram should be inserted. Sync copy is used in pipeline programming model.
 *
 * @details
 *
 * @return``void``.
 * @remark
 * - This interface is supported on ``(m)tp_2xx`` and higher.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __sync_copy_sram_to_nram();

//Group:Synchronization Functions
/**
 * @brief Synchronizes all copy instructions of WRAM2SRAM direction within a core. ``__sync_copy_wram_to_sram`` is used paired with ::__memcpy_async. For example, __memcpy_async(dst, src, size, WRAM2SRAM) is a producer, before instruction using ``<dst>``, ::__sync_copy_wram_to_sram should be inserted. Sync copy is used in pipeline programming model.
 *
 * @details
 *
 * @return``void``.
 * @remark
 * - This interface is supported on ``(m)tp_2xx`` and higher.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __sync_copy_wram_to_sram();

//Group:Synchronization Functions
/**
 * @brief Synchronizes all copy instructions of SRAM2WRAM direction within a core. ``__sync_copy_sram_to_wram`` is used paired with ::__memcpy_async. For example, __memcpy_async(dst, src, size, SRAM2WRAM) is a producer, before instruction using ``<dst>``, ::__sync_copy_sram_to_wram should be inserted. Sync copy is used in pipeline programming model.
 *
 * @details
 *
 * @return``void``.
 * @remark
 * - This interface is supported on ``(m)tp_2xx`` and higher.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __sync_copy_sram_to_wram();

static __mlu_func__ __mlu_builtin__ void __sync_copy_sram_to_sram();

//Group:Memory Copy Functions
static __mlu_func__ __mlu_builtin__ void __memcpy(void* dst,
                                                  const void* src,
                                                  int size,
                                                  mluMemcpyDirection_t dir);
//Group:Memory Copy Functions
static __mlu_func__ __mlu_builtin__ void __memcpy(void* dst,
                                                  const void* src,
                                                  int size,
                                                  mluMemcpyDirection_t dir,
                                                  int dst_stride,
                                                  int src_stride,
                                                  int segnum);
//Group:Memory Copy Functions
static __mlu_func__ __mlu_builtin__ void __memcpy(void* dst,
                                                  const void* src,
                                                  int size,
                                                  mluMemcpyDirection_t dir,
                                                  int dst_stride,
                                                  int src_stride,
                                                  int segnum,
                                                  int id_dst_cluster);

//Group:Memory Copy Functions
/**
 * @brief Copies ``<size>`` bytes data from source address ``<src>`` to destination address ``<dst>``. The memory copy direction is specified by ``<dir>``.
 *
 * The memcpy interface are supported on all architectures. The memory copy direction referring to ``SRAM`` is only supported on ``(m)tp_2xx`` and higher.
 *
 * \rst
 *
 *      .. _f11.6:
 *      .. figure:: ../img/11.6.png
 *
 *         Example of Memcpy with Stride
 *
 * Memory copy with stride is shown in Figure :ref:`f11.6` . The blue background indicates the data to be copied. Please note that the section number, i.e. ``seg_num``, equals (``<segnum>`` + 1). In this example, ``<segnum>`` is 2, so  ``seg_num`` is 3. Therefore, there are 3 sections of data (figured as 1,1,3,3,5,5). ``<size>`` is 128 bytes. ``<src_stride>`` (interval between every ``<src>`` data section) is 256 bytes. ``<dst_stride>`` (interval between every ``<dst>`` data section) is 192 bytes.
 *
 * \endrst
 *
 * @param[out] dst The address of destination area.
 * @param[in] src The address of source area.
 * @param[in] size The number of bytes to be copied.
 * @param[in] dir Copy direction.
 * @param[out] dst_stride Destination address stride.
 * @param[in] src_stride Source address stride.
 * @param[in] segnum Section number minus one.
 * @param[in] id_dst_cluster Destination cluster ID.
 * @return ``void``.
 * @remark
 * \rst
 *
 * - The alignment constraints of address of ``<dst>`` or ``<src>`` in the interface ``__memcpy`` without or with stride are shown in the table :ref:`alignment_constraints_of_addr_in_memcpy` .
 *
 * .. table:: Alignment Constraints of Address Space in ``__memcpy``
 *    :widths: 18 10 10 10 10 10
 *    :class: longtable
 *    :name: alignment_constraints_of_addr_in_memcpy
 *
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    |Address Space|   tp_110    |  tp_220     |  mtp_220    |  tp_322     |  mtp_322    |
 *    |             |   tp_120    |  tp_270     |  mtp_270    |             |  mtp_372    |
 *    |             |   mtp_100   |             |  mtp_290    |             |             |
 *    +=============+=============+=============+=============+=============+=============+
 *    | GDRAM       |      1B     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM       |      1B     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM        |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM        |     32B     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM        |     32B     |      8B     |      8B     |      8B     |      8B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *
 * - The address of ``__nram__`` space, to which the vector operand ``<src>`` or ``<dst>`` points, must be 64-byte aligned, when ``<dir>`` is NRAM2NRAM without stride on ``(m)tp_2xx`` and higher.
 *
 * - The supported copy directions of the interface ``__memcpy`` without stride on different targets are shown in the table :ref:`Direction Constraints of __memcpy without Stride<direction_constraints_of_conmemcpy_without_stride>` .
 *
 *
 * .. table:: Direction Constraints of ``__memcpy`` without Stride
 *    :widths: 18 10 10 10 10 10
 *    :class: longtable
 *    :name: direction_constraints_of_conmemcpy_without_stride
 *
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    |  Direction  |   tp_110    |  tp_220     |  mtp_220    |  tp_322     |  mtp_322    |
 *    |             |   tp_120    |  tp_270     |  mtp_270    |             |  mtp_372    |
 *    |             |   mtp_100   |             |  mtp_290    |             |             |
 *    +=============+=============+=============+=============+=============+=============+
 *    | GDRAM2GDRAM |      Y      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2LDRAM |      Y      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2SRAM  |      N      |      N      |      Y      |      N      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2NRAM  |      Y      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2WRAM  |      Y      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2GDRAM |      Y      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2LDRAM |      N      |      N      |      N      |      N      |      N      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2SRAM  |      N      |      N      |      Y      |      N      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2NRAM  |      Y      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2WRAM  |      Y      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2GDRAM  |      N      |      N      |      Y      |      N      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2LDRAM  |      N      |      N      |      Y      |      N      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2SRAM   |      N      |      N      |      Y      |      N      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2NRAM   |      N      |      N      |      Y      |      N      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2WRAM   |      N      |      N      |      Y      |      N      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2GDRAM  |      Y      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2LDRAM  |      Y      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2SRAM   |      N      |      N      |      Y      |      N      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2NRAM   |      Y      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2WRAM   |      Y      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2GDRAM  |      Y      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2LDRAM  |      Y      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2SRAM   |      N      |      N      |      Y      |      N      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2NRAM   |      Y      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2WRAM   |      N      |      N      |      N      |      N      |      N      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *
 * - The supported copy directions of the interface ``__memcpy`` with stride on different targets are shown in the table :ref:`Direction Constraints of __memcpy with Stride<direction_constraints_of_memcpy_with_stride>` .
 *
 * .. table:: Direction Constraints of ``__memcpy`` with Stride
 *    :widths: 18 10 10 10 10 10
 *    :class: longtable
 *    :name: direction_constraints_of_memcpy_with_stride
 *
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    |  Direction  |   tp_110    |  tp_220     |  mtp_220    |  tp_322     |  mtp_322    |
 *    |             |   tp_120    |  tp_270     |  mtp_270    |             |  mtp_372    |
 *    |             |   mtp_100   |             |  mtp_290    |             |             |
 *    +=============+=============+=============+=============+=============+=============+
 *    | GDRAM2GDRAM |      N      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2LDRAM |      N      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2SRAM  |      N      |      N      |      Y      |      N      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2NRAM  |      Y      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2WRAM  |      N      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2GDRAM |      N      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2LDRAM |      N      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2SRAM  |      N      |      N      |      Y      |      N      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2NRAM  |      Y      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2WRAM  |      N      |      N      |      N      |      N      |      N      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2GDRAM  |      N      |      N      |      Y      |      N      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2LDRAM  |      N      |      N      |      Y      |      N      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2SRAM   |      N      |      N      |      Y      |      N      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2NRAM   |      N      |      N      |      Y      |      N      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2WRAM   |      N      |      N      |      Y      |      N      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2GDRAM  |      Y      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2LDRAM  |      Y      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2SRAM   |      N      |      N      |      Y      |      N      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2NRAM   |      Y      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2WRAM   |      N      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2GDRAM  |      N      |      N      |      N      |      N      |      N      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2LDRAM  |      N      |      N      |      N      |      N      |      N      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2SRAM   |      N      |      N      |      N      |      N      |      N      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2NRAM   |      N      |      N      |      N      |      N      |      N      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2WRAM   |      N      |      N      |      N      |      N      |      N      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *
 * - The alignment constraints of ``<size>`` in the interface ``__memcpy`` without stride are shown in the table :ref:`Alignment Constraints of size in __memcpy without Stride<alignment_constraints_of_size_in_memcpy_without_stride>` .
 *
 * .. table:: Alignment Constraints of size in __memcpy without Stride
 *    :widths: 18 10 10 10 10 10
 *    :class: longtable
 *    :name: alignment_constraints_of_size_in_memcpy_without_stride
 *
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    |  Direction  |   tp_110    |  tp_220     |  mtp_220    |  tp_322     |  mtp_322    |
 *    |             |   tp_120    |  tp_270     |  mtp_270    |             |  mtp_372    |
 *    |             |   mtp_100   |             |  mtp_290    |             |             |
 *    +=============+=============+=============+=============+=============+=============+
 *    | GDRAM2GDRAM |     32B     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2LDRAM |     32B     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2SRAM  |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2NRAM  |     32B     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2WRAM  |    512B     |     64B     |     64B     |     16B     |     16B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2GDRAM |     32B     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2LDRAM |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2SRAM  |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2NRAM  |     32B     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2WRAM  |    512B     |     64B     |     64B     |     16B     |     16B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2GDRAM  |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2LDRAM  |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2SRAM   |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2NRAM   |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2WRAM   |      NA     |      NA     |     64B     |      NA     |     16B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2GDRAM  |     32B     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2LDRAM  |     32B     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2SRAM   |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2NRAM   |     32B     |    128B     |    128B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2WRAM   |    512B     |     64B     |     64B     |     16B     |     16B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2GDRAM  |    512B     |     64B     |     64B     |     16B     |     16B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2LDRAM  |    512B     |     64B     |     64B     |     16B     |     16B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2SRAM   |      NA     |      NA     |     64B     |      NA     |     16B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2NRAM   |    512B     |     64B     |     64B     |     16B     |     16B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2WRAM   |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *
 * - The alignment constraints of ``<size>`` in the interface ``__memcpy`` with stride are shown in the table :ref:`Alignment Constraints of size in __memcpy with stride<alignment_constraints_of_size_in_memcpy_with_stride>` .
 *
 * .. table:: Alignment Constraints of size in __memcpy with Stride
 *    :widths: 18 10 10 10 10 10
 *    :class: longtable
 *    :name: alignment_constraints_of_size_in_memcpy_with_stride
 *
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    |  Direction  |   tp_110    |  tp_220     |  mtp_220    |  tp_322     |  mtp_322    |
 *    |             |   tp_120    |  tp_270     |  mtp_270    |             |  mtp_372    |
 *    |             |   mtp_100   |             |  mtp_290    |             |             |
 *    +=============+=============+=============+=============+=============+=============+
 *    | GDRAM2GDRAM |      NA     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2LDRAM |      NA     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2SRAM  |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2NRAM  |     32B     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2WRAM  |      NA     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2GDRAM |      NA     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2LDRAM |      NA     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2SRAM  |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2NRAM  |     32B     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2WRAM  |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2GDRAM  |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2LDRAM  |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2SRAM   |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2NRAM   |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2WRAM   |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2GDRAM  |     32B     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2LDRAM  |     32B     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2SRAM   |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2NRAM   |     32B     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2WRAM   |      NA     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2GDRAM  |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2LDRAM  |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2SRAM   |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2NRAM   |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2WRAM   |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *
 * - If the size of the vector with the address space of WRAM is not 8-byte aligned on each LT, the value of the unaligned part is uncertain on ``tp_322`` and ``(m)tp_372``.
 *
 * - The alignment constraints of ``<dst_stride>`` in the interface ``__memcpy`` with stride are shown in the table :ref:`Alignment Constraints of dst_stride in __memcpy with Stride<alignment_constraints_of_destination_stride_in_memcpy_with_stride>` .
 *
 * .. table:: Alignment Constraints of ``dst_stride`` in ``__memcpy`` with Stride
 *    :widths: 18 10 10 10 10 10
 *    :class: longtable
 *    :name: alignment_constraints_of_destination_stride_in_memcpy_with_stride
 *
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    |  Direction  |   tp_110    |  tp_220     |  mtp_220    |  tp_322     |  mtp_322    |
 *    |             |   tp_120    |  tp_270     |  mtp_270    |             |  mtp_372    |
 *    |             |   mtp_100   |             |  mtp_290    |             |             |
 *    +=============+=============+=============+=============+=============+=============+
 *    | GDRAM2GDRAM |      NA     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2LDRAM |      NA     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2SRAM  |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2NRAM  |     32B     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2WRAM  |      NA     |      8B     |      8B     |      8B     |      8B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2GDRAM |      NA     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2LDRAM |      NA     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2SRAM  |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2NRAM  |     32B     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2WRAM  |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2GDRAM  |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2LDRAM  |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2SRAM   |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2NRAM   |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2WRAM   |      NA     |      NA     |      8B     |      NA     |      8B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2GDRAM  |     32B     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2LDRAM  |     32B     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2SRAM   |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2NRAM   |     32B     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2WRAM   |      NA     |      8B     |      8B     |      8B     |      8B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2GDRAM  |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2LDRAM  |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2SRAM   |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2NRAM   |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2WRAM   |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *
 * - The alignment constraints of ``<src_stride>`` in the interface ``__memcpy`` with stride are shown in the table :ref:`Alignment Constraints of src_stride in __memcpy with stride<alignment_constraints_of_source_stride_in_memcpy_with_stride>` .
 *
 *
 * .. table:: Alignment Constraints of ``src_stride`` in ``__memcpy`` with Stride
 *    :widths: 18 10 10 10 10 10
 *    :class: longtable
 *    :name: alignment_constraints_of_source_stride_in_memcpy_with_stride
 *
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    |  Direction  |   tp_110    |  tp_220     |  mtp_220    |  tp_322     |  mtp_322    |
 *    |             |   tp_120    |  tp_270     |  mtp_270    |             |  mtp_372    |
 *    |             |   mtp_100   |             |  mtp_290    |             |             |
 *    +=============+=============+=============+=============+=============+=============+
 *    | GDRAM2GDRAM |      NA     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2LDRAM |      NA     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2SRAM  |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2NRAM  |     32B     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2WRAM  |      NA     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2GDRAM |      NA     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2LDRAM |      NA     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2SRAM  |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2NRAM  |     32B     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2WRAM  |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2GDRAM  |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2LDRAM  |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2SRAM   |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2NRAM   |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2WRAM   |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2GDRAM  |     32B     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2LDRAM  |     32B     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2SRAM   |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2NRAM   |     32B     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2WRAM   |      NA     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2GDRAM  |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2LDRAM  |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2SRAM   |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2NRAM   |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2WRAM   |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *
 * - ``<id_dst_cluster>`` is used when ``<dir>`` is SRAM2SRAM.
 *
 * - ``<size>`` must be a positive integer.
 *
 * - ``<dst_stride>`` must be a positive integer greater than or equal to ``<size>``.
 * - The range of ``<count>`` is [0, 65535].
 * - The ``seg_num`` is ``<count> + 1``.
 *
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * @code
 *
 *     if (clusterId == 0) {
 *       // Step1. load data from GDRAM to cluster0's SRAM
 *       // auto running on MPU, no need to specify coreId == 0x80
 *       __memcpy(S, src, size * coreDim, GDRAM2SRAM);
 *       __sync_cluster();
 *
 *       // Step2. test inside cluster0
 *       __memcpy(A, S + offset, size, SRAM2NRAM);
 *       __memcpy(C, A, size, NRAM2NRAM);
 *       __memcpy(S + offset, C, size, NRAM2SRAM);
 *       __sync_cluster();
 *
 *       // Step3. push S from Cluster0 to Cluster1
 *       __memcpy(S, S, size * coreDim, SRAM2SRAM, clusterId + 1);
 *     }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __memcpy(void* dst,
                                                  const void* src,
                                                  int size,
                                                  mluMemcpyDirection_t dir,
                                                  int id_dst_cluster);

//Group:Memory Copy Functions
/**
 * @brief Copies ``<size>`` bytes data from ``<src>`` source address to ``<dst>`` destination address. Both ``<src>`` and ``<dst>`` are in ``__nram__`` space.
 *
 * We recommended this interface for memory copy within ``__nram__`` space on ``(m)tp_2xx`` series for better performance, but it has 128-bytes alignment constraint.
 *
 * @details
 *
 * @param[out] dst The address of destination area.
 * @param[in] src The address of source area.
 * @param[in] size The number of bytes to be copied.
 * @param[out] dst_stride Destination address stride.
 * @param[in] src_stride Source address stride.
 * @param[in] segnum The number of data blocks to be copied.
 * @return ``void``.
 * @remark
 * - This interface is only supported on ``(m)tp_2xx`` and higher.
 * - ``<size>`` must be divisible by 128;
 * - ``<src>`` and ``<dst>`` must point to ``__nram__`` space;
 * - The address of ``<dst>`` and ``<src>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - ``<dst_stride>`` and ``<src_stride>`` must be greater than or equal to zero, and must be divisible by 64;
 * - ``<segnum>`` is in the range [1, 4096].
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __memcpy_nram_to_nram(void* dst,
                                                               const void* src,
                                                               int size,
                                                               int dst_stride,
                                                               int src_stride,
                                                               int segnum);

//Group:Memory Copy Functions
static __mlu_func__ __mlu_builtin__ void __memcpy_async(void* dst,
                                                        const void* src,
                                                        int size,
                                                        mluMemcpyDirection_t dir);

//Group:Memory Copy Functions
/**
 * @brief Copies ``<size>`` bytes data from source address ``<src>`` to destination address ``<dst>`` asynchronously.
 *
 * The ::__memcpy_async interfaces are supported on all architectures. The memory copy direction referring to ``SRAM`` is only supported on ``(m)tp_2xx`` and higher.
 *
 * \rst
 *
 *      .. _f11.7:
 *      .. figure:: ../img/11.6.png
 *
 *         Example of Async Memcpy with Stride
 *
 * Async Memory copy with stride is shown in Figure :ref:`f11.7` . The blue background indicates the data to be copied. Please note that the section number, i.e. ``seg_num``, equals ``<segnum> + 1``. In this example, ``<segnum>`` is 2, so  ``seg_num`` is 3. Therefore, there are 3 sections of data, figured as 1, 1, 3, 3, 5, 5. ``<size>`` is 128 bytes. ``<src_stride>``, which intervals between every ``<src>`` data section, is 256 bytes. ``<dst_stride>``, which intervals between every ``<dst>`` data section, is 192 bytes.
 *
 * \endrst
 *
 * @param[out] dst The address of destination area.
 * @param[in] src The address of source area.
 * @param[in] size The number of bytes to be copied.
 * @param[in] dir Copy direction.
 * @param[out] dst_stride Destination address stride.
 * @param[in] src_stride Source address stride.
 * @param[in] segnum Section number minus one.
 * @return ``void``.
 * @remark
 * \rst
 *
 * - The alignment constraints of address of ``<dst>`` or ``<src>`` in the interface ``__memcpy_async`` without or with stride are shown in the table :ref:`Alignment Constraints of Address Space in __memcpy<alignment_constraints_of_addr_in_memcpy>` .
 *
 * - The supported copy directions of the interface ``__memcpy_async`` without stride on different targets are shown in the table :ref:`Direction Constraints of __memcpy_async without Stride<memcpy_with_async_and_without_stride>` .
 *
 * .. table:: Direction Constraints of ``__memcpy_async`` without Stride
 *    :widths: 18 10 10 10 10 10
 *    :class: longtable
 *    :name: memcpy_with_async_and_without_stride
 *
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    |  Direction  |   tp_110    |  tp_220     |  mtp_220    |  tp_322     |  mtp_322    |
 *    |             |   tp_120    |  tp_270     |  mtp_270    |             |  mtp_372    |
 *    |             |   mtp_100   |             |  mtp_290    |             |             |
 *    +=============+=============+=============+=============+=============+=============+
 *    | GDRAM2GDRAM |      Y      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2LDRAM |      Y      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2SRAM  |      N      |      N      |      Y      |      N      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2NRAM  |      Y      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2WRAM  |      Y      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2GDRAM |      N      |      N      |      N      |      N      |      N      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2LDRAM |      N      |      N      |      N      |      N      |      N      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2SRAM  |      N      |      N      |      N      |      N      |      N      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2NRAM  |      N      |      N      |      N      |      N      |      N      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2WRAM  |      N      |      N      |      N      |      N      |      N      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2GDRAM  |      N      |      N      |      Y      |      N      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2LDRAM  |      N      |      N      |      N      |      N      |      N      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2SRAM   |      N      |      N      |      N      |      N      |      N      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2NRAM   |      N      |      N      |      Y      |      N      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2WRAM   |      N      |      N      |      Y      |      N      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2GDRAM  |      Y      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2LDRAM  |      N      |      N      |      N      |      N      |      N      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2SRAM   |      N      |      N      |      Y      |      N      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2NRAM   |      Y      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2WRAM   |      Y      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2GDRAM  |      N      |      N      |      N      |      N      |      N      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2LDRAM  |      N      |      N      |      N      |      N      |      N      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2SRAM   |      N      |      N      |      Y      |      N      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2NRAM   |      Y      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2WRAM   |      N      |      N      |      N      |      N      |      N      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *
 * - The supported copy directions of the interface ``__memcpy_async`` with stride on different targets are shown in the table :ref:`Direction Constraints of __memcpy_async with Stride<memcpy_with_async_and_with_stride>` .
 *
 * .. table:: Direction Constraints of ``__memcpy_async`` with Stride
 *    :widths: 18 10 10 10 10 10
 *    :class: longtable
 *    :name: memcpy_with_async_and_with_stride
 *
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    |  Direction  |   tp_110    |  tp_220     |  mtp_220    |  tp_322     |  mtp_322    |
 *    |             |   tp_120    |  tp_270     |  mtp_270    |             |  mtp_372    |
 *    |             |   mtp_100   |             |  mtp_290    |             |             |
 *    +=============+=============+=============+=============+=============+=============+
 *    | GDRAM2GDRAM |      Y      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2LDRAM |      Y      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2SRAM  |      N      |      N      |      Y      |      N      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2NRAM  |      Y      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2WRAM  |      N      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2GDRAM |      N      |      N      |      N      |      N      |      N      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2LDRAM |      N      |      N      |      N      |      N      |      N      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2SRAM  |      N      |      N      |      N      |      N      |      N      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2NRAM  |      N      |      N      |      N      |      N      |      N      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2WRAM  |      N      |      N      |      N      |      N      |      N      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2GDRAM  |      N      |      N      |      Y      |      N      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2LDRAM  |      N      |      N      |      N      |      N      |      N      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2SRAM   |      N      |      N      |      N      |      N      |      N      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2NRAM   |      N      |      N      |      Y      |      N      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2WRAM   |      N      |      N      |      Y      |      N      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2GDRAM  |      Y      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2LDRAM  |      N      |      N      |      N      |      N      |      N      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2SRAM   |      N      |      N      |      Y      |      N      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2NRAM   |      Y      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2WRAM   |      N      |      Y      |      Y      |      Y      |      Y      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2GDRAM  |      N      |      N      |      N      |      N      |      N      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2LDRAM  |      N      |      N      |      N      |      N      |      N      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2SRAM   |      N      |      N      |      N      |      N      |      N      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2NRAM   |      N      |      N      |      N      |      N      |      N      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2WRAM   |      N      |      N      |      N      |      N      |      N      |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *
 * - The alignment constraints of ``<size>`` in the interface ``__memcpy_async`` without stride are shown in the table :ref:`Alignment Constraints of Size in __memcpy_async without Stride<alignment_constraints_of_size_in_memcpy_with_async_and_without_stride>` .
 *
 * .. table:: Alignment Constraints of Size in ``__memcpy_async`` without Stride
 *    :widths: 18 10 10 10 10 10
 *    :class: longtable
 *    :name: alignment_constraints_of_size_in_memcpy_with_async_and_without_stride
 *
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    |  Direction  |   tp_110    |  tp_220     |  mtp_220    |  tp_322     |  mtp_322    |
 *    |             |   tp_120    |  tp_270     |  mtp_270    |             |  mtp_372    |
 *    |             |   mtp_100   |             |  mtp_290    |             |             |
 *    +=============+=============+=============+=============+=============+=============+
 *    | GDRAM2GDRAM |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2LDRAM |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2SRAM  |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2NRAM  |     32B     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2WRAM  |    512B     |     64B     |     64B     |     16B     |     16B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2GDRAM |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2LDRAM |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2SRAM  |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2NRAM  |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2WRAM  |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2GDRAM  |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2LDRAM  |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2SRAM   |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2NRAM   |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2WRAM   |      NA     |      NA     |     64B     |      NA     |     16B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2GDRAM  |     32B     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2LDRAM  |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2SRAM   |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2NRAM   |     32B     |    128B     |    128B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2WRAM   |    512B     |     64B     |     64B     |     16B     |     16B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2GDRAM  |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2LDRAM  |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2SRAM   |      NA     |      NA     |     64B     |      NA     |     16B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2NRAM   |    512B     |     64B     |     64B     |     16B     |     16B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2WRAM   |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *
 * - The alignment constraints of ``<size>`` in the interface ``__memcpy_async`` with stride are shown in the table :ref:`Alignment Constraints of size in __memcpy_async with Stride<alignment_constraints_of_size_in_memcpy_with_async_and_with_stride>` .
 *
 * .. table:: Alignment Constraints of Size in ``__memcpy_async`` with Stride
 *    :widths: 18 10 10 10 10 10
 *    :class: longtable
 *    :name: alignment_constraints_of_size_in_memcpy_with_async_and_with_stride
 *
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    |  Direction  |   tp_110    |  tp_220     |  mtp_220    |  tp_322     |  mtp_322    |
 *    |             |   tp_120    |  tp_270     |  mtp_270    |             |  mtp_372    |
 *    |             |   mtp_100   |             |  mtp_290    |             |             |
 *    +=============+=============+=============+=============+=============+=============+
 *    | GDRAM2GDRAM |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2LDRAM |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2SRAM  |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2NRAM  |     32B     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2WRAM  |      NA     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2GDRAM |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2LDRAM |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2SRAM  |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2NRAM  |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2WRAM  |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2GDRAM  |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2LDRAM  |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2SRAM   |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2NRAM   |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2WRAM   |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2GDRAM  |     32B     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2LDRAM  |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2SRAM   |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2NRAM   |     32B     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2WRAM   |      NA     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2GDRAM  |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2LDRAM  |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2SRAM   |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2NRAM   |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2WRAM   |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *
 * - If the size of the vector with the address space of WRAM is not 8-byte aligned on each LT, the value of the unaligned part is uncertain on ``tp_322`` and ``(m)tp_372``.
 *
 * - The alignment constraints of ``<dst_stride>`` in the interface ``__memcpy_async`` with stride are shown in the table :ref:`Alignment Constraints of dst_stride in __memcpy_async with Stride<alignment_constraints_of_destination_stride_in_memcpy_with_async_and_without_stride>` .
 *
 * .. table:: Alignment Constraints of ``dst_stride`` in ``__memcpy_async`` with Stride
 *    :widths: 18 10 10 10 10 10
 *    :class: longtable
 *    :name: alignment_constraints_of_destination_stride_in_memcpy_with_async_and_without_stride
 *
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    |  Direction  |   tp_110    |  tp_220     |  mtp_220    |  tp_322     |  mtp_322    |
 *    |             |   tp_120    |  tp_270     |  mtp_270    |             |  mtp_372    |
 *    |             |   mtp_100   |             |  mtp_290    |             |             |
 *    +=============+=============+=============+=============+=============+=============+
 *    | GDRAM2GDRAM |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2LDRAM |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2SRAM  |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2NRAM  |     32B     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2WRAM  |      NA     |      8B     |      8B     |      8B     |      8B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2GDRAM |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2LDRAM |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2SRAM  |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2NRAM  |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2WRAM  |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2GDRAM  |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2LDRAM  |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2SRAM   |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2NRAM   |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2WRAM   |      NA     |      NA     |      8B     |      NA     |      8B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2GDRAM  |     32B     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2LDRAM  |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2SRAM   |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2NRAM   |     32B     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2WRAM   |      NA     |      8B     |      8B     |      8B     |      8B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2GDRAM  |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2LDRAM  |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2SRAM   |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2NRAM   |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2WRAM   |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *
 * - The alignment constraints of ``<src_stride>`` in the interface ``__memcpy_async`` with stride are shown in the table :ref:`Alignment Constraints of src_stride in __memcpy_async with Stride<alignment_constraints_of_source_stride_in_memcpy_with_async_and_with_stride>` .
 *
 * .. table:: Alignment Constraints of ``src_stride`` in ``__memcpy_async`` with Stride
 *    :widths: 18 10 10 10 10 10
 *    :class: longtable
 *    :name: alignment_constraints_of_source_stride_in_memcpy_with_async_and_with_stride
 *
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    |  Direction  |   tp_110    |  tp_220     |  mtp_220    |  tp_322     |  mtp_322    |
 *    |             |   tp_120    |  tp_270     |  mtp_270    |             |  mtp_372    |
 *    |             |   mtp_100   |             |  mtp_290    |             |             |
 *    +=============+=============+=============+=============+=============+=============+
 *    | GDRAM2GDRAM |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2LDRAM |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2SRAM  |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2NRAM  |     32B     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | GDRAM2WRAM  |      NA     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2GDRAM |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2LDRAM |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2SRAM  |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2NRAM  |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | LDRAM2WRAM  |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2GDRAM  |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2LDRAM  |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2SRAM   |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2NRAM   |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | SRAM2WRAM   |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2GDRAM  |     32B     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2LDRAM  |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2SRAM   |      NA     |      NA     |      1B     |      NA     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2NRAM   |     32B     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | NRAM2WRAM   |      NA     |      1B     |      1B     |      1B     |      1B     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2GDRAM  |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2LDRAM  |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2SRAM   |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2NRAM   |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *    | WRAM2WRAM   |      NA     |      NA     |      NA     |      NA     |      NA     |
 *    +-------------+-------------+-------------+-------------+-------------+-------------+
 *
 * - ``<size>`` must be a positive integer.
 * - ``<dst_stride>`` must be a positive integer greater than or equal to ``<size>``.
 * - The range of ``<count>`` is [0, 65535].
 * - The ``seg_num`` is ``<count> + 1``.
 *
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __memcpy_async(void* dst,
                                                        const void* src,
                                                        int size,
                                                        mluMemcpyDirection_t dir,
                                                        int dst_stride,
                                                        int src_stride,
                                                        int segnum);

//Group:3D Memory Copy Functions
static __mlu_func__ __mlu_builtin__ void __memcpy_async(void* dst,
                                                        const void* src,
                                                        int size,
                                                        mluMemcpyDirection_t dir,
                                                        int dst_stride0,
                                                        int dst_segnum1,
                                                        int dst_stride1,
                                                        int dst_segnum2,
                                                        int src_stride0,
                                                        int src_segnum1,
                                                        int src_stride1,
                                                        int src_segnum2,
                                                        int id_dst_cluster);

//Group:3D Memory Copy Functions
/**
 * @brief Copies data from source address ``<src>`` to destination address ``<dst>`` asynchronously. The memory copy direction is specified by ``<dir>``.
 *
 * @details Copies data from the ``<src>`` address space to the ``<dst>`` address space in three dimensions asynchronously. Data operation in the source space is:  take the ``<size>`` of the data, operate the ``<src_segnum1>`` times through the ``<src_stride0>``, and then take the ``<src_stride1>`` size to iterate the number of ``<src_segnum2>``. Data operation in the destination space is: take the ``<size>`` of the data, operate the ``<dst_segnum1>`` times through the ``<dst_stride0>``, and then take the ``<dst_stride1>`` size to iterate the number of ``<dst_segnum2>``.
 *
 * @param[out] dst The address of destination area.
 * @param[in] src The address of source area.
 * @param[in] size The byte size of data.
 * @param[in] dir Copy direction.
 * @param[out] dst_stride0 The destination address stride(bytes) in the first dimension.
 * @param[out] dst_segnum1 The destination segment number in the first dimension.
 * @param[out] dst_stride1 The destination address stride(bytes) in the second dimension.
 * @param[out] dst_segnum2 The destination segment number in the second dimension.
 * @param[in] src_stride0 The source address stride(bytes) in the first dimension.
 * @param[in] src_segnum1 The source segment number in the first dimension.
 * @param[in] src_stride1 The source address stride(bytes) in the second dimension.
 * @param[in] src_segnum2 The source segment number in the second dimension.
 * @param[in] id_dst_cluster Destination cluster ID.
 * @return ``void``.
 * @remark
 * - The total number of iterations at the source must be equal to the total number of iterations at the destination. That is, the segment numbers need to satisfy: \f$(dst\_segnum1 + 1) \times (dst\_segnum2 + 1) = (src\_segnum1 + 1) \times (src\_segnum2 + 1)\f$;
 * - The ``<size>`` must be greater than zero, and the absolute value of ``<dst_stride0>`` must be greater than or equal to ``<size>`` unless the value of ``<dst_stride0>`` and ``<dst_segnum1>`` are equal to zero. The absolute value of ``<dst_stride1>`` must be greater than or equal to ``<size>`` unless the value of ``<dst_stride1>`` and ``<dst_segnum2>`` are equal to zero;
 * - If ``<dir>`` is SRAM2SRAM, ``<id_dst_cluster>`` needs to be provided, and vice versa;
 * - The ``<dir>`` of ::__memcpy_async supports transferring data within NRAM, WRAM, SRAM, LDRAM and GDRAM except for WRAM2WRAM;
 * - When ``<dst>`` address space is WRAM, ``<dst_stride0>`` and ``<dst_stride1>`` must be divisible by 8;
 * - When the segment number of destination and source is 0, it means that it is copied once in this dimension. The real segment number value is the given value plus one;
 * - If the size of the vector with the address space of WRAM is not 8-byte aligned on each LT, the value of the unaligned part is uncertain on ``tp_322`` and ``(m)tp_372``.
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *   - BANG Version: ``__BANG_ARCH__ >= 322`` ;
 *   - CNCC Version: ``cncc --version >= 3.2.0`` ;
 *   - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30`` ;
 *   - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322`` .
 *
 * @par Example
 * @code
 *
 *    #include <bang.h>
 *
 *    #define LEN 7
 *    #define IN_STRIDE_0 11
 *    #define IN_STRIDE_1 103
 *    #define IN_SEGNUM_1 7
 *    #define IN_SEGNUM_2 2
 *    #define OUT_STRIDE_0 9
 *    #define OUT_STRIDE_1 67
 *    #define OUT_SEGNUM_1 5
 *    #define OUT_SEGNUM_2 3
 *    #define SIZE (LEN * (IN_SEGNUM_1 + 1) * (IN_SEGNUM_2 + 1))
 *    #define SIZE_IN (IN_STRIDE_1 * (IN_SEGNUM_2 + 1))
 *    #define SIZE_OUT (OUT_STRIDE_1 * (OUT_SEGNUM_2 + 1))
 *
 *    __mlu_entry__ void kernel(unsigned char *dst, unsigned char *src) {
 *      __nram__ unsigned char dst_nram[512];
 *      __nram__ unsigned char src_nram[512];
 *      __memcpy(src_nram, src, 512, GDRAM2NRAM);
 *      __memcpy_async(dst_nram, src_nram, LEN, NRAM2NRAM, OUT_STRIDE_0,
 *                     OUT_SEGNUM_1, OUT_STRIDE_1, OUT_SEGNUM_2, IN_STRIDE_0,
 *                     IN_SEGNUM_1, IN_STRIDE_1, IN_SEGNUM_2);
 *      __memcpy(dst, dst_nram, 512, NRAM2GDRAM);
 *    }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __memcpy_async(void* dst,
                                                        const void* src,
                                                        int size,
                                                        mluMemcpyDirection_t dir,
                                                        int dst_stride0,
                                                        int dst_segnum1,
                                                        int dst_stride1,
                                                        int dst_segnum2,
                                                        int src_stride0,
                                                        int src_segnum1,
                                                        int src_stride1,
                                                        int src_segnum2);

//Group:3D Memory Copy Functions
static __mlu_func__ __mlu_builtin__ void __memcpy(void* dst,
                                                  const void* src,
                                                  int size,
                                                  mluMemcpyDirection_t dir,
                                                  int dst_stride0,
                                                  int dst_segnum1,
                                                  int dst_stride1,
                                                  int dst_segnum2,
                                                  int src_stride0,
                                                  int src_segnum1,
                                                  int src_stride1,
                                                  int src_segnum2,
                                                  int id_dst_cluster);

//Group:3D Memory Copy Functions
/**
 * @brief Copies data from source address ``<src>`` to destination address ``<dst>``. The memory copy direction is specified by ``<dir>``.
 *
 * @details Copies data from the ``<src>`` address space to the ``<dst>`` address space in three dimensions. Data operation in the source space is:  take the ``<size>`` of the data, operate the ``<src_segnum1>`` times through the ``<src_stride0>``, and then take the ``<src_stride1>`` size to iterate the number of ``<src_segnum2>``. Data operation in the destination space is: take the ``<size>`` of the data, operate the ``<dst_segnum1>`` times through the ``<dst_stride0>``, and then take the ``<dst_stride1>`` size to iterate the number of ``<dst_segnum2>``.
 *
 * @param[out] dst The address of destination area.
 * @param[in] src The address of source area.
 * @param[in] size The byte size of data.
 * @param[in] dir Copy direction.
 * @param[out] dst_stride0 The destination address stride(bytes) in the first dimension.
 * @param[out] dst_segnum1 The destination segment number in the first dimension.
 * @param[out] dst_stride1 The destination address stride(bytes) in the second dimension.
 * @param[out] dst_segnum2 The destination segment number in the second dimension.
 * @param[in] src_stride0 The source address stride(bytes) in the first dimension.
 * @param[in] src_segnum1 The source segment number in the first dimension.
 * @param[in] src_stride1 The source address stride(bytes) in the second dimension.
 * @param[in] src_segnum2 The source segment number in the second dimension.
 * @param[in] id_dst_cluster Destination cluster ID.
 * @return ``void``.
 * @remark
 * - The total number of iterations at the source must be equal to the total number of iterations at the destination. That is, the segment numbers need to satisfy: \f$(dst\_segnum1 + 1) \times (dst\_segnum2 + 1) = (src\_segnum1 + 1) \times (src\_segnum2 + 1)\f$;
 * - The ``<size>`` must be greater than zero, and the absolute value of ``<dst_stride0>`` must be greater than or equal to ``<size>`` unless the value of ``<dst_stride0>`` and ``<dst_segnum1>`` are equal to zero. The absolute value of ``<dst_stride1>`` must be greater than or equal to ``<size>`` unless the value of ``<dst_stride1>`` and ``<dst_segnum2>`` are equal to zero;
 * - If ``<dir>`` is SRAM2SRAM, ``<id_dst_cluster>`` needs to be provided, and vice versa;
 * - The ``<dir>`` of memcpy supports transferring data within NRAM, WRAM, SRAM, LDRAM and GDRAM except for WRAM2WRAM;
 * - When ``<dst>`` address space is WRAM, ``<dst_stride0>`` and ``<dst_stride1>`` must be divisible by 8;
 * - When the segment number of destination and source is 0, it means that it is copied once in this dimension. The real segment number value is the given value plus one.
 * - If the size of the vector with the address space of WRAM is not 8‑byte aligned on each LT, the value of the unaligned part is uncertain on ``tp_322`` and ``(m)tp_372``.
 *
 * @par Requirements
 * - Compute capability and version notes:
 *
 *   - BANG Version: ``__BANG_ARCH__ >= 322`` ;
 *   - CNCC Version: ``cncc --version >= 3.0.0`` ;
 *   - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30`` ;
 *   - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= tp_322`` .
 *
 * @par Example
 * @code
 *
 *    #include <bang.h>
 *
 *    #define LEN 7
 *    #define IN_STRIDE_0 11
 *    #define IN_STRIDE_1 103
 *    #define IN_SEGNUM_1 7
 *    #define IN_SEGNUM_2 2
 *    #define OUT_STRIDE_0 9
 *    #define OUT_STRIDE_1 67
 *    #define OUT_SEGNUM_1 5
 *    #define OUT_SEGNUM_2 3
 *    #define SIZE (LEN * (IN_SEGNUM_1 + 1) * (IN_SEGNUM_2 + 1))
 *    #define SIZE_IN (IN_STRIDE_1 * (IN_SEGNUM_2 + 1))
 *    #define SIZE_OUT (OUT_STRIDE_1 * (OUT_SEGNUM_2 + 1))
 *
 *    __mlu_entry__ void kernel(unsigned char *dst, unsigned char *src) {
 *      __nram__ unsigned char dst_nram[512];
 *      __nram__ unsigned char src_nram[512];
 *      __memcpy(src_nram, src, 512, GDRAM2NRAM);
 *      __memcpy(dst_nram, src_nram, LEN, NRAM2NRAM, OUT_STRIDE_0,
 *               OUT_SEGNUM_1, OUT_STRIDE_1, OUT_SEGNUM_2, IN_STRIDE_0,
 *               IN_SEGNUM_1, IN_STRIDE_1, IN_SEGNUM_2);
 *      __memcpy(dst, dst_nram, 512, NRAM2GDRAM);
 *    }
 *
 * @endcode
 */
static __mlu_func__ __mlu_builtin__ void __memcpy(void* dst,
                                                  const void* src,
                                                  int size,
                                                  mluMemcpyDirection_t dir,
                                                  int dst_stride0,
                                                  int dst_segnum1,
                                                  int dst_stride1,
                                                  int dst_segnum2,
                                                  int src_stride0,
                                                  int src_segnum1,
                                                  int src_stride1,
                                                  int src_segnum2);

static __mlu_func__ __mlu_builtin__ void __memcpy_nram_to_remote(void* dst,
                                                                 void* src,
                                                                 int size,
                                                                 int8_t qpid);

static __mlu_func__ __mlu_builtin__ void __memcpy_nram_to_remote_async(void* dst,
                                                                       void* src,
                                                                       int size,
                                                                       int8_t qpid);
static __mlu_func__ __mlu_builtin__ void __memcpy_gdram_to_remote(void* dst,
                                                                  void* src,
                                                                  int size,
                                                                  int8_t qpid);

static __mlu_func__ __mlu_builtin__ void __memcpy_gdram_to_remote_async(void* dst,
                                                                        void* src,
                                                                        int size,
                                                                        int8_t qpid);
static __mlu_func__ __mlu_builtin__ void __memcpy_nram_to_remote_tf32(float* dst,
                                                                      float* src,
                                                                      int size,
                                                                      int8_t qpid);
static __mlu_func__ __mlu_builtin__ void __memcpy_nram_to_remote_tf32_async(float* dst,
                                                                            float* src,
                                                                            int size,
                                                                            int8_t qpid);
static __mlu_func__ __mlu_builtin__ void __memcpy_gdram_to_remote_tf32(float* dst,
                                                                       float* src,
                                                                       int size,
                                                                       int8_t qpid);
static __mlu_func__ __mlu_builtin__ void __memcpy_gdram_to_remote_tf32_async(float* dst,
                                                                             float* src,
                                                                             int size,
                                                                             int8_t qpid);
static __mlu_func__ __mlu_builtin__ void __bang_remote_write(void* dst,
                                                             short value,
                                                             int8_t qpid);
static __mlu_func__ __mlu_builtin__ void __bang_remote_write_sync(void* dst,
                                                                  short value,
                                                                  int8_t qpid);
static __mlu_func__ __mlu_builtin__ void __bang_remote_write_invalidate(void* dst,
                                                                        short value,
                                                                        int8_t qpid);
static __mlu_func__ __mlu_builtin__ void __bang_remote_write_sync_invalidate(void* dst,
                                                                             short value,
                                                                             int8_t qpid);
static __mlu_func__ __mlu_builtin__ void __bang_qpreset(int8_t qpid);

//Group:Memory Setting Functions
/**
 * @brief Sets ``<value>`` to a vector in ``__nram__``.
 *
 * @details Sets a vector in ``__nram__`` space pointed by ``<dst>`` to the specified ``<value>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] elem_count The number of elements to be set.
 * @param[in] value Value to be set.
 * @return ``void``.
 * @remark
 * - ``<dst>`` must point to ``__nram__`` space;
 * - ``<elem_count>`` * ``sizeof(type)`` must be positive and divisible by 64 on ``(m)tp_2xx``;
 * - The address of ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - This interface is supported on ``(m)tp_2xx`` and higher.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __nramset_float(float* dst,
                                                         int elem_count,
                                                         float value);

//Group:Memory Setting Functions
/**
 * @brief Sets ``<value>`` to a vector in ``__nram__``.
 *
 * @details Sets a vector in ``__nram__`` space pointed by ``<dst>`` to the specified ``<value>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] elem_count The number of elements to be set.
 * @param[in] value Value to be set.
 * @return ``void``.
 * @remark
 * - ``<dst>`` must point to ``__nram__`` space;
 * - ``<elem_count>`` must be constant on ``(m)tp_1xx``;
 * - ``<elem_count>`` * ``sizeof(type)`` must be positive and divisible by 64 on ``(m)tp_2xx``;
 * - The address of ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __nramset_half(half* dst,
                                                        int elem_count,
                                                        half value);

//Group:Memory Setting Functions
/**
 * @brief Sets ``<value>`` to a vector in ``__nram__``.
 *
 * @details Sets a vector in ``__nram__`` space pointed by ``<dst>`` to the specified ``<value>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] elem_count The number of elements to be set.
 * @param[in] value Value to be set.
 * @return ``void``.
 * @remark
 * - ``<dst>`` must point to ``__nram__`` space;
 * - ``<elem_count>`` must be constant on ``(m)tp_1xx``;
 * - ``<elem_count>`` * ``sizeof(type)`` must be positive and divisible by 64 on ``(m)tp_2xx``;
 * - The address of ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __nramset_int(int* dst,
                                                       int elem_count,
                                                       int value);

//Group:Memory Setting Functions
/**
 * @brief Sets ``<value>`` to a vector in ``__nram__``.
 *
 * @details Sets a vector in ``__nram__`` space pointed by ``<dst>`` to the specified ``<value>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] elem_count The number of elements to be set.
 * @param[in] value Value to be set.
 * @return ``void``.
 * @remark
 * - ``<dst>`` must point to ``__nram__`` space;
 * - ``<elem_count>`` must be constant on ``(m)tp_1xx``;
 * - ``<elem_count>`` * ``sizeof(type)`` must be positive and divisible by 64 on ``(m)tp_2xx``;
 * - The address of ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __nramset_unsigned_int(unsigned int* dst,
                                                                int elem_count,
                                                                unsigned int value);

//Group:Memory Setting Functions
/**
 * @brief Sets ``<value>`` to a vector in ``__nram__``.
 *
 * @details Sets a vector in ``__nram__`` space pointed by ``<dst>`` to the specified ``<value>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] elem_count The number of elements to be set.
 * @param[in] value Value to be set.
 * @return ``void``.
 * @remark
 * - ``<dst>`` must point to ``__nram__`` space;
 * - ``<elem_count>`` must be constant on ``(m)tp_1xx``;
 * - ``<elem_count>`` * ``sizeof(type)`` must be positive and divisible by 64 on ``(m)tp_2xx``;
 * - The address of ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __nramset_short(short* dst,
                                                         int elem_count,
                                                         short value);

//Group:Memory Setting Functions
/**
 * @brief Sets ``<value>`` to a vector in ``__nram__``.
 *
 * @details Sets a vector in ``__nram__`` space pointed by ``<dst>`` to the specified ``<value>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] elem_count The number of elements to be set.
 * @param[in] value Value to be set.
 * @return ``void``.
 * @remark
 * - ``<dst>`` must point to ``__nram__`` space;
 * - ``<elem_count>`` must be constant on ``(m)tp_1xx``;
 * - ``<elem_count>`` * ``sizeof(type)`` must be positive and divisible by 64 on ``(m)tp_2xx``;
 * - The address of ``<dst>`` must be 64-byte aligned on ``(m)tp_1xx`` and ``(m)tp_2xx``.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __nramset_unsigned_short(unsigned short* dst,
                                                                  int elem_count,
                                                                  unsigned short value);

//Group:Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __nramset(void* dst,
                                                   int elem_count,
                                                   char value);
static __mlu_func__ __mlu_builtin__ void __nramset(void* dst,
                                                   int elem_count,
                                                   signed char value);
static __mlu_func__ __mlu_builtin__ void __nramset(void* dst,
                                                   int elem_count,
                                                   unsigned char value);
//Group:Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __nramset(void* dst,
                                                   int elem_count,
                                                   short value);
static __mlu_func__ __mlu_builtin__ void __nramset(void* dst,
                                                   int elem_count,
                                                   unsigned short value);
//Group:Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __nramset(void* dst,
                                                   int elem_count,
                                                   float value);
//Group:Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __nramset(void* dst,
                                                   int elem_count,
                                                   half value);
static __mlu_func__ __mlu_builtin__ void __nramset(void* dst,
                                                   int elem_count,
                                                   unsigned int value);
//Group:Memory Setting Functions
/**
 * @brief Sets ``<value>`` to a vector in ``__nram__``.
 *
 * @details Sets a vector in ``__nram__`` space pointed by ``<dst>`` to the specified ``<value>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] elem_count The number of elements to be set.
 * @param[in] value Value to be set.
 * @return ``void``.
 * @remark
 * - ``<dst>`` must point to ``__nram__`` space;
 * - ``<elem_count>`` * ``sizeof(type)`` must be positive and divisible by 64 on ``(m)tp_2xx``;
 * - The address of ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - This interface is only supported on ``(m)tp_2xx`` and higher.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __nramset(void* dst,
                                                   int elem_count,
                                                   int value);

//Group:Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __bang_write_value(void* dst,
                                                            int elem_count,
                                                            char value);
static __mlu_func__ __mlu_builtin__ void __bang_write_value(void* dst,
                                                            int elem_count,
                                                            unsigned char value);
static __mlu_func__ __mlu_builtin__ void __bang_write_value(void* dst,
                                                            int elem_count,
                                                            signed char value);
//Group:Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __bang_write_value(void* dst,
                                                            int elem_count,
                                                            int value);
//Group:Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __bang_write_value(void* dst,
                                                            int elem_count,
                                                            short value);
static __mlu_func__ __mlu_builtin__ void __bang_write_value(void* dst,
                                                            int elem_count,
                                                            unsigned short value);
static __mlu_func__ __mlu_builtin__ void __bang_write_value(void* dst,
                                                            int elem_count,
                                                            unsigned int value);
//Group:Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __bang_write_value(void* dst,
                                                            int elem_count,
                                                            float value);
//Group:Memory Setting Functions
/**
 * @brief Sets ``<value>`` to a vector in ``__nram__``.
 *
 * @details Sets a vector in the ``__nram__`` space pointed by ``<dst>`` to the specified ``<value>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] elem_count The number of elements to be set.
 * @param[in] value The value to be set to ``<dst>``.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - The operand ``<dst>`` must point to ``__nram__`` space;
 * - ``<elem_count> * sizeof(<value>)`` must be positive and divisible by 64 ``(m)tp_2xx``;
 * - The address of ``<dst>`` must be 64-byte aligned on ``(m)tp_2xx``;
 * - This interface is only supported on ``(m)tp_2xx`` and higher.
 * \endrst
 *
 * @par Requirements
 *  - Compute capability and version notes:
 *
 *    - BANG Version: ``__BANG_ARCH__ >= 200`` ;
 *    - CNCC Version: ``cncc --version >= 3.2.0`` ;
 *    - BANG Compute Arch Version: ``cncc --bang-arch >= compute_20`` ;
 *    - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= (m)tp_2xx`` .
 *
 * @par Example
 *  - None.
 *
*/
static __mlu_func__ __mlu_builtin__ void __bang_write_value(void* dst,
                                                            int elem_count,
                                                            half value);

//Group:3D Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __bang_write_value(void* dst, int elem_count,
                                                            char value, int stride0,
                                                            int iter1, int stride1,
                                                            int iter2);
static __mlu_func__ __mlu_builtin__ void __bang_write_value(void* dst, int elem_count,
                                                            unsigned char value, int stride0,
                                                            int iter1, int stride1,
                                                            int iter2);
static __mlu_func__ __mlu_builtin__ void __bang_write_value(void* dst, int elem_count,
                                                            signed char value, int stride0,
                                                            int iter1, int stride1,
                                                            int iter2);
//Group:3D Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __bang_write_value(void* dst, int elem_count,
                                                            half value, int stride0,
                                                            int iter1, int stride1,
                                                            int iter2);
//Group:3D Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __bang_write_value(void* dst, int elem_count,
                                                            short value, int stride0,
                                                            int iter1, int stride1,
                                                            int iter2);
static __mlu_func__ __mlu_builtin__ void __bang_write_value(void* dst, int elem_count,
                                                            unsigned short value, int stride0,
                                                            int iter1, int stride1,
                                                            int iter2);
static __mlu_func__ __mlu_builtin__ void __bang_write_value(void* dst, int elem_count,
                                                            unsigned int value, int stride0,
                                                            int iter1, int stride1,
                                                            int iter2);
//Group:3D Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __bang_write_value(void* dst, int elem_count,
                                                            float value, int stride0,
                                                            int iter1, int stride1,
                                                            int iter2);
//Group:3D Memory Setting Functions
/**
 * @brief Sets ``<value>`` to a three-dimensional block in ``__nram__``.
 *
 * @details Sets a three-dimensional block in the ``__nram__`` space pointed by ``<dst>`` to the specified ``<value>``. The way of setting ``<value>`` is that takes the ``<elem_count>`` of the data, operates the ``<iter1> + 1`` times through the ``<stride0>``, and then take the ``<stride1>`` size to iterate the number of ``<iter2> + 1``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] elem_count The number of elements to be set.
 * @param[in] value The value to be set to ``<dst>``.
 * @param[in] stride0 The source address stride(bytes) in the first dimension.
 * @param[in] iter1 The source segment number in the first dimension.
 * @param[in] stride1 The source address stride(bytes) in the second dimension.
 * @param[in] iter2 The source segment number in the second dimension.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - The operand ``<dst>`` must point to ``__nram__`` space;
 * - The operand ``<elem_count>`` must be greater than zero;
 * - The operand ``<stride0>`` must be greater than or equal to ``<elem_count> * sizeof(<value>)``, and the operand ``<stride1>`` must be greater than or equal to ``<stride0> * (<iter1> + 1)``;
 * - The operand ``<iter1>`` and ``<iter2>`` must be greater than or equal to zero; When the value of ``<iter1>`` and ``<iter2>`` is 0, it represents 1, and when the value is 1, it represents 2, and so on;
 * - This interface is supported on ``(m)tp_3xx`` and higher.
 * \endrst
 *
 * @par Requirements
 *  - Compute capability and version notes:
 *
 *    - BANG Version: ``__BANG_ARCH__ >= 322`` ;
 *    - CNCC Version: ``cncc --version >= 3.2.0`` ;
 *    - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30`` ;
 *    - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= (m)tp_3xx`` .
 *
 * @par Example
 *  - None.
 *
*/
static __mlu_func__ __mlu_builtin__ void __bang_write_value(void* dst, int elem_count,
                                                            int value, int stride0,
                                                            int iter1, int stride1,
                                                            int iter2);

//Group:3D Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __nramset(void* dst, int elem_count,
                                                   char value, int stride0,
                                                   int iter1, int stride1,
                                                   int iter2);
//Group:3D Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __nramset(void* dst,
                                                   int elem_count,
                                                   half value, int stride0,
                                                   int iter1, int stride1,
                                                   int iter2);
//Group:3D Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __nramset(void* dst,
                                                   int elem_count,
                                                   short value, int stride0,
                                                   int iter1, int stride1,
                                                   int iter2);
//Group:3D Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __nramset(void* dst,
                                                   int elem_count,
                                                   float value, int stride0,
                                                   int iter1, int stride1,
                                                   int iter2);
//Group:3D Memory Setting Functions
/**
 * @brief Sets ``<value>`` to a three-dimensional block in ``__nram__``.
 *
 * @details Sets the specified ``<value>`` to a three-dimensional block in the ``__nram__`` space pointed by ``<dst>``. The way of setting ``<value>`` is that takes the ``<elem_count>`` of the data, operates the ``<iter1> + 1`` times through the ``<stride0>``, and then takes the ``<stride1>`` size to iterate the number of ``<iter2> + 1``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] elem_count The number of elements to be set.
 * @param[in] value The value to be set to ``<dst>``.
 * @param[in] stride0 The source address stride(bytes) in the first dimension.
 * @param[in] iter1 The source segment number in the first dimension.
 * @param[in] stride1 The source address stride(bytes) in the second dimension.
 * @param[in] iter2 The source segment number in the second dimension.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - The operand ``<dst>`` must point to ``__nram__`` space;
 * - The operand ``<elem_count>`` must be greater than zero;
 * - The operand ``<stride0>`` must be greater than or equal to ``<elem_count> * sizeof(<value>)``, and the operand ``<stride1>`` must be greater than or equal to ``<stride0> * (<iter1> + 1)``;
 * - The operand ``<iter1>`` and ``<iter2>`` must be greater than or equal to zero; When ``<iter1>`` and ``<iter2>`` are 0, they represent 1, and when ``<iter1>`` and ``<iter2>`` are 1, they represent 2, and so on;
 * - This interface is supported on ``(m)tp_3xx`` and higher.
 * \endrst
 *
 * @par Requirements
 *  - Compute capability and version notes:
 *
 *    - BANG Version: ``__BANG_ARCH__ >= 322``;
 *    - CNCC Version: ``cncc --version >= 3.8.0``;
 *    - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *    - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= (m)tp_3xx``.
 *
 * @par Example
 *  - None.
 *
*/
static __mlu_func__ __mlu_builtin__ void __nramset(void* dst,
                                                   int elem_count,
                                                   int value, int stride0,
                                                   int iter1, int stride1,
                                                   int iter2);

//Group:3D Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __sramset(void* dst, int elem_count,
                                                   char value, int stride0,
                                                   int iter1, int stride1,
                                                   int iter2);
//Group:3D Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __sramset(void* dst,
                                                   int elem_count,
                                                   half value, int stride0,
                                                   int iter1, int stride1,
                                                   int iter2);
//Group:3D Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __sramset(void* dst,
                                                   int elem_count,
                                                   short value, int stride0,
                                                   int iter1, int stride1,
                                                   int iter2);
//Group:3D Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __sramset(void* dst,
                                                   int elem_count,
                                                   float value, int stride0,
                                                   int iter1, int stride1,
                                                   int iter2);
//Group:3D Memory Setting Functions
/**
 * @brief Sets ``<value>`` to a three-dimensional block in ``__mlu_shared__``.
 *
 * @details Sets the specified ``<value>`` to a three-dimensional block in the ``__nram__`` space pointed by ``<dst>``. The way of setting ``<value>`` is that takes the ``<elem_count>`` of the data, operates the ``<iter1> + 1`` times through the ``<stride0>``, and then takes the ``<stride1>`` size to iterate the number of ``<iter2> + 1``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] elem_count The number of elements to be set.
 * @param[in] value The value to be set to ``<dst>``.
 * @param[in] stride0 The source address stride(bytes) in the first dimension.
 * @param[in] iter1 The source segment number in the first dimension.
 * @param[in] stride1 The source address stride(bytes) in the second dimension.
 * @param[in] iter2 The source segment number in the second dimension.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - The operand ``<dst>`` must point to ``__mlu_shared__`` space;
 * - The operand ``<elem_count>`` must be greater than zero;
 * - The operand ``<stride0>`` must be greater than or equal to ``<elem_count> * sizeof(<value>)``, and the operand ``<stride1>`` must be greater than or equal to ``<stride0> * (<iter1> + 1)``;
 * - The operand ``<iter1>`` and ``<iter2>`` must be greater than or equal to zero; When ``<iter1>`` and ``<iter2>`` are 0, they represent 1, and when ``<iter1>`` and ``<iter2>`` are 1, they represent 2, and so on;
 * - This interface is supported on ``(m)tp_3xx`` and higher.
 * \endrst
 *
 * @par Requirements
 *  - Compute capability and version notes:
 *
 *    - BANG Version: ``__BANG_ARCH__ >= 322``;
 *    - CNCC Version: ``cncc --version >= 3.8.0``;
 *    - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *    - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= (m)tp_3xx``.
 *
 * @par Example
 *  - None.
 *
*/
static __mlu_func__ __mlu_builtin__ void __sramset(void* dst,
                                                   int elem_count,
                                                   int value, int stride0,
                                                   int iter1, int stride1,
                                                   int iter2);

//Group:3D Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __ldramset(void* dst, int elem_count,
                                                    char value, int stride0,
                                                    int iter1, int stride1,
                                                    int iter2);
//Group:3D Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __ldramset(void* dst,
                                                    int elem_count,
                                                    half value, int stride0,
                                                    int iter1, int stride1,
                                                    int iter2);
//Group:3D Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __ldramset(void* dst,
                                                    int elem_count,
                                                    short value, int stride0,
                                                    int iter1, int stride1,
                                                    int iter2);
//Group:3D Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __ldramset(void* dst,
                                                    int elem_count,
                                                    float value, int stride0,
                                                    int iter1, int stride1,
                                                    int iter2);
//Group:3D Memory Setting Functions
/**
 * @brief Sets ``<value>`` to a three-dimensional block in ``__ldram__``.
 *
 * @details Sets the specified ``<value>`` to a three-dimensional block in the ``__nram__`` space pointed by ``<dst>``. The way of setting ``<value>`` is that takes the ``<elem_count>`` of the data, operates the ``<iter1> + 1`` times through the ``<stride0>``, and then takes the ``<stride1>`` size to iterate the number of ``<iter2> + 1``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] elem_count The number of elements to be set.
 * @param[in] value The value to be set to ``<dst>``.
 * @param[in] stride0 The source address stride(bytes) in the first dimension.
 * @param[in] iter1 The source segment number in the first dimension.
 * @param[in] stride1 The source address stride(bytes) in the second dimension.
 * @param[in] iter2 The source segment number in the second dimension.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - The operand ``<dst>`` must point to ``__ldram__`` space;
 * - The operand ``<elem_count>`` must be greater than zero;
 * - The operand ``<stride0>`` must be greater than or equal to ``<elem_count> * sizeof(<value>)``, and the operand ``<stride1>`` must be greater than or equal to ``<stride0> * (<iter1> + 1)``;
 * - The operand ``<iter1>`` and ``<iter2>`` must be greater than or equal to zero; When ``<iter1>`` and ``<iter2>`` are 0, they represent 1, and when ``<iter1>`` and ``<iter2>`` are 1, they represent 2, and so on;
 * - This interface is supported on ``(m)tp_3xx`` and higher.
 * \endrst
 *
 * @par Requirements
 *  - Compute capability and version notes:
 *
 *    - BANG Version: ``__BANG_ARCH__ >= 322``;
 *    - CNCC Version: ``cncc --version >= 3.8.0``;
 *    - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *    - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= (m)tp_3xx``.
 *
 * @par Example
 *  - None.
 *
*/
static __mlu_func__ __mlu_builtin__ void __ldramset(void* dst,
                                                    int elem_count,
                                                    int value, int stride0,
                                                    int iter1, int stride1,
                                                    int iter2);

//Group:3D Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __gdramset(void* dst, int elem_count,
                                                    char value, int stride0,
                                                    int iter1, int stride1,
                                                    int iter2);
//Group:3D Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __gdramset(void* dst,
                                                    int elem_count,
                                                    half value, int stride0,
                                                    int iter1, int stride1,
                                                    int iter2);
//Group:3D Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __gdramset(void* dst,
                                                    int elem_count,
                                                    short value, int stride0,
                                                    int iter1, int stride1,
                                                    int iter2);
//Group:3D Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __gdramset(void* dst,
                                                    int elem_count,
                                                    float value, int stride0,
                                                    int iter1, int stride1,
                                                    int iter2);
//Group:3D Memory Setting Functions
/**
 * @brief Sets ``<value>`` to a three-dimensional block in ``__mlu_device__``.
 *
 * @details Sets the specified ``<value>`` to a three-dimensional block in the ``__nram__`` space pointed by ``<dst>``. The way of setting ``<value>`` is that takes the ``<elem_count>`` of the data, operates the ``<iter1> + 1`` times through the ``<stride0>``, and then takes the ``<stride1>`` size to iterate the number of ``<iter2> + 1``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] elem_count The number of elements to be set.
 * @param[in] value The value to be set to ``<dst>``.
 * @param[in] stride0 The source address stride(bytes) in the first dimension.
 * @param[in] iter1 The source segment number in the first dimension.
 * @param[in] stride1 The source address stride(bytes) in the second dimension.
 * @param[in] iter2 The source segment number in the second dimension.
 *
 * @return ``void``.
 *
 * @remark
 * \rst
 * - The operand ``<dst>`` must point to ``__mlu_device__`` space;
 * - The operand ``<elem_count>`` must be greater than zero;
 * - The operand ``<stride0>`` must be greater than or equal to ``<elem_count> * sizeof(<value>)``, and the operand ``<stride1>`` must be greater than or equal to ``<stride0> * (<iter1> + 1)``;
 * - The operand ``<iter1>`` and ``<iter2>`` must be greater than or equal to zero; When ``<iter1>`` and ``<iter2>`` are 0, they represent 1, and when ``<iter1>`` and ``<iter2>`` are 1, they represent 2, and so on;
 * - This interface is supported on ``(m)tp_3xx`` and higher.
 * \endrst
 *
 * @par Requirements
 *  - Compute capability and version notes:
 *
 *    - BANG Version: ``__BANG_ARCH__ >= 322``;
 *    - CNCC Version: ``cncc --version >= 3.8.0``;
 *    - BANG Compute Arch Version: ``cncc --bang-arch >= compute_30``;
 *    - MLU Compute Arch Version:  ``cncc --bang-mlu-arch >= (m)tp_3xx``.
 *
 * @par Example
 *  - None.
 *
*/
static __mlu_func__ __mlu_builtin__ void __gdramset(void* dst,
                                                    int elem_count,
                                                    int value, int stride0,
                                                    int iter1, int stride1,
                                                    int iter2);

//Group:Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __sramset(void* dst,
                                                   int elem_count,
                                                   char value);
static __mlu_func__ __mlu_builtin__ void __sramset(void* dst,
                                                   int elem_count,
                                                   unsigned char value);
static __mlu_func__ __mlu_builtin__ void __sramset(void* dst,
                                                   int elem_count,
                                                   signed char value);
//Group:Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __sramset(void* dst,
                                                   int elem_count,
                                                   half value);
static __mlu_func__ __mlu_builtin__ void __sramset(void* dst,
                                                   int elem_count,
                                                   unsigned short value);
static __mlu_func__ __mlu_builtin__ void __sramset(void* dst,
                                                   int elem_count,
                                                   unsigned int value);
//Group:Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __sramset(void* dst,
                                                   int elem_count,
                                                   short value);
//Group:Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __sramset(void* dst,
                                                   int elem_count,
                                                   float value);
//Group:Memory Setting Functions
/**
 * @brief Sets ``<value>`` to a vector in ``__mlu_shared__``.
 *
 * @details Sets a vector in ``__mlu_shared__`` space pointed by ``<dst>`` to the specified ``<value>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] elem_count The number of elements to be set.
 * @param[in] value Value to be set.
 * @return ``void``.
 * @remark
 * - ``<dst>`` must point to ``__mlu_shared__`` space;
 * - ``<elem_count>`` must be positive;
 * - This interface is only supported on ``(m)tp_2xx`` and higher.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __sramset(void* dst,
                                                   int elem_count,
                                                   int value);

//Group:Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __gdramset(void* dst,
                                                    int elem_count,
                                                    char value);
static __mlu_func__ __mlu_builtin__ void __gdramset(void* dst,
                                                    int elem_count,
                                                    unsigned char value);
static __mlu_func__ __mlu_builtin__ void __gdramset(void* dst,
                                                    int elem_count,
                                                    signed char value);
//Group:Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __gdramset(void* dst,
                                                    int elem_count,
                                                    short value);
static __mlu_func__ __mlu_builtin__ void __gdramset(void* dst,
                                                    int elem_count,
                                                    unsigned short value);
static __mlu_func__ __mlu_builtin__ void __gdramset(void* dst,
                                                    int elem_count,
                                                    unsigned int value);
//Group:Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __gdramset(void* dst,
                                                    int elem_count,
                                                    half value);
//Group:Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __gdramset(void* dst,
                                                    int elem_count,
                                                    float value);
//Group:Memory Setting Functions
/**
 * @brief Sets ``<value>`` to a vector in ``__mlu_device__``.
 *
 * @details Sets a vector in ``__mlu_device__`` space pointed by ``<dst>`` to the specified ``<value>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] elem_count The number of elements to be set.
 * @param[in] value Value to be set.
 * @return ``void``.
 * @remark
 * - ``<dst>`` must point to ``__mlu_device__`` space;
 * - This interface is only supported on ``(m)tp_2xx`` and higher.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __gdramset(void* dst,
                                                    int elem_count,
                                                    int value);

//Group:Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __ldramset(void* dst,
                                                    int elem_count,
                                                    char value);
static __mlu_func__ __mlu_builtin__ void __ldramset(void* dst,
                                                    int elem_count,
                                                    unsigned char value);
static __mlu_func__ __mlu_builtin__ void __ldramset(void* dst,
                                                    int elem_count,
                                                    signed char value);
//Group:Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __ldramset(void* dst,
                                                    int elem_count,
                                                    short value);
static __mlu_func__ __mlu_builtin__ void __ldramset(void* dst,
                                                    int elem_count,
                                                    unsigned short value);
static __mlu_func__ __mlu_builtin__ void __ldramset(void* dst,
                                                    int elem_count,
                                                    unsigned int value);
//Group:Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __ldramset(void* dst,
                                                    int elem_count,
                                                    half value);
//Group:Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __ldramset(void* dst,
                                                    int elem_count,
                                                    float value);
//Group:Memory Setting Functions
/**
 * @brief Sets ``<value>`` to a vector in ``__ldram__``.
 *
 * @details Sets a vector in ``__ldram__`` space pointed by ``<dst>`` to the specified ``<value>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] elem_count The number of elements to be set.
 * @param[in] value Value to be set.
 * @return ``void``.
 * @remark
 * - ``<dst>`` must point to ``__ldram__`` space;
 * - This interface is only supported on ``(m)tp_2xx`` and higher.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __ldramset(void* dst,
                                                    int elem_count,
                                                    int value);

//Group:Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __memset_nram(void* dst,
                                                       int elem_count,
                                                       char value);
static __mlu_func__ __mlu_builtin__ void __memset_nram(void* dst,
                                                       int elem_count,
                                                       unsigned char value);
static __mlu_func__ __mlu_builtin__ void __memset_nram(void* dst,
                                                       int elem_count,
                                                       signed char value);
//Group:Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __memset_nram(void* dst,
                                                       int elem_count,
                                                       short value);
static __mlu_func__ __mlu_builtin__ void __memset_nram(void* dst,
                                                       int elem_count,
                                                       unsigned short value);
static __mlu_func__ __mlu_builtin__ void __memset_nram(void* dst,
                                                       int elem_count,
                                                       unsigned int value);
//Group:Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __memset_nram(void* dst,
                                                       int elem_count,
                                                       half value);
//Group:Memory Setting Functions
static __mlu_func__ __mlu_builtin__ void __memset_nram(void* dst,
                                                       int elem_count,
                                                       float value);
//Group:Memory Setting Functions
/**
 * @brief Sets ``<value>`` to a vector in ``__nram__``.
 *
 * @details Sets a vector in ``__nram__`` space pointed by ``<dst>`` to the specified ``<value>``.
 *
 * @param[out] dst The address of destination vector.
 * @param[in] elem_count The number of elements to be set.
 * @param[in] value Value to be set.
 * @return ``void``.
 * @remark
 * - ``<dst>`` must point to ``__nram__`` space;
 * - ``<elem_count>`` must be positive;
 * - This interface is only supported on ``(m)tp_2xx`` and higher.
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ void __memset_nram(void* dst,
                                                       int elem_count,
                                                       int value);

static __mlu_func__ __mlu_builtin__ unsigned int __bang_perf_executed_inst();
static __mlu_func__ __mlu_builtin__ unsigned int __bang_perf_cache_miss();
static __mlu_func__ __mlu_builtin__ unsigned int __bang_perf_compute_alu_low();
static __mlu_func__ __mlu_builtin__ unsigned int __bang_perf_compute_alu_high();
static __mlu_func__ __mlu_builtin__ unsigned int __bang_perf_compute_wfu_low();
static __mlu_func__ __mlu_builtin__ unsigned int __bang_perf_compute_wfu_high();
static __mlu_func__ __mlu_builtin__ unsigned int __bang_perf_compute_nfu_low();
static __mlu_func__ __mlu_builtin__ unsigned int __bang_perf_compute_nfu_high();
static __mlu_func__ __mlu_builtin__ unsigned int __bang_perf_memory_dram_read_low();
static __mlu_func__ __mlu_builtin__ unsigned int __bang_perf_memory_dram_read_high();
static __mlu_func__ __mlu_builtin__ unsigned int __bang_perf_memory_dram_write_low();
static __mlu_func__ __mlu_builtin__ unsigned int __bang_perf_memory_dram_write_high();
static __mlu_func__ __mlu_builtin__ unsigned int __bang_perf_memory_sram_read_low();
static __mlu_func__ __mlu_builtin__ unsigned int __bang_perf_memory_sram_read_high();
static __mlu_func__ __mlu_builtin__ unsigned int __bang_perf_memory_sram_write_low();
static __mlu_func__ __mlu_builtin__ unsigned int __bang_perf_memory_sram_write_high();
static __mlu_func__ __mlu_builtin__ unsigned int __bang_perf_memory_broadcast_low();
static __mlu_func__ __mlu_builtin__ unsigned int __bang_perf_memory_broadcast_high();

//Group:Control Flow And Debugging Functions
/**
 * @brief Similar to standard printf function, prints arguments to screen, formatted by the format string.
 *
 * @details
 *
 * @param[in] fmt The format string, which must be a literal constant string.
 * @return ``void``.
 * @remark
 * \rst
 *
 * - This interface can at most accept 17 parameters including the format string;
 * - ``<fmt>`` must be a literal constant string. For the description of format string, please see Section :ref:`format_output` for more details;
 * - The type of parameters can be different. It must be one of: char, unsigned char, short, unsigned short, int, unsigned int, half, float, char, bool, pointer;
 * - Since this interface involves extremely time-consuming interaction between CPU and MLU, it might cause significant performance degradation;
 * - This interface is supported on all architectures.
 *
 * \endrst
 *
 * @par Requirements
 * - None.
 *
 * @par Example
 * - None.
 */
static __mlu_func__ __mlu_builtin__ int __bang_printf(const char* fmt, ...);

// -----------------------------------------------------------------------------
// TRC APIs
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __trc_active_f16(...);
static __mlu_func__ __mlu_builtin__ void __trc_active_f32(...);
static __mlu_func__ __mlu_builtin__ void __trc_active_sigmoid(...);
static __mlu_func__ __mlu_builtin__ void __trc_active_exp(...);
static __mlu_func__ __mlu_builtin__ void __trc_active_cos(...);
static __mlu_func__ __mlu_builtin__ void __trc_active_sqrt(...);
static __mlu_func__ __mlu_builtin__ void __trc_active_sin(...);
static __mlu_func__ __mlu_builtin__ void __trc_active_tanh(...);
static __mlu_func__ __mlu_builtin__ void __trc_active_sign(...);
static __mlu_func__ __mlu_builtin__ void __trc_active_pow2(...);
static __mlu_func__ __mlu_builtin__ void __trc_active_gelu(...);
static __mlu_func__ __mlu_builtin__ void __trc_active_exphp(...);
static __mlu_func__ __mlu_builtin__ void __trc_active_explt0(...);
static __mlu_func__ __mlu_builtin__ void __trc_active_sqrthp(...);
static __mlu_func__ __mlu_builtin__ void __trc_active_rsqrt(...);
static __mlu_func__ __mlu_builtin__ void __trc_active_rsqrthp(...);
static __mlu_func__ __mlu_builtin__ void __trc_active_reciprocal(...);
static __mlu_func__ __mlu_builtin__ void __trc_active_reciprocalhp(...);
static __mlu_func__ __mlu_builtin__ void __trc_active_recipgt1(...);
static __mlu_func__ __mlu_builtin__ void __trc_active_log(...);
static __mlu_func__ __mlu_builtin__ void __trc_active_loghp(...);
static __mlu_func__ __mlu_builtin__ void __trc_active_geluhp(...);
static __mlu_func__ __mlu_builtin__ void __trc_lut_s16(...);
static __mlu_func__ __mlu_builtin__ void __trc_lut_s32(...);
static __mlu_func__ __mlu_builtin__ void __trc_lut_s8(...);
static __mlu_func__ __mlu_builtin__ void __trc_add(...);
static __mlu_func__ __mlu_builtin__ void __trc_sub(...);
static __mlu_func__ __mlu_builtin__ void __trc_mult(...);
static __mlu_func__ __mlu_builtin__ void __trc_maxequal(...);
static __mlu_func__ __mlu_builtin__ void __trc_minequal(...);
static __mlu_func__ __mlu_builtin__ void __trc_relun(...);
static __mlu_func__ __mlu_builtin__ void __trc_create(...);
static __mlu_func__ __mlu_builtin__ void __trc_slice(...);
static __mlu_func__ __mlu_builtin__ void __trc_memcpy(...);
static __mlu_func__ __mlu_builtin__ void __trc_and(...);
static __mlu_func__ __mlu_builtin__ void __trc_band(...);
static __mlu_func__ __mlu_builtin__ void __trc_or(...);
static __mlu_func__ __mlu_builtin__ void __trc_bor(...);
static __mlu_func__ __mlu_builtin__ void __trc_xor(...);
static __mlu_func__ __mlu_builtin__ void __trc_bxor(...);
static __mlu_func__ __mlu_builtin__ void __trc_not(...);
static __mlu_func__ __mlu_builtin__ void __trc_bnot(...);
static __mlu_func__ __mlu_builtin__ void __trc_eq(...);
static __mlu_func__ __mlu_builtin__ void __trc_eq_bitindex(...);
static __mlu_func__ __mlu_builtin__ void __trc_ne(...);
static __mlu_func__ __mlu_builtin__ void __trc_ne_bitindex(...);
static __mlu_func__ __mlu_builtin__ void __trc_gt(...);
static __mlu_func__ __mlu_builtin__ void __trc_gt_bitindex(...);
static __mlu_func__ __mlu_builtin__ void __trc_ge(...);
static __mlu_func__ __mlu_builtin__ void __trc_ge_bitindex(...);
static __mlu_func__ __mlu_builtin__ void __trc_lt(...);
static __mlu_func__ __mlu_builtin__ void __trc_lt_bitindex(...);
static __mlu_func__ __mlu_builtin__ void __trc_le(...);
static __mlu_func__ __mlu_builtin__ void __trc_le_bitindex(...);
static __mlu_func__ __mlu_builtin__ void __trc_nramset(...);
static __mlu_func__ __mlu_builtin__ void __trc_sramset(...);
static __mlu_func__ __mlu_builtin__ void __trc_gdramset(...);
static __mlu_func__ __mlu_builtin__ void __trc_ldramset(...);
static __mlu_func__ __mlu_builtin__ void __trc_abs(...);
static __mlu_func__ __mlu_builtin__ void __trc_square(...);
static __mlu_func__ __mlu_builtin__ void __trc_accsum(...);
static __mlu_func__ __mlu_builtin__ void __trc_accsum_hp(...);
static __mlu_func__ __mlu_builtin__ void __trc_relu(...);
static __mlu_func__ __mlu_builtin__ void __trc_conv(...);
static __mlu_func__ __mlu_builtin__ void __trc_select(...);
static __mlu_func__ __mlu_builtin__ void __trc_select_bitindex(...);
static __mlu_func__ __mlu_builtin__ unsigned int __trc_select1d(...);
static __mlu_func__ __mlu_builtin__ unsigned int __trc_select1d_bitindex(...);
static __mlu_func__ __mlu_builtin__ void __trc_maskmove(...);
static __mlu_func__ __mlu_builtin__ unsigned int __trc_count(...);
static __mlu_func__ __mlu_builtin__ unsigned int __trc_count_bitindex(...);
static __mlu_func__ __mlu_builtin__ void __trc_findfirst1(...);
static __mlu_func__ __mlu_builtin__ void __trc_findlast1(...);
static __mlu_func__ __mlu_builtin__ unsigned int __trc_findfirst1d(...);
static __mlu_func__ __mlu_builtin__ unsigned int __trc_findlast1d(...);
static __mlu_func__ __mlu_builtin__ void __trc_writezero(...);
static __mlu_func__ __mlu_builtin__ void __trc_pad(...);
static __mlu_func__ __mlu_builtin__ void __trc_pad_inplace(...);
static __mlu_func__ __mlu_builtin__ void __trc_faa(...);
static __mlu_func__ __mlu_builtin__ void __trc_fas(...);
static __mlu_func__ __mlu_builtin__ void __trc_fam(...);
static __mlu_func__ __mlu_builtin__ void __trc_fma(...);
static __mlu_func__ __mlu_builtin__ void __trc_fms(...);
static __mlu_func__ __mlu_builtin__ void __trc_fsa(...);
static __mlu_func__ __mlu_builtin__ void __trc_fsm(...);
static __mlu_func__ __mlu_builtin__ void __trc_fss(...);
static __mlu_func__ __mlu_builtin__ void __trc_avgpool(...);
static __mlu_func__ __mlu_builtin__ void __trc_maxpool(...);
static __mlu_func__ __mlu_builtin__ void __trc_maxpool_index(...);
static __mlu_func__ __mlu_builtin__ void __trc_maxpool_value_index(...);
static __mlu_func__ __mlu_builtin__ void __trc_minpool(...);
static __mlu_func__ __mlu_builtin__ void __trc_minpool_index(...);
static __mlu_func__ __mlu_builtin__ void __trc_minpool_value_index(...);
static __mlu_func__ __mlu_builtin__ void __trc_avgpool_dilation(...);
static __mlu_func__ __mlu_builtin__ void __trc_maxpool_dilation(...);
static __mlu_func__ __mlu_builtin__ void __trc_maxpool_index_dilation(...);
static __mlu_func__ __mlu_builtin__ void __trc_maxpool_value_index_dilation(...);
static __mlu_func__ __mlu_builtin__ void __trc_minpool_dilation(...);
static __mlu_func__ __mlu_builtin__ void __trc_minpool_index_dilation(...);
static __mlu_func__ __mlu_builtin__ void __trc_minpool_value_index_dilation(...);
static __mlu_func__ __mlu_builtin__ void __trc_avgpool_bp(...);
static __mlu_func__ __mlu_builtin__ void __trc_avgpool_bp_dilation(...);
static __mlu_func__ __mlu_builtin__ void __trc_maxpool_bp(...);
static __mlu_func__ __mlu_builtin__ void __trc_maxpool_bp_dilation(...);
static __mlu_func__ __mlu_builtin__ void __trc_unpool(...);
static __mlu_func__ __mlu_builtin__ void __trc_unpool_dilation(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2half(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2half_tz(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2half_oz(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2half_up(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2half_dn(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2half_rd(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2half_rn(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2half_rm(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82half(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82half_tz(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82half_oz(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82half_up(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82half_dn(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82half_rd(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82half_rn(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82half_rm(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2half(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2half_tz(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2half_oz(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2half_up(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2half_dn(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2half_rd(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2half_rn(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2half_rm(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2half(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2half_tz(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2half_oz(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2half_up(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2half_dn(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2half_rd(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2half_rn(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2half_rm(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2half(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2half_tz(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2half_oz(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2half_up(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2half_dn(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2half_rd(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2half_rn(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2half_rm(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2float(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2float_tz(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2float_oz(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2float_up(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2float_dn(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2float_rd(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2float_rn(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2float_rm(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82float(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82float_tz(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82float_oz(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82float_up(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82float_dn(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82float_rd(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82float_rn(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82float_rm(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2float(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2float_tz(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2float_oz(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2float_up(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2float_dn(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2float_rd(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2float_rn(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2float_rm(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2float(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2float_tz(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2float_oz(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2float_up(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2float_dn(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2float_rd(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2float_rn(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2float_rm(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2float(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2float_tz(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2float_oz(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2float_up(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2float_dn(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2float_rd(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2float_rn(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2float_rm(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2int8(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2int8_tz(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2int8_oz(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2int8_up(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2int8_dn(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2int8_rd(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2int8_rn(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2int8_rm(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2int8(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2int8_tz(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2int8_oz(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2int8_up(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2int8_dn(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2int8_rd(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2int8_rn(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2int8_rm(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2int8(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2int8_tz(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2int8_oz(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2int8_up(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2int8_dn(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2int8_rd(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2int8_rn(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2int8_rm(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2int8(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2int8_tz(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2int8_oz(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2int8_up(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2int8_dn(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2int8_rd(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2int8_rn(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2int8_rm(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2int8(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2int8_tz(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2int8_oz(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2int8_up(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2int8_dn(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2int8_rd(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2int8_rn(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2int8_rm(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2short(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2short_tz(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2short_oz(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2short_up(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2short_dn(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2short_rd(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2short_rn(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2short_rm(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2short(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2short_tz(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2short_oz(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2short_up(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2short_dn(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2short_rd(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2short_rn(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2short_rm(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82short(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82short_tz(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82short_oz(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82short_up(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82short_dn(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82short_rd(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82short_rn(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82short_rm(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2short(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2short_tz(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2short_oz(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2short_up(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2short_dn(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2short_rd(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2short_rn(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2short_rm(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2short(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2short_tz(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2short_oz(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2short_up(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2short_dn(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2short_rd(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2short_rn(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2short_rm(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2int(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2int_tz(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2int_oz(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2int_up(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2int_dn(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2int_rd(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2int_rn(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2int_rm(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2int(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2int_tz(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2int_oz(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2int_up(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2int_dn(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2int_rd(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2int_rn(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2int_rm(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82int(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82int_tz(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82int_oz(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82int_up(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82int_dn(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82int_rd(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82int_rn(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82int_rm(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2int(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2int_tz(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2int_oz(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2int_up(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2int_dn(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2int_rd(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2int_rn(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2int_rm(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2int(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2int_tz(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2int_oz(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2int_up(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2int_dn(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2int_rd(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2int_rn(...);
static __mlu_func__ __mlu_builtin__ void __trc_uchar2int_rm(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2uchar(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2uchar_tz(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2uchar_oz(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2uchar_up(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2uchar_dn(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2uchar_rd(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2uchar_rn(...);
static __mlu_func__ __mlu_builtin__ void __trc_half2uchar_rm(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2uchar(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2uchar_tz(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2uchar_oz(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2uchar_up(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2uchar_dn(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2uchar_rd(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2uchar_rn(...);
static __mlu_func__ __mlu_builtin__ void __trc_float2uchar_rm(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82uchar(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82uchar_tz(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82uchar_oz(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82uchar_up(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82uchar_dn(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82uchar_rd(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82uchar_rn(...);
static __mlu_func__ __mlu_builtin__ void __trc_int82uchar_rm(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2uchar(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2uchar_tz(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2uchar_oz(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2uchar_up(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2uchar_dn(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2uchar_rd(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2uchar_rn(...);
static __mlu_func__ __mlu_builtin__ void __trc_short2uchar_rm(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2uchar(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2uchar_tz(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2uchar_oz(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2uchar_up(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2uchar_dn(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2uchar_rd(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2uchar_rn(...);
static __mlu_func__ __mlu_builtin__ void __trc_int2uchar_rm(...);
static __mlu_func__ __mlu_builtin__ void __trc_move(...);
static __mlu_func__ __mlu_builtin__ void __trc_argmax(...);
static __mlu_func__ __mlu_builtin__ void __trc_argmaxabs(...);
static __mlu_func__ __mlu_builtin__ void __trc_argmin(...);
static __mlu_func__ __mlu_builtin__ void __trc_argminabs(...);
static __mlu_func__ __mlu_builtin__ void __trc_atom_add(...);
static __mlu_func__ __mlu_builtin__ void __trc_atom_add_reduce(...);
static __mlu_func__ __mlu_builtin__ void __trc_atom_max(...);
static __mlu_func__ __mlu_builtin__ void __trc_atom_max_reduce(...);
static __mlu_func__ __mlu_builtin__ void __trc_atom_min(...);
static __mlu_func__ __mlu_builtin__ void __trc_atom_min_reduce(...);
static __mlu_func__ __mlu_builtin__ void __trc_atom_exch(...);
static __mlu_func__ __mlu_builtin__ void __trc_atom_exch_reduce(...);
static __mlu_func__ __mlu_builtin__ void __trc_atom_inc(...);
static __mlu_func__ __mlu_builtin__ void __trc_atom_inc_reduce(...);
static __mlu_func__ __mlu_builtin__ void __trc_atom_dec(...);
static __mlu_func__ __mlu_builtin__ void __trc_atom_dec_reduce(...);
static __mlu_func__ __mlu_builtin__ void __trc_atom_and(...);
static __mlu_func__ __mlu_builtin__ void __trc_atom_and_reduce(...);
static __mlu_func__ __mlu_builtin__ void __trc_atom_or(...);
static __mlu_func__ __mlu_builtin__ void __trc_atom_or_reduce(...);
static __mlu_func__ __mlu_builtin__ void __trc_atom_xor(...);
static __mlu_func__ __mlu_builtin__ void __trc_atom_xor_reduce(...);
static __mlu_func__ __mlu_builtin__ void __trc_atom_cas(...);
static __mlu_func__ __mlu_builtin__ void __trc_atom_cas_reduce(...);

// -----------------------------------------------------------------------------
// Grid APIs
// -----------------------------------------------------------------------------
static __mlu_func__ __mlu_builtin__ void __grid_launch_kernel(...);
static __mlu_func__ __mlu_builtin__ void __grid_load(...);
static __mlu_func__ __mlu_builtin__ void __grid_store(...);
static __mlu_func__ __mlu_builtin__ void __grid_move(...);
static __mlu_func__ __mlu_builtin__ void __grid_add(...);
static __mlu_func__ __mlu_builtin__ void __grid_sub(...);
static __mlu_func__ __mlu_builtin__ void __grid_mul(...);
static __mlu_func__ __mlu_builtin__ void __grid_mulh(...);
static __mlu_func__ __mlu_builtin__ void __grid_eq(...);
static __mlu_func__ __mlu_builtin__ void __grid_ne(...);
static __mlu_func__ __mlu_builtin__ void __grid_lt(...);
static __mlu_func__ __mlu_builtin__ void __grid_ge(...);
static __mlu_func__ __mlu_builtin__ void __grid_and(...);
static __mlu_func__ __mlu_builtin__ void __grid_or(...);
static __mlu_func__ __mlu_builtin__ void __grid_xor(...);
static __mlu_func__ __mlu_builtin__ void __grid_max(...);
static __mlu_func__ __mlu_builtin__ void __grid_min(...);
static __mlu_func__ __mlu_builtin__ void __grid_land(...);
static __mlu_func__ __mlu_builtin__ void __grid_lor(...);
static __mlu_func__ __mlu_builtin__ void __grid_lxor(...);
static __mlu_func__ __mlu_builtin__ void __grid_sll(...);
static __mlu_func__ __mlu_builtin__ void __grid_srl(...);
static __mlu_func__ __mlu_builtin__ void __grid_sra(...);
static __mlu_func__ __mlu_builtin__ void __grid_relun(...);
static __mlu_func__ __mlu_builtin__ void __grid_not(...);
static __mlu_func__ __mlu_builtin__ void __grid_lnot(...);
static __mlu_func__ __mlu_builtin__ void __grid_abs(...);
static __mlu_func__ __mlu_builtin__ void __grid_relu(...);
static __mlu_func__ __mlu_builtin__ void __grid_shift_up(...);
static __mlu_func__ __mlu_builtin__ void __grid_shift_down(...);
static __mlu_func__ __mlu_builtin__ void __grid_shift_left(...);
static __mlu_func__ __mlu_builtin__ void __grid_shift_right(...);

#endif  // __BANG_ARCH__ This file only for host-side compilation

#endif  // __BANG_DEVICE_FUNCTIONS_DECLS_H__
